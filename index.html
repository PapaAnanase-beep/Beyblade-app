<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Beyblade ANANAS</title>
<link rel="icon" href="tlo.png" type="image/png">
<link href="https://fonts.googleapis.com/css2?family=Kode+Mono:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dom-to-image-more@2.10.1/dist/dom-to-image-more.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    /* ============================================= */
    /* === PODSTAWOWE STYLE I UKŁAD APLIKACJI === */
    /* ============================================= */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: 'Kode Mono', monospace;
        background: #101018;
        color: #f0f0f0;
        overflow-x: hidden;
        text-align: center;
    }

    * {
        -webkit-tap-highlight-color: transparent;
        box-sizing: border-box;
    }

    button, a, select, input, textarea {
        outline: none;
    }

    #vanta-background {
        position: fixed;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 0;
    }

    #app-container {
        position: relative;
        z-index: 1;
        min-height: 100vh;
        padding: 20px;
        margin-left: 50px;
        transition: margin-left 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .page {
        display: none;
        padding-top: 20px;
        animation: fadeInPage 0.5s ease-in-out;
    }

    .page.active {
        display: block;
    }

    @keyframes fadeInPage {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    /* ========================================= */
    /* === EKRAN ŁADOWANIA (LOADER) === */
    /* ========================================= */
    #loader-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: #101018;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 10001;
        transition: opacity 0.7s ease-in-out;
        opacity: 1;
    }

    #loader-overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .loader-spinner {
        border: 6px solid rgba(255, 255, 255, 0.2);
        border-top: 6px solid #a25ff0;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1.2s linear infinite;
    }

    .loader-text {
        margin-top: 20px;
        color: #ccc;
        font-size: 1.5em;
        font-family: monospace;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    #app-container, .sidebar {
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
    }

    #app-container.loaded, .sidebar.loaded {
        visibility: visible;
        opacity: 1;
    }

    /* ========================================= */
    /* === PASEK BOCZNY (SIDEBAR) === */
    /* ========================================= */
    .sidebar {
        height: 100%; width: 50px; position: fixed; top: 0; left: 0;
        background: rgba(30, 30, 30, 0.75);
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        box-shadow: 3px 0 15px rgba(0, 0, 0, 0.6);
        transition: width 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 0 15px 15px 0;
        z-index: 2000;
        display: flex; flex-direction: column;
        overflow-x: hidden;
    }
    .sidebar.expanded { width: 260px; }
    .openbtn-container { width: 100%; padding: 10px 0 8px 0; display: flex; }
    .sidebar.expanded .openbtn-container { padding-left: 10px; padding-right: 10px; }
    .openbtn { cursor: pointer; display: flex; align-items: center; gap: 12px; border-radius: 10px; transition: background-color 0.25s ease; padding: 10px; margin: 0 auto; }
    .sidebar.expanded .openbtn { margin: 0; }
    .openbtn img { width: 28px; height: 28px; display: block; flex-shrink: 0; }
    .openbtn .menu-text { color: #f0f0f0; font-size: 1.0em; font-weight: bold; opacity: 0; max-width: 0; overflow: hidden; white-space: nowrap; transition: opacity 0.25s ease 0.1s, max-width 0.25s ease 0.1s; }
    .sidebar.expanded .openbtn .menu-text { opacity: 1; max-width: 120px; }
    .sidebar-links { width: 100%; overflow-y: auto; max-height: calc(100% - 70px); }
    /* POPRAWKA SELEKTORA - dotyczy tylko linków w menu */
    .sidebar .sidebar-links a { display: flex; align-items: center; gap: 12px; color: #e0e0e0; text-decoration: none; transition: background-color 0.25s ease, color 0.25s ease; border-radius: 8px; white-space: nowrap; overflow: hidden; padding: 12px; justify-content: center; width: auto; margin: 4px auto; }
    .sidebar:not(.expanded) .sidebar-links a span { display: none; }
    .sidebar.expanded .sidebar-links a { width: calc(100% - 20px); margin: 4px 10px; padding: 12px 10px; justify-content: flex-start; }
    .sidebar a:hover { background: rgba(70, 70, 70, 0.8); }
    .sidebar a img { width: 22px; height: 22px; flex-shrink: 0; }
    .sidebar a.active-link { background: rgba(138, 43, 226, 0.4); font-weight: bold; color: #fff; }
    .sidebar a.active-link:hover { background: rgba(138, 43, 226, 0.5); }
    .sidebar a.help-link:hover { background: rgba(50, 140, 220, 0.6); }

    /* ========================================= */
    /* === OGÓLNE ELEMENTY FORMULARZY === */
    /* ========================================= */
    label { display: block; margin-bottom: 5px; color: #ccc; font-size: 0.9em; text-align: left; }
    select, input[type="text"], input[type="number"], input[type="url"], input[type="search"], textarea {
        width: 100%;
        padding: 12px 15px;
        margin: 0 0 10px 0;
        background: rgba(45, 45, 55, 0.8);
        color: #f0f0f0;
        font-family: 'Kode Mono', monospace;
        font-size: 1em;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    select:focus, input:focus, textarea:focus {
        border-color: rgba(138, 43, 226, 0.7);
        box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.25);
    }
    textarea { resize: vertical; min-height: 80px; }

    /* ========================================= */
    /* === PRZYCISKI I KARTY (CARDS) === */
    /* ========================================= */
    button { cursor: pointer; background: rgba(80, 85, 95, 0.8); color: #f0f0f0; transition: background-color 0.2s ease, transform 0.1s ease; border: 1px solid rgba(255, 255, 255, 0.1); padding: 12px 18px; font-family: 'Kode Mono', monospace; font-size: 1em; border-radius: 8px; font-weight: bold; }
    button:hover { background: rgba(100, 105, 115, 0.9); }
    button:active { transform: scale(0.97); }
    button:disabled { background: rgba(60, 60, 70, 0.7); color: #888; cursor: not-allowed; }
    button.danger-btn { background: rgba(190, 50, 50, 0.7); }
    button.danger-btn:hover { background: rgba(210, 60, 60, 0.8); }
    .card { background: rgba(35, 35, 45, 0.75); backdrop-filter: blur(6px); border-radius: 15px; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); padding: 20px; margin: 15px 0; text-align: center; }
    .card h2, .page > h2 { margin-top: 0; margin-bottom: 20px; color: #a25ff0; font-weight: bold; text-align: center; }
    .card h3 { margin-top: 0; margin-bottom: 15px; color: #b27ff0; font-weight: bold; }
    .card h4 { margin-top: 0; margin-bottom: 8px; color: #c080ff; font-weight: bold; }
    .card p { font-size: 0.95em; line-height: 1.6; color: #d0d0d0; }
    .card p strong { color: #a25ff0; }
    
    /* ========================================= */
    /* === MAGAZYN I FILTRY === */
    /* ========================================= */
    #magazyn-filtry-container { display: flex; flex-wrap: wrap; justify-content: center; align-items: flex-end; gap: 20px; padding-bottom: 10px; }
    .filtr-item { flex-grow: 1; flex-basis: 220px; max-width: 300px; text-align: left; }
    #magazyn-filtry-container select, #magazyn-filtry-container .search-input-container { margin-bottom: 0 !important; }
    .search-input-container { position: relative; }
    #searchMagazynByName { -webkit-appearance: none; appearance: none; padding: 12px 15px 12px 40px !important; margin: 0; }
    #searchMagazynByName::-webkit-search-cancel-button { -webkit-appearance: none; appearance: none; height: 20px; width: 20px; cursor: pointer; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23999'><path d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/></svg>"); opacity: 0.6; transition: opacity 0.2s; }
    #searchMagazynByName::-webkit-search-cancel-button:hover { opacity: 1; }
    #lista-magazyn { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 15px; }
    #lista-magazyn .card { display: flex; flex-direction: column; justify-content: space-between; padding: 15px; }
  #lista-magazyn img.part-img {
    width: 100px;
    height: 100px;
    object-fit: contain;
    margin-bottom: 10px;
    /* --- NOWE LINIE DO CENTROWANIA --- */
    margin-left: auto;
    margin-right: auto;
}
    #lista-magazyn h3 { font-size: 1.05em; margin: 5px 0; color: #e0e0e0; }
    #lista-magazyn p { font-size: 0.8em; margin: 3px 0; line-height: 1.3; color: #bbb; }
    .item-quantity-controls { display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 12px; }
    .quantity-btn { font-size: 1.2em; padding: 6px 12px; min-width: 40px; }
    .quantity-display { font-size: 1.1em; font-weight: bold; background-color: rgba(0, 0, 0, 0.15); border-radius: 6px; min-width: 30px; text-align: center; padding: 5px 10px; }
    .mode-switch-btn { font-size: 0.75em; padding: 4px 8px; background-color: rgba(138, 43, 226, 0.4); border: 1px solid rgba(138, 43, 226, 0.6); font-weight: normal; }

    /* ========================================= */
    /* === GALERIA DECKÓW I WYKRESY === */
    /* ========================================= */
    #savedDecksContainer { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 15px; }
    .deck-card-set-preview { position: relative; border-radius: 10px; background-color: rgba(0, 0, 0, 0.15); padding: 15px; margin-bottom: 15px; overflow: visible; }
    .deck-card-set-preview:last-child { margin-bottom: 0; }
    .deck-card-set-preview:before { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 180px; height: 180px; background-image: var(--bg-symbol-url); background-repeat: no-repeat; background-position: center; background-size: contain; opacity: 0.15; z-index: 0; }
.wynik-zestaw-obrazki {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    padding: 8px 5px;
	padding-left: 40px;
    /* Linia 'width: 100%;' została usunięta */
    align-self: center; /* Ta linia pomaga w centrowaniu w pionie/poziomie w zależności od kontekstu flex */
}
.wynik-zestaw-obrazki {
    padding: 0;
}
.cx-images-container { 
    flex-direction: column; 
    align-items: center; 
}
.cx-blade-row, .cx-drive-row { 
    width: 100%;
}
    .wynik-zestaw-obrazki img.deck-part-img { height: 60px; max-width: 60px; object-fit: contain; }

    /* ZNAJDŹ I WYKASUJ TEN BLOK */
    .set-info-wrapper {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    

.set-chart-container {
    flex-shrink: 0;
    /* Ustawiamy docelowy, większy rozmiar */
    width: 160px;
    height: 160px;
    position: relative;
}
saved-deck-card {
    padding-right: 25px; /* 20px domyślnego paddingu + 5px dodatkowego */
}
.set-chart-container canvas { width: 100% !important; height: 100% !important; }
    .set-header-container { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; }
    .set-icons-container { display: flex; gap: 8px; padin;}
    .set-icons-container .set-icon { height: 28px; width: 28px; object-fit: contain; border-radius: 5px; padding: 2px;margin-left:10px; }
   /* ======================================================= */
/* === OSTATECZNA POPRAWKA: Statystyki w osobnych liniach === */
/* ======================================================= */
.stat-grid {
    display: block; /* Zmieniamy z flex na block, aby elementy układały się pionowo */
    margin-top: 10px;
    font-size: 0.9em; /* Lekko powiększamy czcionkę dla czytelności */
    line-height: 1.6; /* Zwiększamy odstęp między liniami */
    text-align: left;   /* Wyrównujemy tekst do lewej wewnątrz kolumny statystyk */
    padding-left: 20px; /* Dodajemy wcięcie, aby wyglądało jak lista */
}

/* 
  Ta reguła zamienia każdy element <span> ze statystyką w osobny blok,
  co wymusza jego wyświetlenie w nowej linii.
*/
.stat-grid span {
    display: block; /* KLUCZOWA ZMIANA */
    margin-bottom: 3px; /* Mały odstęp pod każdą statystyką */
}
.stat-grid span { white-space: nowrap; }
    .set-info-wrapper div[style*="break-word"], .set-info-wrapper .stat-grid { word-break: break-all; hyphens: auto; }
    @media (max-width: 500px) { .set-preview-with-chart { flex-direction: column; } .set-chart-container { width: 180px; height: 180px; margin-top: 15px; } }

    /* ========================================= */
    /* === INNE === */
    /* ========================================= */
    .inline-icon { height: 1.5em; width: auto; vertical-align: -0.35em; margin: 0 4px; }
    .action-button-container { background: rgba(40, 40, 50, 0.7); backdrop-filter: blur(10px); border-radius: 12px; padding: 20px; margin-top: 15px; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.45); }
    .action-button-container h4 { margin: 0 0 12px 0; color: #a25ff0; }
    .action-button-container p { font-size: 0.9em; color: #bbb; }
    #notification-bar { position: fixed; top: 0; left: 0; width: 100%; color: white; text-align: center; padding: 14px; font-size: 1em; font-weight: bold; z-index: 10000; display: none; border-radius: 0 0 12px 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.35); opacity: 0; transition: opacity 0.3s ease-in-out; }
    #notification-bar.notification-show { opacity: 1; }
    #generator-obraz img { display: block; max-width: 220px; width: 70%; height: auto; margin: 10px auto; animation: rotateImg 10s linear infinite; border-radius: 12px; }
    .info-panels-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px; }
    .info-panel { text-align: left; display: flex; flex-direction: column; }
    .info-list { max-height: calc(1.6em * 6 + 10px * 5); overflow-y: auto; list-style-position: inside; padding-right: 10px; line-height: 1.6; font-size: 0.9em; }
    @media (max-width: 768px) { .info-panels-container { grid-template-columns: 1fr; } }
    .score-counter-card { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 20px; padding: 25px; align-items: flex-start; }
    .player-section { background-color: rgba(25, 25, 35, 0.6); padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); max-width: 450px; width: 100%; }
    .score-display { font-size: 4.5em; font-weight: bold; background-color: rgba(10,10,10,0.4); padding: 15px 25px; border-radius: 10px; margin-bottom: 20px; border: 2px solid rgba(138, 43, 226, 0.3); }
    .score-buttons button { font-size: 1.1em; padding: 10px 18px; margin: 5px; min-width: 60px; }
    .game-controls { margin-top: 20px;
  flex-basis: 100%;
    width: 100%;
    text-align: center;	}
    .fullscreen-finish-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: black; display: none; justify-content: center; align-items: center; z-index: 9000; opacity: 0; transition: opacity 0.3s ease-in-out; }
    .fullscreen-finish-overlay.visible { display: flex; opacity: 1; }
    .fullscreen-finish-overlay img { max-width: 80vw; max-height: 80vh; object-fit: contain; animation: zoomInFinishImage 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    @keyframes zoomInFinishImage { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    @media (max-width: 600px) { .score-counter-card { padding: 15px; } .player-section { padding: 15px; } .score-display { font-size: 3.5em; } .score-buttons button { font-size: 1em; padding: 8px 15px; } }
    .deck-builder-container { display: flex; gap: 20px; }
    .available-parts-panel { width: 300px; padding: 15px; background: rgba(40,40,50,0.7); border-radius: 10px; height: fit-content; max-height: 70vh; overflow-y: auto; }
    .available-parts-panel h4 { margin: 0 0 10px 0; color: #c080ff; }
    .available-part-item { display: flex; align-items: center; gap: 10px; padding: 8px; margin-bottom: 8px; background: rgba(55,55,65,0.8); border-radius: 6px; cursor: grab; }
    .available-part-item img { width: 40px; height: 40px; object-fit: contain; border-radius: 4px; }
    .dragging { opacity: 0.5; border: 2px dashed #8a2be2; }
    .deck-set-slots-container { flex-grow: 1; }
    .deck-part-slot { min-height: 70px; padding: 10px; margin-bottom: 10px; background: rgba(30,30,40,0.6); border: 2px dashed rgba(255,255,255,0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 10px; }
    .deck-part-slot.drag-over-target { background-color: rgba(138,43,226,0.2); border-color: #8a2be2; }
    .deck-part-slot.filled { border-style: solid; background: rgba(45,45,55,0.7); justify-content: space-between; padding: 5px 10px; }
    .deck-part-slot .part-info-container { display: flex; align-items: center; gap: 8px; }
    .deck-part-slot img { width: 50px; height: 50px; object-fit: contain; }
    .deck-part-slot .remove-part-btn { background: none; border: none; color: #ff6b6b; font-size: 1.3em; cursor: pointer; padding: 5px; }
    .tabs-container { display: flex; margin-bottom: 15px; border-bottom: 2px solid rgba(138, 43, 226, 0.3); }
    .tab-button { padding: 10px 18px; cursor: pointer; background-color: rgba(55, 55, 65, 0.7); color: #ccc; border: none; border-radius: 6px 6px 0 0; font-family: 'Kode Mono', monospace; font-size: 0.95em; transition: all 0.2s; }
    .tab-button:hover { background-color: rgba(70, 70, 80, 0.8); color: #fff; }
    .tab-button.active { background-color: rgba(35,35,45,0.75); color: #a25ff0; border-bottom: 2px solid #a25ff0; }
    @media (max-width: 768px) { .deck-builder-container { flex-direction: column; } .available-parts-panel { width: 100%; max-height: 40vh; } }
    ::-webkit-scrollbar { width: 10px; }
    ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 10px; }
    ::-webkit-scrollbar-thumb { background: rgba(138, 43, 226, 0.5); border-radius: 10px; border: 2px solid transparent; background-clip: content-box; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(138, 43, 226, 0.8); }
    html { scrollbar-width: thin; scrollbar-color: rgba(138, 43, 226, 0.7) rgba(0, 0, 0, 0.2); }
	@keyframes rotateImg {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.deck-card-set-preview.exporting-png::before {
    display: none !important;
}
/* Styl dla tymczasowego obrazka tła przy eksporcie PNG */
.background-symbol-img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 180px;
    height: 180px;
    object-fit: contain;
    z-index: -1; /* Umieść obrazek pod treścią */
    pointer-events: none; /* Zapobiegaj przechwytywaniu kliknięć */
}
/* Styl dla kontenera z ikonką lupy */
.search-input-container {
    position: relative;
}

/* Główne style dla pola wyszukiwania */
#searchMagazynByName {
    /* Usuwa domyślny wygląd w niektórych przeglądarkach */
    -webkit-appearance: none;
    appearance: none;
    
    /* NAJWAŻNIEJSZE: Dodaje wewnętrzny odstęp po lewej stronie, aby zrobić miejsce na ikonkę lupy */
    padding: 12px 15px 12px 40px !important;
    
    margin: 0; /* Usuwa domyślne marginesy */
}
/* Styl dla przycisku 'X' (wyczyść) w przeglądarkach WebKit (Chrome, Safari) */
#searchMagazynByName::-webkit-search-cancel-button {
    -webkit-appearance: none;
    appearance: none;
    height: 20px;
    width: 20px;
    cursor: pointer;
    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23999'><path d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/></svg>");
    opacity: 0.6;
    transition: opacity 0.2s;
}

/* Efekt po najechaniu na przycisk 'X' */
#searchMagazynByName::-webkit-search-cancel-button:hover {
    opacity: 1;
}
/* ======================================================= */
/* === OSTATECZNA POPRAWKA: Style dla nazw pod obrazkami === */
/* ======================================================= */

.part-with-name {
    display: flex;
    flex-direction: column; /* Ustawia obrazek nad tekstem */
    align-items: center;    /* Centruje w poziomie */
    text-align: center;
    max-width: 80px; /* Ogranicza szerokość, by długie nazwy się zawijały */
}

.part-name-label {
    font-size: 0.75em;
    color: #ccc;
    margin-top: 5px;
    line-height: 1.2;
    word-break: break-word; /* Zapewnia zawijanie długich nazw */
    hyphens: auto;
}

/* Poprawka dla kontenera obrazków, aby dać mu więcej przestrzeni */
.wynik-zestaw-obrazki, .cx-images-container {
    display: flex;
    justify-content: center;
    gap: 10px;
    align-items: flex-start;
}
#galeriaDeckow .cx-images-container,
#galeriaDeckow .wynik-zestaw-obrazki:not(.cx-blade-row):not(.cx-drive-row) {
    margin-bottom: 15px;
}
.saved-deck-card .item-actions {
    display: flex;
    justify-content: center; /* Centruje przyciski */
    flex-wrap: wrap;         /* Pozwala zawijać się do nowej linii */
    gap: 10px;               /* DODAJEMY ODSTĘP 10px między przyciskami */
}
.deck-builder-container + .card .action-buttons-wrapper {
    display: flex;
    flex-wrap: wrap;         /* Pozwala zawijać przyciski */
    justify-content: center; /* Centruje przyciski w poziomie */
    gap: 10px;               /* DODAJEMY ODSTĘP MIĘDZY PRZYCISKAMI */
    margin-top: 10px;
}

/*
  Naprawia wysokość slotów, jeśli jakimś cudem
  nadal byłaby nieprawidłowa. Ta reguła gwarantuje, że
  zawsze będą miały minimalną wysokość 70px.
*/
.deck-part-slot {
    min-height: 70px;
}
/* ======================================================= */
/* === OSTATECZNA, KOMPLETNA SEKCJA DLA GALERII DECKÓW === */
/* ======================================================= */

/* --- Główny kontener siatki --- */
#savedDecksContainer {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 15px;
    align-items: start; /* KLUCZOWE: Karty mają własną wysokość */
}

/* --- Przyciski na dole karty decku --- */
.saved-deck-card .item-actions {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 10px;
}

/* --- Pojedyncza karta zestawu (wewnątrz karty decku) --- */
.deck-card-set-preview {
    position: relative;
    border-radius: 10px;
    background-color: rgba(0, 0, 0, 0.25);
    padding: 15px;
    margin-bottom: 15px;
    overflow: hidden; /* Ważne dla z-index */
}
.deck-card-set-preview:last-child { margin-bottom: 0; }

/* --- Poprawne, półprzezroczyste tło --- */
.deck-card-set-preview::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 180px;
    height: 180px;
    background-image: var(--bg-symbol-url);
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
    opacity: 0.15;
    z-index: -1; /* Umieszcza tło POD treścią */
}

/* --- Nagłówek (Zestaw X + ikony) --- */
.set-header-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.set-icons-container { display: flex; gap: 8px; }
.set-icons-container .set-icon { height: 28px; width: 28px; object-fit: contain; }

/* --- Segment obrazków i nazw --- */
.wynik-zestaw-obrazki, .cx-images-container {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 15px;
    align-items: flex-start;
}
.cx-images-container { flex-direction: column; align-items: center; }
.cx-blade-row, .cx-drive-row { display: flex; justify-content: center; gap: 10px; }
.part-with-name { display: flex; flex-direction: column; align-items: center; text-align: center; max-width: 80px; }
.wynik-zestaw-obrazki img.deck-part-img { height: 60px; max-width: 60px; object-fit: contain; }
.part-name-label { font-size: 0.75em; color: #ccc; margin-top: 5px; line-height: 1.2; word-break: break-word; }

/* --- Dolny segment (Statystyki + Wykres) --- */
.set-preview-with-chart {
    display: flex;
    flex-direction: row; /* Zapewnia układ poziomy */
    align-items: center;   /* Wyrównuje w pionie statystyki i wykres */
    gap: 25px;
    width: 100%;
    margin-left: 0; /* Resetuje stary, błędny margines */
}

.stat-grid { display: block; font-size: 0.85em; line-height: 1.6; text-align: left; }
.stat-grid span { display: block; }
.set-chart-container { flex-shrink: 0; width: 140px; height: 140px; position: relative; }
.set-chart-container canvas { width: 100% !important; height: 100% !important; }

/* --- Media Query dla telefonów --- */
@media (max-width: 500px) {
    /* Zmień kierunek na pionowy: Staty na górze, Wykres na dole */
    .set-chart-container {
        width: 180px;
        height: 180px;
        margin-top: 15px;
    }
    .stat-grid {
        text-align: center; /* Na mobilce wycentruj listę statystyk */
    }
}


</style>

</head>
<body>
<div id="loader-overlay">
        <div class="loader-spinner"></div>
        <p class="loader-text">Wczytywanie zasobów...</p>
    </div>
    <!-- ======================================= -->

    <div id="vanta-background"></div>
<div id="vanta-background"></div>
<div id="notification-bar"></div>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
    <div class="openbtn-container">
        <div class="openbtn" id="sidebarToggleBtn" title="Rozwiń/Zwiń menu">
            <img src="menu.png" alt="Menu Icon" id="menu-icon">
            <span class="menu-text" id="menu-btn-text">MENU</span>
        </div>
    </div>
    <div class="sidebar-links">
        <a href="#" onclick="navigateTo('info', this)" title="Informacje i Instrukcja"><img src="info.png" alt="Info"><span>Info</span></a>
        <a href="#" onclick="navigateTo('generator', this)" title="Generator Zestawów"><img src="1.png" alt="Generator"><span>Generator</span></a>
        <a href="#" onclick="navigateTo('magazyn', this)" title="Mój Magazyn Części"><img src="2.png" alt="Magazyn"><span>Magazyn</span></a>
        <a href="#" onclick="navigateTo('licznikPunktow', this)" title="Licznik Punktów"><img src="3.png" alt="Licznik"><span>Licznik</span></a>
        <a href="#" onclick="navigateTo('deck', this)" title="Deck Generator"><img src="4.png" alt="Deck" class="menu-icon"><span>Deck Generator</span></a>
        <a href="#" onclick="navigateTo('galeriaDeckow', this)" title="Moje Zapisane Decki"><img src="5.png" alt="Galeria"><span>Moje Decki</span></a>
        <a href="#" onclick="navigateTo('importexport', this)" title="Ustawienia"><img src="6.png" alt="Import/Eksport"><span>Dane</span></a>
		 <a href="https://discord.com/channels/1344364297941286933/1413086273517916161" target="_blank" class="help-link" title="Potrzebujesz pomocy? Kliknij, aby przejść do Discorda!">
        <img src="img/discord.webp" alt="Help">
        <span>Pomoc (Discord)</span>
    </a>
    </div>
</div>

<!-- NOWY ELEMENT DLA PEŁNOEKRANOWEGO OBRAZKA FINISHU -->
<div id="fullscreenFinishOverlay" class="fullscreen-finish-overlay">
    <img id="fullscreenFinishImage" src="#" alt="Finish Effect">
</div>

<div id="app-container">
    <section id="info" class="page">
        <h2>Witaj w Beyblade App by Ananasek</h2>
        <div id="generator-obraz" style="margin-top:20px; margin-bottom: 20px;">
            <img src="tlo.png" alt="Animowane tło generatora">
        </div>
        <div class="card">
            <h3>Krótka Instrukcja Obsługi</h3>
            <p style="text-align: left; line-height: 1.8;">
                Witaj w aplikacji wspomagającej Twoje rozgrywki i zarządzanie kolekcją Beyblade! Oto kilka wskazówek, jak zacząć:
            </p>
            <ul style="text-align: left; margin-left: 20px; line-height: 1.8;">
                <li><strong>Generator Zestawów:</strong><img src="1.png" alt="Generator Icon" class="inline-icon">Wybierz serię i ilość, a aplikacja wylosuje dla Ciebie części z Twojego magazynu.</li>
                <li><strong>Mój Magazyn:</strong><img src="2.png" alt="Magazyn Icon" class="inline-icon"> Tutaj zarządzasz swoją kolekcją części</li>
                <li><strong>Licznik Punktów:</strong><img src="3.png" alt="Licznik Icon" class="inline-icon"> Prosty licznik do śledzenia wyników podczas rozgrywki</li>
                <li><strong>Deck Generator:</strong><img src="4.png" alt="Deck Icon" class="inline-icon"> Składaj własne decki w oparciu o zasady turniejowe</li>
                <li><strong>Moje Decki:</strong><img src="5.png" alt="Galeria Icon" class="inline-icon"> Przeglądaj, edytuj lub usuwaj decki</li>
                <li><strong>Dane:</strong><img src="6.png" alt="Dane Icon" class="inline-icon"> W tej sekcji możesz importować/eksportować swoje części jak i decki</li>
            </ul>
            <p style="text-align: left; margin-top: 15px;">
                Pamiętaj, aby regularnie zapisywać swoje dane (magazyn i decki) za pomocą opcji eksportu, aby uniknąć ich utraty!
            </p>
            <p style="text-align: center; margin-top: 20px; font-weight: bold;">
                Miłej zabawy i udanych pojedynków!
            </p>
        </div>
    <div class="info-panels-container">

    <div class="card info-panel">
        <h4>Co w planach:</h4>
        <ul class="info-list">
            <li><strong>Aktualnie:</strong> Rozbudowa bazy części, aktualizacja brakujących statystyk.</li>
            <li><strong>W planach:</strong> Optymalizacja obecnych oraz dodawanie nowych funkcji.</li>
            <li style="margin-top: 10px;"><em>Masz sugestie? Daj znać!</em></li>
        </ul>
    </div>

    <div class="card info-panel">
        <h4>Patch Notes:</h4>
        <ul class="info-list">
		<li><strong>v2.2.4:</strong> Dodano wykresy statystyk</li>
		<li><strong>v2.2.3:</strong> Dodano wyszukiwanie po nazwie w magazynie</li>
		<li><strong>v2.2.3:</strong> Dodany Guzik <em>"HELP"</em> do kanału na discordzie</li>
		<li><strong>v2.2.2:</strong> Zmiany wizualne galerii Decków</li>
		<li><strong>v2.2.1:</strong> Możliwość zapisu decku jako png</li>
		<li><strong>v2.2.0:</strong> Dodanie systemu trybów na elementach np.<em>Eclipse</em> i <em>Dual</em> </li>
		<li><strong>v2.1.4:</strong> Rozdzielenie <em>Eclipse</em> na upper i smash mode </li>
		<li><strong>v2.1.3:</strong> Dodano część brakujących statystyk</li>
		<li><strong>v2.1.2:</strong> Dodano Patch Note</li>
		<li><strong>v2.1.1:</strong> Dodano <em>ClockMirage</em> wraz z zasadami dopasowania do niego</li>
        <li><strong>v2.1.0:</strong> Nowa Strona główna Info</li>
		<li><strong>v2.0.3:</strong> Poprawki Graficnze licznika punktów</li>
		<li><strong>v2.0.2:</strong> Dodane Automatyczny update Bazy Dysków</li>
		<li><strong>v2.0.1:</strong> Bugfixy, zwiększony cap losowań</li>
        <li><strong>v2.0.0:</strong> Deck Builder 2.0 Zmiany graficzne</li>
		<li><strong>v1.2.0:</strong> Dodano licznik punków</li>
        <li><strong>v1.1.2:</strong> Poprawa deck buildera</li>
		<li><strong>v1.1.1:</strong> Poprawa zasad dla <em>Turbo</em></li>
        <li><strong>v1.1.0:</strong> Dodano import export dla decków i magazynu</li>
        <li><strong>v1.0.1:</strong> Dodano deck builder oraz status beta części w magazynie oraz obsługe cx</li>
        <li><strong>v1.0.0:</strong> Dodano generator zestawów losowych wraz z ręcznym dodawaniem części</li>
        </ul>
    </div>

</div>
    </section>

    <section id="licznikPunktow" class="page">
        <h2>Licznik Punktów Rozgrywki</h2>
        <div class="card score-counter-card">
            <div class="player-section" data-player-id="player1">
                <h3 id="playerName1">Gracz 1</h3>
                <!-- Obrazek finishu jest teraz globalny, usuwamy stąd lokalne kontenery -->
                <div class="score-display" id="scorePlayer1">0</div>
                <div class="score-buttons">
                    <button onclick="updateScore('player1', 1, 'spin_finish')">Spin </button>
                    <button onclick="updateScore('player1', 2, 'over_finish')">Over </button>
                    <button onclick="updateScore('player1', 2, 'burst_finish')">Burst </button>
                    <button onclick="updateScore('player1', 3, 'xtreme_finish')">Xtreme </button>
                    <button class="danger-btn" onclick="updateScore('player1', -1)" style="margin-left: 10px;">-1</button>
                </div>
                <input type="text" id="inputPlayerName1" placeholder="Wpisz imię Gracza 1" onchange="updatePlayerName('player1')">
            </div>

            <div class="player-section" data-player-id="player2">
                <h3 id="playerName2">Gracz 2</h3>
                 <!-- Obrazek finishu jest teraz globalny, usuwamy stąd lokalne kontenery -->
                <div class="score-display" id="scorePlayer2">0</div>
                <div class="score-buttons">
                    <button onclick="updateScore('player2', 1, 'spin_finish')">Spin </button>
                    <button onclick="updateScore('player2', 2, 'over_finish')">Over </button>
                    <button onclick="updateScore('player2', 2, 'burst_finish')">Burst </button>
                    <button onclick="updateScore('player2', 3, 'xtreme_finish')">Xtreme </button>
                    <button class="danger-btn" onclick="updateScore('player2', -1)" style="margin-left: 10px;">-1</button>
                </div>
                <input type="text" id="inputPlayerName2" placeholder="Wpisz imię Gracza 2" onchange="updatePlayerName('player2')">
            </div>
            <div class="game-controls">
                <button onclick="resetScoresAndImages()">Resetuj Wyniki</button>
            </div>
        </div>
    </section>

    <section id="generator" class="page">
        <h2>Generator Zestawów</h2>
        <div class="card">
            <label for="seriaLosowania">Wybierz Serię do Losowania:</label>
            <select id="seriaLosowania" aria-label="Seria Beybladów do losowania">
                <option value="bx_ux">BX / UX (Blade, Ratchet, Bit)</option>
                <option value="cx">CX (LockChip, Main, Assist, Ratchet, Bit)</option>
            </select>
            <label for="ilosc" style="margin-top:15px;">Wybierz ilość Beybladów do wylosowania:</label>
            <select id="ilosc" aria-label="Ilość Beybladów do wylosowania">
                <option value="1">1</option><option value="2">2</option><option value="3">3</option>
                <option value="4">4</option><option value="5">5</option><option value="6">6</option>
                <option value="7">7</option><option value="8">8</option><option value="9">9</option>
                <option value="10">10</option><option value="11">11</option><option value="12">12</option>
                <option value="13">13</option><option value="14">14</option><option value="15">15</option>
                <option value="16">16</option><option value="17">17</option><option value="18">18</option>
                <option value="19">19</option><option value="20">20</option><option value="21">21</option>
                <option value="22">22</option><option value="23">23</option><option value="24">24</option>
            </select>
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button onclick="LOSUJ()">Losuj Zestawy</button>
                <button onclick="wyczyscLosowanie()" class="cancel-btn">Wyczyść Wyniki</button>
            </div>
        </div>
        <div id="wyniki" style="margin-top:20px;"></div>
        <!-- Dodany kontener dla przycisków zapisu wylosowanego zestawu -->
    
    </section>

    <section id="magazyn" class="page">
        <h2>Mój Magazyn Części</h2>
       <!-- === CAŁY POPRAWIONY KONTENER FILTRÓW === -->
<!-- === OSTATECZNY, POPRAWIONY KONTENER FILTRÓW === -->
<div class="card" id="magazyn-filtry-container">

    <!-- Filtr Kategorii -->
    <div class="filtr-item">
        <label for="filterKategoria">Filtruj według kategorii:</label>
        <select id="filterKategoria" onchange="wyswietlMagazyn()" aria-label="Filtr kategorii części">
            <option value="all">Wszystkie Kategorie</option>
            <optgroup label="Seria BX">
                <option value="blade">Blade (BX)</option>
            </optgroup>
            <optgroup label="Seria UX">
                <option value="ux-blade">Blade (UX)</option>
            </optgroup>
            <optgroup label="Seria CX">
                <option value="cx-lock-chip">CX Lock Chip</option>
                <option value="cx-main-blade">CX Main Blade</option>
                <option value="cx-assist-blade">CX Assist Blade</option>
            </optgroup>
            <optgroup label="Komponenty Wspólne">
                <option value="rachet">Ratchet</option>
                <option value="bit">Bit</option>
            </optgroup>
        </select>
    </div>

    <!-- Pole Wyszukiwania -->
    <div class="filtr-item">
        <label for="searchMagazynByName">Wyszukaj po nazwie:</label>
        <div class="search-input-container">
            <input 
                type="search" 
                id="searchMagazynByName" 
                placeholder="Np. Dran Sword, 3-60..." 
                oninput="wyswietlMagazyn()"
                aria-label="Wyszukaj część po nazwie"
            >
        </div>
    </div>

    <!-- Filtr Posiadania -->
    <div class="filtr-item">
        <label for="filterPosiadane">Pokaż części:</label>
        <select id="filterPosiadane" onchange="wyswietlMagazyn()" aria-label="Filtr posiadanych części">
            <option value="posiadane">Posiadane</option>
            <option value="nieposiadane">Nieposiadane</option>
            <option value="wszystkie_w_bazie">Wszystkie</option>
        </select>
    </div>

</div>

<!-- === KONIEC POPRAWIONEGO KONTENERA FILTRÓW === -->

   
        <div id="lista-magazyn" style="margin-top:15px;"></div>
    </section>

    <section id="deck" class="page">
        <h2>Deck Generator</h2>
        <p style="text-align: center;">Przeciągnij części z panelu do odpowiednich slotów aktywnego zestawu.</p>
        <div class="card" style="margin-bottom: 20px;">
            <h3>Zarządzanie Deckiem</h3>
            <div>
                <label for="deckName" style="display: block; margin-bottom: 5px;">Nazwa Decku:</label>
                <input type="text" id="deckName" placeholder="Np. Mój Deck Turniejowy" style="margin-bottom: 10px;">
            </div>
          <div class="action-buttons-wrapper">
        <button id="saveDeckButton" onclick="saveCurrentDeck()">Zapisz Aktualny Deck</button>
        <button onclick="clearCurrentDeckForBuilder()" class="cancel-btn">Wyczyść Builder</button>
    </div>
     </div>
        <div class="deck-builder-container">
            <div class="available-parts-panel" id="available-parts-panel">
                <h4>Dostępne Części</h4>
                <div class="filter-parts-dnd" style="margin-bottom:15px;">
                    <label for="dndPartTypeFilter">Filtruj części:</label>
                    <select id="dndPartTypeFilter" onchange="renderAvailablePartsList()">
                        <option value="blade">BX Blade</option>
						<option value="ux-blade">UX Blade</option>
                        <option value="cx-lock-chip">CX Lock Chip</option>
                        <option value="cx-main-blade">CX Main Blade</option>
                        <option value="cx-assist-blade">CX Assist Blade</option>
                        <option value="rachet">Ratchet</option>
                        <option value="bit">Bit</option>
                    </select>
                </div>
                <div id="parts-list-for-dnd">
                    <!-- Lista części do przeciągania -->
                </div>
            </div>
            <div class="deck-set-slots-container">
                <div id="deck-set-tabs-container" class="tabs-container">
                    <!-- Guziki zakładek będą generowane przez JS -->
                </div>
                <div id="deck-builder-active-set-slots">
                    <!-- Slotów na aktywny zestaw będą renderowane tutaj przez JS -->
                </div>
            </div>
        </div>
    </section>

    <section id="galeriaDeckow" class="page">
        <h2>Moje Zapisane Decki</h2>
        <p style="text-align: center;">Tutaj znajdziesz wszystkie swoje zapisane konfiguracje decków.</p>
        <div id="savedDecksContainer" style="margin-top: 20px;"></div>
    </section>

    <section id="importexport" class="page">
        <h2>Zarządzanie Danymi Aplikacji</h2>
        <div class="action-button-container import-export-section">
            <h4>Importuj lub Eksportuj Dane Magazynu Części</h4>
            <p style="font-size:0.9em; color:#bbb; margin-bottom:10px;">
                Skopiuj dane z pola poniżej, aby utworzyć kopię zapasową magazynu, lub wklej wcześniej zapisane dane, aby je przywrócić.
            </p>
            <button class="button-auto-width" onclick="eksportujDaneDoPolaTekstowego()">Eksportuj Magazyn</button>
            <textarea id="poleDanychJsonMagazyn" rows="8" placeholder="Dane magazynu JSON..." aria-label="Pole JSON magazynu"></textarea>
            <button class="button-auto-width" onclick="importujDaneZPolaTekstowego()">Importuj Magazyn</button>
        </div>
        <div class="action-button-container import-export-section">
            <h4>Importuj lub Eksportuj Zapisane Decki</h4>
            <p style="font-size:0.9em; color:#bbb; margin-bottom:10px;">
                Skopiuj dane z pola poniżej, aby utworzyć kopię zapasową swoich decków, lub wklej wcześniej zapisane dane, aby je przywrócić.
            </p>
            <button class="button-auto-width" onclick="eksportujDeckiDoPolaTekstowego()">Eksportuj Decki</button>
            <textarea id="poleDanychJsonDecki" rows="8" placeholder="Dane decków JSON..." aria-label="Pole JSON decków"></textarea>
            <button class="button-auto-width" onclick="importujDeckiZPolaTekstowego()">Importuj Decki</button>
        </div>
        <div class="action-button-container">
            <h4>Resetowanie Aplikacji</h4>
            <p style="font-size:0.9em; color:#bbb; margin-bottom:10px;">
                Ta operacja <strong>usunie wszystkie Twoje dane</strong> (magazyn części, zapisane decki, wyniki)
                i przywróci aplikację do stanu początkowego z domyślną bazą części.
            </p>
            <button id="resetAppButton" class="button-auto-width danger-btn" onclick="wykonajPelnyResetAplikacji()" style="margin-top:10px;">
                Resetuj Aplikację (Nieodwracalne)
            </button>
        </div>
    </section>
</div>



<script>
// =================================
// Konfiguracja i Zmienne Globalne
// =================================
const ID_CLOCK_MIRAGE = "206"
let sidebarExpanded = false;
const sidebarWidthExpanded = 260;
const sidebarWidthCollapsed = 50;
let currentEditingDeckId = null; 

let sidebar, appContainer, sidebarToggleBtn, menuIcon, menuBtnText;
let wynikiDivGenerator, placeholderActualImgGenerator;

let ostatnioWylosowaneZestawyGlobalnie = [];

const MAGAZYN_KEY = 'beybladeMagazynAnanasCX_v3';
const SAVED_DECKS_KEY = 'savedBeybladeDecksAnanasCX_v3';
const SCORES_KEY = 'beybladeScoreCounterAnanas';
const DOMYSLNA_BAZA_ZALADOWANA_KEY = 'ananasAppDomyślnaBazaZaladowana_v1'; // Nowy klucz
let currentDeckBeingBuilt = {}; // Zostanie zainicjalizowane w DOMContentLoaded lub przy nawigacji
    let currentlyActiveSetIndexInBuilder = 0; // Domyślnie pierwszy zestaw (indeks 0)
	let imageHideTimeouts = { player1: null, player2: null };
	let fullscreenOverlayHideTimeout = null;
function initializeOrResetCurrentDeck(deckData = null) {
    const defaultSetStructure = () => ({
        seria: 'bx_ux',
        bladeId: null, bladeAktywnyTrybIndex: 0, // Indeks dla trybu Blade
        ratchetId: null,
        bitId: null,
        cx_lock_chipId: null,
        cx_main_bladeId: null, cx_main_bladeAktywnyTrybIndex: 0, // Indeks dla trybu Main Blade
        cx_assist_bladeId: null,
        statystykiObliczone: {}
    });

    if (deckData && deckData.id) {
        currentDeckBeingBuilt = JSON.parse(JSON.stringify(deckData)); // Głęboka kopia
        // Upewnij się, że każdy zestaw ma wszystkie potrzebne klucze, nawet jeśli są null
        currentDeckBeingBuilt.sets = currentDeckBeingBuilt.sets.map(set => ({
            ...defaultSetStructure(), // Zacznij od domyślnej struktury
            ...set // Nadpisz wartościami z wczytanego zestawu
        }));
        // Uzupełnij do 4 zestawów, jeśli jest mniej
        while (currentDeckBeingBuilt.sets.length < 4) {
            currentDeckBeingBuilt.sets.push(defaultSetStructure());
        }
        if (document.getElementById('deckName')) {
            document.getElementById('deckName').value = currentDeckBeingBuilt.name || "";
        }
        currentEditingDeckId = deckData.id; // Ustaw ID edytowanego decku
    } else {
        currentDeckBeingBuilt = {
            name: "",
            id: `temp_deck_${Date.now()}_${Math.random().toString(16).slice(2)}`,
            sets: Array(4).fill(null).map(() => defaultSetStructure())
        };
        if (document.getElementById('deckName')) {
            document.getElementById('deckName').value = "";
        }
        currentEditingDeckId = null; // Resetuj ID edytowanego decku
    }
    console.log("Zainicjalizowano/Zresetowano currentDeckBeingBuilt:", JSON.parse(JSON.stringify(currentDeckBeingBuilt)));
}

    function clearCurrentDeckForBuilder() {
        const deckNameInput = document.getElementById('deckName');
        if(deckNameInput) deckNameInput.value = "";
        initializeOrResetCurrentDeck(); 
        currentEditingDeckId = null; 
        const saveBtn = document.getElementById('saveDeckButton');
        if (saveBtn) saveBtn.textContent = 'Zapisz Aktualny Deck';
        
        currentlyActiveSetIndexInBuilder = 0; // Zresetuj do pierwszej zakładki
        renderDeckBuilderAndParts(); // Odśwież widok buildera (zakładki i sloty)
        showNotification("Builder decku wyczyszczony.", 2000, 'info');
    }
// =================================
// Zarządzanie Magazynem (localStorage)
// =================================
function getMagazyn() {
    try {
        const magazynString = localStorage.getItem(MAGAZYN_KEY);
        return magazynString ? JSON.parse(magazynString) : [];
    } catch (e) { showNotification("Błąd odczytu danych magazynu.", 3000, 'error'); console.error("Błąd odczytu magazynu:", e); return []; }
}
function setMagazyn(magazynArray) {
    try {
        if (Array.isArray(magazynArray)) {
            localStorage.setItem(MAGAZYN_KEY, JSON.stringify(magazynArray));
        } else {
            showNotification("Błąd zapisu: Dane magazynu muszą być tablicą.", 3000, 'error');
            console.error("setMagazyn: Przekazano nie-tablicę:", magazynArray);
        }
    } catch (e) { showNotification("Błąd zapisu danych magazynu.", 3000, 'error'); console.error("Błąd zapisu magazynu:", e); }
}

// =================================
// Zarządzanie Zapisanymi Deckami (localStorage)
// =================================
function getSavedDecks() {
    try {
        const decksString = localStorage.getItem(SAVED_DECKS_KEY);
        return decksString ? JSON.parse(decksString) : [];
    } catch (e) {
        showNotification("Błąd odczytu zapisanych decków.", 3000, 'error');
        console.error("getSavedDecks Błąd:", e);
        return [];
    }
}
function setSavedDecks(decksArray) {
    try {
        if (Array.isArray(decksArray)) {
            localStorage.setItem(SAVED_DECKS_KEY, JSON.stringify(decksArray));
        } else {
            showNotification("Błąd zapisu decków: Nieprawidłowe dane (nie jest tablicą).", 3000, 'error');
            console.error("setSavedDecks: Próba zapisu nie-tablicy:", decksArray);
        }
    } catch (e) {
        showNotification("Błąd zapisu decków do localStorage.", 3000, 'error');
        console.error("setSavedDecks Błąd:", e);
    }
}

// =================================
// Logika Licznika Punktów
// =================================
let scores = { player1: 0, player2: 0 };
let playerNames = { player1: "Gracz 1", player2: "Gracz 2" };

function displayScores() {
    const scoreP1 = document.getElementById('scorePlayer1');
    const scoreP2 = document.getElementById('scorePlayer2');
    if (scoreP1) scoreP1.textContent = scores.player1;
    if (scoreP2) scoreP2.textContent = scores.player2;
}
function displayPlayerNames() {
    const nameP1Display = document.getElementById('playerName1');
    const nameP2Display = document.getElementById('playerName2');
    const nameP1Input = document.getElementById('inputPlayerName1');
    const nameP2Input = document.getElementById('inputPlayerName2');
    if (nameP1Display) nameP1Display.textContent = playerNames.player1;
    if (nameP2Display) nameP2Display.textContent = playerNames.player2;
    if (nameP1Input) nameP1Input.value = playerNames.player1 === "Gracz 1" ? "" : playerNames.player1;
    if (nameP2Input) nameP2Input.value = playerNames.player2 === "Gracz 2" ? "" : playerNames.player2;
}
let backgroundResetTimeouts = { player1: null, player2: null };
const finishBackgroundClasses = ['has-background-spin_finish', 'has-background-over_finish', 'has-background-burst_finish', 'has-background-xtreme_finish']; // Pomocnicza tablica klas

function updateScore(player, points, finishType = null) {
    console.log("updateScore called for:", player, "points:", points, "finishType:", finishType);

    if (!scores || !scores.hasOwnProperty(player)) {
        console.error("Błąd: Obiekt 'scores' lub właściwość dla gracza nie istnieje.", player);
        return;
    }

    scores[player] += points;
    if (typeof displayScores === 'function') displayScores();
    if (typeof saveScoresToLocalStorage === 'function') saveScoresToLocalStorage();

    const overlayElement = document.getElementById('fullscreenFinishOverlay');
    const imageElement = document.getElementById('fullscreenFinishImage');

    if (overlayElement && imageElement) {
        // Wyczyść poprzedni timeout ukrywania nakładki, jeśli istnieje
        if (fullscreenOverlayHideTimeout) {
            clearTimeout(fullscreenOverlayHideTimeout);
            fullscreenOverlayHideTimeout = null;
        }

        if (finishType && points > 0) {
            const imagePath = `img/${finishType}.png`;
            console.log("Setting fullscreen image path to:", imagePath);
            imageElement.src = imagePath;
            imageElement.alt = finishType.replace('_', ' ') + " Finish";

            overlayElement.classList.add('visible'); // Pokaż nakładkę z przejściem

            // Timeout do ukrycia nakładki
            fullscreenOverlayHideTimeout = setTimeout(() => {
                console.log("Timeout: Hiding fullscreen overlay");
                overlayElement.classList.remove('visible');
                // Można dodać opóźnienie na wyczyszczenie src, aby uniknąć "mignięcia"
                setTimeout(() => {
                    if (!overlayElement.classList.contains('visible')) { // Sprawdź, czy nadal jest ukryta
                        imageElement.src = '#';
                    }
                }, 300); // Czas trwania przejścia opacity
                fullscreenOverlayHideTimeout = null;
            }, 1000); // Nakładka zniknie po 2.8 sekundach (dostosuj)

        } else {
            // Jeśli punkty są odejmowane lub brak finishType, upewnij się, że nakładka jest ukryta
            // (chociaż normalnie powinna być już ukryta po timeout'cie)
            if (overlayElement.classList.contains('visible')) {
                 overlayElement.classList.remove('visible');
                 setTimeout(() => { imageElement.src = '#'; }, 300);
            }
        }
    } else {
        console.warn(`Nie znaleziono elementu nakładki (#fullscreenFinishOverlay) lub obrazka (#fullscreenFinishImage)`);
    }
}

function resetScoresAndImages() {
    scores.player1 = 0;
    scores.player2 = 0;
    if (typeof displayScores === 'function') displayScores();
    if (typeof saveScoresToLocalStorage === 'function') saveScoresToLocalStorage();

    const overlayElement = document.getElementById('fullscreenFinishOverlay');
    const imageElement = document.getElementById('fullscreenFinishImage');

    if (overlayElement && imageElement) {
        if (overlayElement.classList.contains('visible')) {
            overlayElement.classList.remove('visible');
            setTimeout(() => { imageElement.src = '#'; }, 300); // Dopasuj do czasu przejścia opacity
        }
    }

    if (fullscreenOverlayHideTimeout) {
        clearTimeout(fullscreenOverlayHideTimeout);
        fullscreenOverlayHideTimeout = null;
    }

    if (typeof showNotification === 'function') {
        showNotification("Wyniki zostały zresetowane.", 2000, 'info');
    }
}


function updatePlayerName(player) {
    const inputElement = document.getElementById(`inputPlayerName${player === 'player1' ? '1' : '2'}`);
    if (inputElement && playerNames.hasOwnProperty(player)) {
        const newName = inputElement.value.trim();
        playerNames[player] = newName !== '' ? newName : (player === 'player1' ? "Gracz 1" : "Gracz 2");
        displayPlayerNames();
        saveScoresToLocalStorage();
    }
}


function saveScoresToLocalStorage() {
    try {
        localStorage.setItem(SCORES_KEY, JSON.stringify({ scores, playerNames }));
    } catch (e) { console.error("Błąd zapisu wyników do localStorage:", e); }
}
function loadScoresFromLocalStorage() {
    try {
        const savedDataString = localStorage.getItem(SCORES_KEY);
        if (savedDataString) {
            const savedData = JSON.parse(savedDataString);
            if (savedData.scores) scores = savedData.scores;
            if (savedData.playerNames) playerNames = savedData.playerNames;
            scores.player1 = parseInt(scores.player1, 10) || 0;
            scores.player2 = parseInt(scores.player2, 10) || 0;
            playerNames.player1 = playerNames.player1 || "Gracz 1";
            playerNames.player2 = playerNames.player2 || "Gracz 2";
        }
    } catch (e) {
        console.error("Błąd odczytu wyników z localStorage:", e);
        scores = { player1: 0, player2: 0 };
        playerNames = { player1: "Gracz 1", player2: "Gracz 2" };
    }
    displayScores(); displayPlayerNames();
}
// =================================
// Funkcje Pomocnicze i Nawigacyjne
// =================================
function showNotification(message, duration = 3000, type = 'info') {
    const bar = document.getElementById("notification-bar");
    if (!bar) { console.error("Element #notification-bar nie znaleziony!"); return; }
    bar.textContent = message;
    bar.className = 'notification-show'; 
    let bgColor = 'rgba(138, 43, 226, 0.9)'; let textColor = '#fff';
    if (type === 'error') bgColor = 'rgba(220, 53, 69, 0.9)';
    else if (type === 'success') bgColor = 'rgba(40, 167, 69, 0.9)';
    else if (type === 'warning') { bgColor = 'rgba(255, 193, 7, 0.9)'; textColor = '#333'; } 
    bar.style.backgroundColor = bgColor; bar.style.color = textColor;
    bar.style.backdropFilter = 'blur(5px)'; bar.style.webkitBackdropFilter = 'blur(5px)';
    bar.style.display = "block"; bar.style.opacity = "1";
    if (bar._hideTimeout) clearTimeout(bar._hideTimeout);
    bar._hideTimeout = setTimeout(() => {
        bar.style.opacity = "0";
        setTimeout(() => { bar.style.display = "none"; }, 300); 
    }, duration);
}

function toggleSidebar() {
    sidebarExpanded = !sidebarExpanded;
    if (sidebar) sidebar.classList.toggle('expanded', sidebarExpanded);
    if (appContainer) appContainer.style.marginLeft = (sidebarExpanded ? sidebarWidthExpanded : sidebarWidthCollapsed) + 'px';
    if (menuIcon && menuBtnText) {
        if (sidebarExpanded) {
            menuIcon.src = 'menu2.png'; menuIcon.alt = "Zamknij"; menuBtnText.textContent = 'ZAMKNIJ MENU';
            if(sidebarToggleBtn) sidebarToggleBtn.title = "Zwiń menu";
        } else {
            menuIcon.src = 'menu.png'; menuIcon.alt = "Menu"; menuBtnText.textContent = 'MENU';
            if(sidebarToggleBtn) sidebarToggleBtn.title = "Rozwiń menu";
        }
    }
}

function navigateTo(pageId, clickedLinkElement) { // Usunięto forceRenderDeckBuilder, bo logika jest teraz wewnątrz
    console.log(`Nawigacja do: ${pageId}`);
    document.querySelectorAll('.sidebar a').forEach(link => link.classList.remove('active-link'));
    if (clickedLinkElement) clickedLinkElement.classList.add('active-link');
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    const page = document.getElementById(pageId);
    if (page) page.classList.add('active');
    else { 
        console.error(`Strona ID '${pageId}' nie znaleziona.`); 
        const fallbackLink = document.querySelector('.sidebar a[onclick*="navigateTo(\'generator"]');
        if (fallbackLink && pageId !== 'generator') navigateTo('generator', fallbackLink); // Wywołanie bez force
        return; 
    }

    if (pageId !== 'deck' && currentEditingDeckId) { 
        const deckNameInput = document.getElementById('deckName');
        if (deckNameInput) deckNameInput.value = '';
        currentEditingDeckId = null; 
        // initializeOrResetCurrentDeck(); // Już niepotrzebne tutaj, bo deck jest czyszczony przed każdym renderowaniem
        const saveBtn = document.getElementById('saveDeckButton');
        if (saveBtn) saveBtn.textContent = 'Zapisz Aktualny Deck';
        console.log("Zresetowano stan edycji decku po opuszczeniu strony 'deck'.");
    }
    
    if (pageId === 'magazyn') wyswietlMagazyn(); 
    else if (pageId === 'deck') {
        if (!currentEditingDeckId) { // Jeśli nie edytujemy, to inicjujemy pusty
             initializeOrResetCurrentDeck();
        }
        // Jeśli currentEditingDeckId jest ustawione, to dane zostaną załadowane przez `edytujDeck` -> `initializeOrResetCurrentDeck(deckData)`
        // a następnie `renderDeckBuilderAndParts`
        renderDeckBuilderAndParts(); 
    } else if (pageId === 'galeriaDeckow') displaySavedDecks();
    else if (pageId === 'licznikPunktow') loadScoresFromLocalStorage();
    
    if (sidebarExpanded && window.innerWidth < 768) toggleSidebar();
}

// =================================
// Wyświetlanie Magazynu
// =================================
function wyswietlMagazyn() {
    const magazynPelny = getMagazyn();
    const lista = document.getElementById('lista-magazyn');
    if (!lista) { console.error("Element #lista-magazyn nie istnieje."); return; }
    lista.innerHTML = '';

    if (!Array.isArray(magazynPelny)) {
        lista.innerHTML = '<div class="card" style="grid-column: 1 / -1; text-align:center;"><p>Błąd wczytywania.</p></div>';
        return;
    }

    // Pobieramy wartości z WSZYSTKICH trzech filtrów
    const filtrKategorii = document.getElementById('filterKategoria')?.value || 'all';
    const filtrPosiadania = document.getElementById('filterPosiadane')?.value || 'posiadane';
    
    // === NOWY KOD: Pobranie wartości z pola wyszukiwania ===
    const frazaWyszukiwania = (document.getElementById('searchMagazynByName')?.value || '').trim().toLowerCase();
    // ========================================================

    let czesciDoWyswietlenia = [...magazynPelny];

    // 1. Filtr posiadania (bez zmian)
    if (filtrPosiadania === 'posiadane') {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => c && (parseInt(c.ilosc, 10) || 0) > 0);
    } else if (filtrPosiadania === 'nieposiadane') {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => c && (parseInt(c.ilosc, 10) || 0) === 0);
    }
    
    // 2. Filtr kategorii (bez zmian)
    if (filtrKategorii !== 'all' && filtrKategorii) {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => c && c.typ === filtrKategorii);
    }

    // === NOWY KOD: Filtrowanie po nazwie ===
    if (frazaWyszukiwania) {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => 
            c && c.nazwa && c.nazwa.toLowerCase().includes(frazaWyszukiwania)
        );
    }
    // =======================================

    // Reszta funkcji pozostaje taka sama
    if (czesciDoWyswietlenia.length === 0) {
        lista.innerHTML = '<div class="card" style="grid-column: 1 / -1; text-align:center;"><p>Brak części pasujących do filtrów.</p></div>';
        return;
    }
    
    // Sortowanie (bez zmian)
    czesciDoWyswietlenia.sort((a, b) => {
        const typA = (a?.typ || "").toLowerCase(); const typB = (b?.typ || "").toLowerCase();
        const nazwaA = (a?.nazwa || "").toLowerCase(); const nazwaB = (b?.nazwa || "").toLowerCase();
        if (typA < typB) return -1; if (typA > typB) return 1;
        if (nazwaA < nazwaB) return -1; if (nazwaA > nazwaB) return 1;
        return 0;
    });

    // Pętla renderująca karty (bez zmian, jest w porządku)
    czesciDoWyswietlenia.forEach((czesc) => {
        if (!czesc || !czesc.typ || typeof czesc.nazwa !== 'string') return;
        const ilosc = parseInt(czesc.ilosc, 10) || 0;
        
        let statyString = '';
        let isBeta = false;
        
        let buttonHTML = '';
        const aktywnyIndex = czesc.aktywnyTrybIndex || 0;
        const aktywnyTryb = (czesc.maTryby && Array.isArray(czesc.tryby)) ? czesc.tryby[aktywnyIndex] : null;

        if (czesc.maTryby && czesc.tryby && czesc.tryby.length > 1 && aktywnyTryb) {
            buttonHTML = `
                <div style="margin-top: 10px;">
                    <button class="mode-switch-btn" onclick="przelaczTrybMagazynu('${czesc.id}')" title="Zmień tryb: ${aktywnyTryb.nazwaTrybu}">
                        ${aktywnyTryb.nazwaTrybu} 🔄
                    </button>
                </div>
            `;
        }
        
        const obrazekDoWyswietlenia = aktywnyTryb?.img || czesc.img;
        const nazwaDoWyswietlenia = aktywnyTryb ? `${czesc.nazwa} <span style="color:#a25ff0;">(${aktywnyTryb.nazwaTrybu})</span>` : czesc.nazwa;
        
        const daneStatystyk = aktywnyTryb || czesc;
        const maStat = (statName) => typeof daneStatystyk[statName] === 'number';
        const jestZeroLubBrak = (statName) => !maStat(statName) || daneStatystyk[statName] === 0;

        if (czesc.typ === 'blade' || czesc.typ === 'ux-blade' || czesc.typ === 'rachet' || czesc.typ === 'cx-main-blade' || czesc.typ === 'cx-assist-blade') {
            if (jestZeroLubBrak('ATK') || jestZeroLubBrak('DEF') || jestZeroLubBrak('STM') || jestZeroLubBrak('waga')) isBeta = true;
            statyString = `ATK:${maStat('ATK') ? daneStatystyk.ATK : 'N/A'}, DEF:${maStat('DEF') ? daneStatystyk.DEF : 'N/A'}, STM:${maStat('STM') ? daneStatystyk.STM : 'N/A'}, Waga:${maStat('waga') ? daneStatystyk.waga : 'N/A'}g`;
        } else if (czesc.typ === 'bit') {
            if (jestZeroLubBrak('ATK') || jestZeroLubBrak('DEF') || jestZeroLubBrak('STM') || jestZeroLubBrak('waga') || jestZeroLubBrak('DASH') || jestZeroLubBrak('BURST_RES')) isBeta = true;
            statyString = `ATK:${maStat('ATK') ? daneStatystyk.ATK : 'N/A'}, DEF:${maStat('DEF') ? daneStatystyk.DEF : 'N/A'}, STM:${maStat('STM') ? daneStatystyk.STM : 'N/A'}, Waga:${maStat('waga') ? daneStatystyk.waga : 'N/A'}g, DASH:${maStat('DASH') ? daneStatystyk.DASH : 'N/A'}, B-RES:${maStat('BURST_RES') ? daneStatystyk.BURST_RES : 'N/A'}`;
        } else if (czesc.typ === 'cx-lock-chip') {
            if (jestZeroLubBrak('waga')) isBeta = true;
            statyString = `Waga:${maStat('waga') ? daneStatystyk.waga : 'N/A'}g`;
            if (maStat('cx_lc_wytrz')) statyString += `, Wytrz:${daneStatystyk.cx_lc_wytrz}`;
            if (maStat('cx_lc_atk_bonus')) statyString += `, ATK+:${daneStatystyk.cx_lc_atk_bonus}`;
            if (maStat('cx_lc_def_bonus')) statyString += `, DEF+:${daneStatystyk.cx_lc_def_bonus}`;
        }
        statyString = `<p style="font-size:0.85em; line-height:1.4;">${statyString}</p>`;
        
        const imgHTML = obrazekDoWyswietlenia ? `<img class="part-img" src="${obrazekDoWyswietlenia}" alt="${czesc.nazwa}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"><div class="part-img-placeholder" style="display:none;">Brak<br>obr.</div>` : `<div class="part-img-placeholder">Brak<br>obr.</div>`;
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        if (ilosc === 0) cardDiv.classList.add('part-not-owned');
        if (isBeta) cardDiv.classList.add('part-beta-item');
        const typNazwaFormatowana = czesc.typ.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const quantityControlsHTML = `
            <div class="item-quantity-controls">
                <button class="quantity-btn" onclick="zmienIloscCzesci('${czesc.id}', -1)" title="Zmniejsz ilość ${czesc.nazwa}" ${ilosc === 0 ? 'disabled' : ''}>-</button>
                <span class="quantity-display" title="Aktualna ilość: ${ilosc}">${ilosc}</span>
                <button class="quantity-btn" onclick="zmienIloscCzesci('${czesc.id}', 1)" title="Zwiększ ilość ${czesc.nazwa}">+</button>
            </div>`;
        
        cardDiv.innerHTML = `${imgHTML}<h3>${nazwaDoWyswietlenia}${isBeta ? '<span class="beta-label">BETA</span>' : ''}</h3><p style="font-size:0.8em; color:#bbb; margin-top:-10px; margin-bottom:8px;"><em>${typNazwaFormatowana}</em></p>${statyString}${buttonHTML}${quantityControlsHTML}`;
        lista.appendChild(cardDiv);
    });
}

function zmienIloscCzesci(idCzesci, zmiana) {
    const magazyn = getMagazyn();
    const indexCzesci = magazyn.findIndex(c => c && c.id === idCzesci);
    if (indexCzesci === -1) { showNotification("Błąd: Nie znaleziono części.", 3000, 'error'); return; }
    const czesc = magazyn[indexCzesci];
    let nowaIlosc = (parseInt(czesc.ilosc, 10) || 0) + zmiana;
    if (nowaIlosc < 0) nowaIlosc = 0;
    if (czesc.ilosc === nowaIlosc && zmiana !== 0) return;
    czesc.ilosc = nowaIlosc;
    magazyn[indexCzesci] = czesc;
    setMagazyn(magazyn);
    const aktywnaStronaId = document.querySelector('.page.active')?.id;
    if (aktywnaStronaId === 'magazyn') wyswietlMagazyn();
    if (aktywnaStronaId === 'deck') renderAvailablePartsList(); // Odśwież listę części dla D&D
}

// =================================
// Obliczanie Statystyk Zestawu
// =================================
function obliczSumeStatystykZestawu(czesciZestawu, seria) { // czesciZestawu to obiekt z częściami, np. {blade: objBlade, rachet: objRatchet, ...}
    const suma = { ATK: 0, DEF: 0, STM: 0, WAGA: 0, DASH: 0, B_RES: 0, CX_LC_WYTRZ: 0 };
    const getStat = (czesc, statName, defaultValue = 0) => {
        if (!czesc || typeof czesc[statName] === 'undefined' || czesc[statName] === null) return defaultValue;
        const val = parseFloat(czesc[statName]);
        return isNaN(val) ? defaultValue : val;
    };

    if (seria === 'bx_ux') {
        const { blade, rachet, bit } = czesciZestawu;
        if (blade) { suma.ATK += getStat(blade, 'ATK'); suma.DEF += getStat(blade, 'DEF'); suma.STM += getStat(blade, 'STM'); suma.WAGA += getStat(blade, 'waga'); }
        if (rachet) {
            suma.ATK += getStat(rachet, 'ATK'); suma.DEF += getStat(rachet, 'DEF'); suma.STM += getStat(rachet, 'STM'); suma.WAGA += getStat(rachet, 'waga');
            if (String(rachet.id) === "205" || rachet.integrujeBit === true) { // Specjalny Ratchet Turbo
                suma.DASH = getStat(rachet, 'DASH'); suma.B_RES = getStat(rachet, 'BURST_RES');
            }
        }
        const jestSpecjalnyRatchet = rachet && (String(rachet.id) === "205" || rachet.integrujeBit === true);
        if (bit && !jestSpecjalnyRatchet) {
            suma.DASH += getStat(bit, 'DASH'); suma.B_RES += getStat(bit, 'BURST_RES'); suma.WAGA += getStat(bit, 'waga');
        }
    } else if (seria === 'cx') {
        const { cx_lock_chip, cx_main_blade, cx_assist_blade, rachet, bit } = czesciZestawu;
        if (cx_lock_chip) { suma.WAGA += getStat(cx_lock_chip, 'waga'); suma.CX_LC_WYTRZ += getStat(cx_lock_chip, 'cx_lc_wytrz'); suma.ATK += getStat(cx_lock_chip, 'cx_lc_atk_bonus'); suma.DEF += getStat(cx_lock_chip, 'cx_lc_def_bonus'); }
        if (cx_main_blade) { suma.ATK += getStat(cx_main_blade, 'ATK'); suma.DEF += getStat(cx_main_blade, 'DEF'); suma.STM += getStat(cx_main_blade, 'STM'); suma.WAGA += getStat(cx_main_blade, 'waga'); }
        if (cx_assist_blade) { suma.ATK += getStat(cx_assist_blade, 'ATK'); suma.DEF += getStat(cx_assist_blade, 'DEF'); suma.STM += getStat(cx_assist_blade, 'STM'); suma.WAGA += getStat(cx_assist_blade, 'waga'); }
        if (rachet) {
            suma.ATK += getStat(rachet, 'ATK'); suma.DEF += getStat(rachet, 'DEF'); suma.STM += getStat(rachet, 'STM'); suma.WAGA += getStat(rachet, 'waga');
             if (String(rachet.id) === "205" || rachet.integrujeBit === true) { // Specjalny Ratchet Turbo
                suma.DASH = getStat(rachet, 'DASH'); suma.B_RES = getStat(rachet, 'BURST_RES');
            }
        }
        const jestSpecjalnyRatchetCX = rachet && (String(rachet.id) === "205" || rachet.integrujeBit === true);
        if (bit && !jestSpecjalnyRatchetCX) {
            suma.DASH += getStat(bit, 'DASH'); suma.B_RES += getStat(bit, 'BURST_RES'); suma.WAGA += getStat(bit, 'waga');
        }
    }

    for (const key in suma) {
        if (typeof suma[key] === 'number') suma[key] = parseFloat(suma[key].toFixed(1));
    }
    return suma;
}

// =================================
// Generator Losowych Zestawów
// =================================
function generujHTMLDlaKartyZestawu(zestaw, indexZestawu) {
    const { seria, czesci, statystyki, idZestawu } = zestaw;
    const getPartAndHTML = (partObj, partTypeDefaultName) => {
        const imgHTML = partObj?.img ? `<img src="${partObj.img}" alt="${partObj.nazwa || partTypeDefaultName}" class="deck-part-img">` : `<div class="deck-part-placeholder">${partTypeDefaultName.substring(0,3).toUpperCase()}</div>`; 
        const nameText = partObj ? (partObj.nazwa || `<i>${partTypeDefaultName} N/A</i>`) : `<i>Brak ${partTypeDefaultName}</i>`;
        return { html: imgHTML, name: nameText };
    };

    let setImagesHTML = ''; let setNameParts = [];
    const ratchetWylosowany = czesci.rachet;
    const czySpecjalnyRatchetZostalWylosowany = ratchetWylosowany && (String(ratchetWylosowany.id) === "205" || ratchetWylosowany.integrujeBit === true);

    if (seria === 'bx_ux') {
        const bladeInfo = getPartAndHTML(czesci.blade, 'Blade');
        const ratchetInfo = getPartAndHTML(ratchetWylosowany, 'Ratchet');
        // === ZMIANA TUTAJ: Używamy nowego obrazka dla zintegrowanego bita ===
        let bitInfo = czySpecjalnyRatchetZostalWylosowany ? 
            { html: `<img src="img/bitturbo.png" alt="Bit Zintegrowany" class="deck-part-img" title="Bit zintegrowany w ${ratchetWylosowany.nazwa}">`, name: `<em>(Bit zint. w ${ratchetWylosowany.nazwa})</em>` } : 
            getPartAndHTML(czesci.bit, 'Bit');
        // === KONIEC ZMIANY ===
        setImagesHTML = `<div class="wynik-zestaw-obrazki">${bladeInfo.html} ${ratchetInfo.html} ${bitInfo.html}</div>`;
        setNameParts = [`<strong>Blade:</strong> ${bladeInfo.name}`, `<strong>Ratchet:</strong> ${ratchetInfo.name}`, `<strong>Bit:</strong> ${bitInfo.name}`];
    } else if (seria === 'cx') {
        const lockChipInfo = getPartAndHTML(czesci.cx_lock_chip, 'LockChip');
        const mainBladeInfo = getPartAndHTML(czesci.cx_main_blade, 'MainBlade');
        const assistBladeInfo = getPartAndHTML(czesci.cx_assist_blade, 'AssistBlade');
        const ratchetInfo = getPartAndHTML(ratchetWylosowany, 'Ratchet');
        // === ZMIANA TUTAJ: Używamy nowego obrazka dla zintegrowanego bita ===
        let bitInfo = czySpecjalnyRatchetZostalWylosowany ? 
            { html: `<img src="img/bitturbo.png" alt="Bit Zintegrowany" class="deck-part-img" title="Bit zintegrowany w ${ratchetWylosowany.nazwa}">`, name: `<em>(Bit zint. w ${ratchetWylosowany.nazwa})</em>` } : 
            getPartAndHTML(czesci.bit, 'Bit');
        // === KONIEC ZMIANY ===
        setImagesHTML = `<div class="cx-images-container"><div class="cx-blade-row wynik-zestaw-obrazki">${lockChipInfo.html} ${mainBladeInfo.html} ${assistBladeInfo.html}</div><div class="cx-drive-row wynik-zestaw-obrazki" style="margin-top: 5px;">${ratchetInfo.html} ${bitInfo.html}</div></div>`;
        setNameParts = [`<strong>LockChip:</strong> ${lockChipInfo.name}`, `<strong>Main Blade:</strong> ${mainBladeInfo.name}`, `<strong>Assist Blade:</strong> ${assistBladeInfo.name}`, `<strong>Ratchet:</strong> ${ratchetInfo.name}`, `<strong>Bit:</strong> ${bitInfo.name}`];
    }
    
    let setNameHTML = setNameParts.join('<br>');
    let statySumaryczneHTML = '<div class="stat-grid">'; 
    statySumaryczneHTML += `<span>ATK: ${(statystyki.ATK || 0).toFixed(1)}</span>`;
    statySumaryczneHTML += `<span>DEF: ${(statystyki.DEF || 0).toFixed(1)}</span>`;
    statySumaryczneHTML += `<span>STM: ${(statystyki.STM || 0).toFixed(1)}</span>`;
    statySumaryczneHTML += `<span>Waga: ${(statystyki.WAGA || 0).toFixed(1)}g</span>`;
    if ((statystyki.DASH || 0) !== 0) statySumaryczneHTML += `<span>DASH: ${(statystyki.DASH || 0).toFixed(1)}</span>`;
    if ((statystyki.B_RES || 0) !== 0) statySumaryczneHTML += `<span>B-RES: ${(statystyki.B_RES || 0).toFixed(1)}</span>`;
    if (seria === 'cx' && (statystyki.CX_LC_WYTRZ || 0) !== 0) statySumaryczneHTML += `<span>LC-W: ${parseInt((statystyki.CX_LC_WYTRZ || 0).toFixed(0))}</span>`;
    statySumaryczneHTML += `</div>`;

    let zmienneStatyRatchetHTML = '';
    
    return `
        <div class="card saved-deck-card generated-set-card ${seria === 'cx' ? 'wylosowany-zestaw-cx' : ''}" data-zestaw-id="${idZestawu}">
            <h4 style="text-align:center; color:#d1b3ff; margin-bottom: 10px;">Wylosowany Zestaw ${seria.toUpperCase().replace('_','/')} #${indexZestawu + 1}</h4>
            ${setImagesHTML}
            <div style="font-size:0.85em; color:#ddd; margin-top: 8px; margin-bottom:12px; word-break: break-word; text-align:center; line-height: 1.4;">${setNameHTML}</div>
            <div style="margin-top:10px; padding-top:10px; border-top: 1px solid rgba(255,255,255,0.1);"><strong style="display:block; text-align:center; font-size:0.9em; margin-bottom:5px; color:#c080ff;">SUMA STATYSTYK:</strong>${statySumaryczneHTML}</div>
            ${zmienneStatyRatchetHTML}
        </div>`;
}

function wyczyscLosowanie() {
    if (wynikiDivGenerator) wynikiDivGenerator.innerHTML = ''; 
    if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block'; 
    ostatnioWylosowaneZestawyGlobalnie = [];
    const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
    if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'none';
    const nazwaDeckuInput = document.getElementById('nazwa-glownego-decku');
    if(nazwaDeckuInput) nazwaDeckuInput.value = ""; // Czyścimy też pole nazwy
    showNotification('Wyniki losowania wyczyszczone.', 2000, 'info');
}

function LOSUJ() {
    if (!wynikiDivGenerator) { showNotification("Błąd: Element wyników generatora nie istnieje.", 3000, 'error'); return; }
    if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'none';
    wynikiDivGenerator.innerHTML = '';
    ostatnioWylosowaneZestawyGlobalnie = [];

    const iloscZestawowDoWylosowania = parseInt(document.getElementById('ilosc')?.value) || 1;
    const wybranaSeria = document.getElementById('seriaLosowania')?.value;

    if (!wybranaSeria) {
        showNotification("Błąd: Nie wybrano serii.", 3000, 'warning');
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        return;
    }

    const magazyn = getMagazyn();
    if (!magazyn || magazyn.length === 0) {
        wynikiDivGenerator.innerHTML = '<div class="card"><p>Magazyn jest pusty! Dodaj części w zakładce "Magazyn".</p></div>';
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        return;
    }

    // === ZMIANA TUTAJ: Dodano 'ux-blade' do obiektu ===
    const dostepneCzesciDoLosowania = { blade: [], 'ux-blade': [], rachet: [], bit: [], 'cx-lock-chip': [], 'cx-main-blade': [], 'cx-assist-blade': [] };
    magazyn.forEach(czesc => {
        const ilosc = parseInt(czesc.ilosc) || 0;
        if (ilosc > 0 && dostepneCzesciDoLosowania.hasOwnProperty(czesc.typ)) {
            for (let j = 0; j < ilosc; j++) {
                dostepneCzesciDoLosowania[czesc.typ].push({ ...czesc, _uniqueDragId: `${czesc.id}_instance_${j}_${Date.now()}_${Math.random()}` });
            }
        }
    });

    let czyWystarczajacoCzesci = true;
    let komunikatBrakuCzesci = "Niewystarczająca ilość części w magazynie do wylosowania ";
    if (wybranaSeria === 'bx_ux') {
        komunikatBrakuCzesci += `${iloscZestawowDoWylosowania} zestawu/ów BX/UX:`;
        // === ZMIANA TUTAJ: Sprawdzamy sumę części blade i ux-blade ===
        if ((dostepneCzesciDoLosowania.blade.length + dostepneCzesciDoLosowania['ux-blade'].length) < iloscZestawowDoWylosowania) {
             czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało Blade (BX/UX),";
        }
        if (dostepneCzesciDoLosowania.rachet.length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało Ratchet,"; }
        let potrzebneBity = 0;
        let dostepneZwykleRatchety = dostepneCzesciDoLosowania.rachet.filter(r => !(r.integrujeBit === true || String(r.id) === "205")).length;
        if (iloscZestawowDoWylosowania > dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchety) {
            potrzebneBity = Math.min(iloscZestawowDoWylosowania - (dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchety), dostepneZwykleRatchety)
        }
        if (dostepneCzesciDoLosowania.bit.length < potrzebneBity) {}
    } else if (wybranaSeria === 'cx') {
        komunikatBrakuCzesci += `${iloscZestawowDoWylosowania} zestawu/ów CX:`;
        if (dostepneCzesciDoLosowania['cx-lock-chip'].length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało LockChip,"; }
        if (dostepneCzesciDoLosowania['cx-main-blade'].length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało MainBlade,"; }
        if (dostepneCzesciDoLosowania['cx-assist-blade'].length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało AssistBlade,"; }
        if (dostepneCzesciDoLosowania.rachet.length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało Ratchet,"; }
        let potrzebneBityCX = 0;
        let dostepneZwykleRatchetyCX = dostepneCzesciDoLosowania.rachet.filter(r => !(r.integrujeBit === true || String(r.id) === "205")).length;
         if (iloscZestawowDoWylosowania > dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchetyCX) {
            potrzebneBityCX = Math.min(iloscZestawowDoWylosowania - (dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchetyCX), dostepneZwykleRatchetyCX)
        }
        if (dostepneCzesciDoLosowania.bit.length < potrzebneBityCX) {}
    }
    if (!czyWystarczajacoCzesci) {
        showNotification(komunikatBrakuCzesci.slice(0, -1) + ".", 4000, 'warning');
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        return;
    }

    const wylosowaneZestawyFragment = document.createDocumentFragment();
    for (let i = 0; i < iloscZestawowDoWylosowania; i++) {
        let wylosowanyZestawCzesci = {};
        let czyZestawKompletny = true;
        let wylosowanoSpecjalnyRatchet = false;
		
        const losujCzescZPulli = (typCzesci, filtrKompatybilnosci = null) => {
            let pulaFiltrwana = [...dostepneCzesciDoLosowania[typCzesci]];
            if (filtrKompatybilnosci) {
                pulaFiltrwana = pulaFiltrwana.filter(filtrKompatybilnosci);
            }

            if (pulaFiltrwana && pulaFiltrwana.length > 0) {
                const randomIndex = Math.floor(Math.random() * pulaFiltrwana.length);
                const wylosowanaCzescZKopii = pulaFiltrwana[randomIndex];

                const indexWOryginalnejPuli = dostepneCzesciDoLosowania[typCzesci].findIndex(c => c._uniqueDragId === wylosowanaCzescZKopii._uniqueDragId);
                if (indexWOryginalnejPuli > -1) {
                    const finalnieWylosowanaCzesc = dostepneCzesciDoLosowania[typCzesci].splice(indexWOryginalnejPuli, 1)[0];
					
					if (finalnieWylosowanaCzesc.maTryby && Array.isArray(finalnieWylosowanaCzesc.tryby) && finalnieWylosowanaCzesc.tryby.length > 0) {
						const wylosowanyTrybIndex = Math.floor(Math.random() * finalnieWylosowanaCzesc.tryby.length);
						const wylosowanyTryb = finalnieWylosowanaCzesc.tryby[wylosowanyTrybIndex];
						
						const czescZTrybem = { ...finalnieWylosowanaCzesc };
						delete czescZTrybem.tryby;
						
						Object.assign(czescZTrybem, wylosowanyTryb);
						
						czescZTrybem.aktywnyTrybIndex = wylosowanyTrybIndex;
						czescZTrybem.nazwa = `${finalnieWylosowanaCzesc.nazwa} (${wylosowanyTryb.nazwaTrybu})`;

						return czescZTrybem;
					}
                    return finalnieWylosowanaCzesc;
                } else {
                    return null;
                }
            }
            return null;
        };

        if (wybranaSeria === 'bx_ux') {
            // === ZMIANA TUTAJ: Logika losowania z dwóch puli 'blade' i 'ux-blade' ===
            const dostepneBX = dostepneCzesciDoLosowania.blade;
            const dostepneUX = dostepneCzesciDoLosowania['ux-blade'];
            let pulaDoLosowaniaBlade = [];
            if (dostepneBX.length > 0) pulaDoLosowaniaBlade.push('blade');
            if (dostepneUX.length > 0) pulaDoLosowaniaBlade.push('ux-blade');

            if (pulaDoLosowaniaBlade.length > 0) {
                const losowyTypBlade = pulaDoLosowaniaBlade[Math.floor(Math.random() * pulaDoLosowaniaBlade.length)];
                wylosowanyZestawCzesci.blade = losujCzescZPulli(losowyTypBlade);
            } else {
                wylosowanyZestawCzesci.blade = null;
            }

            if (wylosowanyZestawCzesci.blade && String(wylosowanyZestawCzesci.blade.id) === ID_CLOCK_MIRAGE) {
                wylosowanyZestawCzesci.rachet = losujCzescZPulli('rachet', czesc => typeof czesc.nazwa === 'string' && (czesc.nazwa.match(/-\d*5$/) || czesc.nazwa.match(/^M-\d*5$/)));
                if (!wylosowanyZestawCzesci.rchet) { czyZestawKompletny = false; }
            } else if (wylosowanyZestawCzesci.blade) {
                wylosowanyZestawCzesci.rachet = losujCzescZPulli('rachet');
            } else { czyZestawKompletny = false; }

            if (wylosowanyZestawCzesci.rachet) {
                if (String(wylosowanyZestawCzesci.rachet.id) === "205" || wylosowanyZestawCzesci.rachet.integrujeBit === true) {
                    wylosowanoSpecjalnyRatchet = true; wylosowanyZestawCzesci.bit = null;
                } else { wylosowanyZestawCzesci.bit = losujCzescZPulli('bit'); }
            } else if (czyZestawKompletny) { czyZestawKompletny = false; wylosowanyZestawCzesci.bit = null; }

            if (!wylosowanyZestawCzesci.blade || !wylosowanyZestawCzesci.rachet || (!wylosowanoSpecjalnyRatchet && !wylosowanyZestawCzesci.bit && wylosowanyZestawCzesci.rachet)) {
                czyZestawKompletny = false;
            }
        } else if (wybranaSeria === 'cx') {
            wylosowanyZestawCzesci.cx_lock_chip = losujCzescZPulli('cx-lock-chip');
            wylosowanyZestawCzesci.cx_main_blade = losujCzescZPulli('cx-main-blade');
            wylosowanyZestawCzesci.cx_assist_blade = losujCzescZPulli('cx-assist-blade');
            wylosowanyZestawCzesci.rachet = losujCzescZPulli('rachet');
            if (wylosowanyZestawCzesci.rachet) {
                if (String(wylosowanyZestawCzesci.rachet.id) === "205" || wylosowanyZestawCzesci.rachet.integrujeBit === true) {
                    wylosowanoSpecjalnyRatchet = true; wylosowanyZestawCzesci.bit = null;
                } else { wylosowanyZestawCzesci.bit = losujCzescZPulli('bit'); }
            } else { wylosowanyZestawCzesci.bit = null; czyZestawKompletny = false; }
            if (!wylosowanyZestawCzesci.cx_lock_chip || !wylosowanyZestawCzesci.cx_main_blade || !wylosowanyZestawCzesci.cx_assist_blade || !wylosowanyZestawCzesci.rachet || (!wylosowanoSpecjalnyRatchet && !wylosowanyZestawCzesci.bit && wylosowanyZestawCzesci.rachet)) {
                czyZestawKompletny = false;
            }
        }

        if (czyZestawKompletny) {
            const czesciDoStatystyk = {};
            for (const key in wylosowanyZestawCzesci) {
                if (wylosowanyZestawCzesci[key]) {
                    const { _uniqueDragId, ...resztaCzesci } = wylosowanyZestawCzesci[key];
                    czesciDoStatystyk[key] = resztaCzesci;
                } else { czesciDoStatystyk[key] = null; }
            }

            const statystykiZestawu = obliczSumeStatystykZestawu(czesciDoStatystyk, wybranaSeria);
            const idUnikalnyZestawu = `wylosowany-${Date.now()}-${i}-${Math.random().toString(16).slice(2)}`;
            const pelnyZestaw = { idZestawu: idUnikalnyZestawu, seria: wybranaSeria, czesci: czesciDoStatystyk, statystyki: statystykiZestawu };
            ostatnioWylosowaneZestawyGlobalnie.push(pelnyZestaw);
            const kartaHTML = generujHTMLDlaKartyZestawu(pelnyZestaw, i);
            const tempDiv = document.createElement('div'); tempDiv.innerHTML = kartaHTML.trim();
            wylosowaneZestawyFragment.appendChild(tempDiv.firstChild);
        } else {
            showNotification(`Nie udało się wylosować kompletu dla zestawu #${i + 1}.`, 3500, 'warning');
        }
    }

    if (wylosowaneZestawyFragment.childNodes.length > 0) {
        wynikiDivGenerator.appendChild(wylosowaneZestawyFragment);
        showNotification(`Wylosowano ${ostatnioWylosowaneZestawyGlobalnie.length} zestaw(ów)!`, 2500, 'success');
        const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
        if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'block';
    } else if (iloscZestawowDoWylosowania > 0) {
        wynikiDivGenerator.innerHTML = '<div class="card"><p>Nie udało się wylosować żadnego kompletnego zestawu.</p></div>';
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
        if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'none';
    }
}

// =================================
// Zapisywanie Wylosowanych Zestawów
// =================================
function saveCurrentGeneratedDeck() {
    if (!ostatnioWylosowaneZestawyGlobalnie || ostatnioWylosowaneZestawyGlobalnie.length === 0) {
        showNotification("Brak wylosowanych zestawów do zapisania jako deck.", 3000, 'warning'); return;
    }
    // Domyślnie zapisujemy pierwszy wylosowany zestaw jako deck jednosetowy
    const zestawDoZapisu = ostatnioWylosowaneZestawyGlobalnie[0]; 
    if (!zestawDoZapisu || !zestawDoZapisu.czesci || !zestawDoZapisu.seria) {
        showNotification("Błąd: Dane wylosowanego zestawu są niekompletne.", 3000, 'error'); return;
    }

    const nazwaInput = document.getElementById('nazwa-glownego-decku');
    let nazwaDecku = `Wylosowany ${zestawDoZapisu.seria.toUpperCase().replace('_','/')} ${new Date().toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' })}`;
    if (nazwaInput && nazwaInput.value.trim() !== '') nazwaDecku = nazwaInput.value.trim();

    const pojedynczyZestawKonfiguracja = { 
        seria: zestawDoZapisu.seria,
        statystykiObliczone: zestawDoZapisu.statystyki 
    };

    if (zestawDoZapisu.seria === 'bx_ux') {
        pojedynczyZestawKonfiguracja.bladeId = zestawDoZapisu.czesci.blade?.id || null;
        pojedynczyZestawKonfiguracja.ratchetId = zestawDoZapisu.czesci.rachet?.id || null;
        pojedynczyZestawKonfiguracja.bitId = zestawDoZapisu.czesci.bit?.id || null;
    } else if (zestawDoZapisu.seria === 'cx') {
        pojedynczyZestawKonfiguracja.cx_lock_chipId = zestawDoZapisu.czesci.cx_lock_chip?.id || null;
        pojedynczyZestawKonfiguracja.cx_main_bladeId = zestawDoZapisu.czesci.cx_main_blade?.id || null;
        pojedynczyZestawKonfiguracja.cx_assist_bladeId = zestawDoZapisu.czesci.cx_assist_blade?.id || null;
        pojedynczyZestawKonfiguracja.ratchetId = zestawDoZapisu.czesci.rachet?.id || null; // Rachet i Bit są też w CX
        pojedynczyZestawKonfiguracja.bitId = zestawDoZapisu.czesci.bit?.id || null;
    } else { showNotification("Błąd: Nieznana seria wylosowanego zestawu.", 3000, 'error'); return; }

    const nowyDeck = {
        id: `deck_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,
        name: nazwaDecku, 
        timestamp: Date.now(), 
        lastModified: Date.now(),
        sets: [pojedynczyZestawKonfiguracja] // Deck składa się z jednego, wylosowanego zestawu
    };

    const zapisaneDecki = getSavedDecks();
    zapisaneDecki.push(nowyDeck);
    setSavedDecks(zapisaneDecki);
    showNotification(`Deck "${nowyDeck.name}" (z jednego zestawu) zapisany!`, 3000, 'success');
    if (nazwaInput) nazwaInput.value = ''; // Czyścimy pole nazwy po zapisie
    
    // Opcjonalnie: Zaktualizuj przycisk zapisu, aby pokazać, że zapisano
    const zapiszGlownyButton = document.querySelector('#zapisz-glowny-zestaw-controls button');
    if(zapiszGlownyButton) {
        zapiszGlownyButton.textContent = 'Zapisano!'; 
        zapiszGlownyButton.disabled = true;
        setTimeout(() => { 
            zapiszGlownyButton.textContent = 'Zapisz Ten Wylosowany Zestaw'; 
            zapiszGlownyButton.disabled = false; 
        }, 2500);
    }
}

// =================================
// Drag and Drop Deck Builder - Funkcje Renderujące
// =================================

    function renderDeckBuilderAndParts() {
        console.log("renderDeckBuilderAndParts (tabs) wywołane. Aktywny zestaw index:", currentlyActiveSetIndexInBuilder, "Dane:", JSON.parse(JSON.stringify(currentDeckBeingBuilt)));
        renderAvailablePartsList();
        renderDeckSetTabs(); // Nowa funkcja do renderowania zakładek
        renderActiveDeckSetSlots(); // Nowa funkcja do renderowania slotów tylko aktywnego zestawu
        
        // Statystyki są teraz aktualizowane w renderActiveDeckSetSlots dla aktywnego zestawu
    }
    
	function renderDeckSetTabs() {
        const tabsContainer = document.getElementById('deck-set-tabs-container');
        if (!tabsContainer) {
            console.error("Kontener zakładek #deck-set-tabs-container nie znaleziony");
            return;
        }
        tabsContainer.innerHTML = ''; // Wyczyść stare zakładki

        for (let i = 0; i < 4; i++) {
            const tabButton = document.createElement('button');
            tabButton.className = 'tab-button';
            tabButton.textContent = `Zestaw ${i + 1}`;
            tabButton.dataset.setIndex = i; // Przechowujemy indeks 0-3

            if (i === currentlyActiveSetIndexInBuilder) {
                tabButton.classList.add('active');
            }

            tabButton.addEventListener('click', (event) => {
                const newActiveIndex = parseInt(event.currentTarget.dataset.setIndex);
                if (newActiveIndex !== currentlyActiveSetIndexInBuilder) {
                    currentlyActiveSetIndexInBuilder = newActiveIndex;
                    renderDeckBuilderAndParts(); // Prerenderuj wszystko, aby odświeżyć zakładki i sloty
                }
            });
            tabsContainer.appendChild(tabButton);
        }
    }
    
function renderActiveDeckSetSlots() {
    const activeSlotsContainer = document.getElementById('deck-builder-active-set-slots');
    if (!activeSlotsContainer) {
        console.error("Kontener slotów aktywnego zestawu #deck-builder-active-set-slots nie znaleziony");
        return;
    }
    activeSlotsContainer.innerHTML = '';

    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets || !currentDeckBeingBuilt.sets[currentlyActiveSetIndexInBuilder]) {
        console.warn("currentDeckBeingBuilt lub aktywny zestaw nie jest poprawnie zainicjalizowany.");
        initializeOrResetCurrentDeck();
        if (!currentDeckBeingBuilt.sets[currentlyActiveSetIndexInBuilder]) {
            currentDeckBeingBuilt.sets[currentlyActiveSetIndexInBuilder] = { seria: 'bx_ux', bladeId: null, ratchetId: null, bitId: null, cx_lock_chipId: null, cx_main_bladeId: null, cx_assist_bladeId: null, statystykiObliczone: {} };
        }
        renderDeckSetTabs();
    }

    const setIndex = currentlyActiveSetIndexInBuilder;
    const displaySetNumber = setIndex + 1;
    const setConfig = currentDeckBeingBuilt.sets[setIndex];

    const deckSetCard = document.createElement("div");
    deckSetCard.className = "deck-set card";
    deckSetCard.style.marginBottom = "20px";
    deckSetCard.style.padding = "15px";

    const seriaSelectDiv = document.createElement('div');
    seriaSelectDiv.style.marginBottom = "10px";
    const seriaLabel = document.createElement('label');
    seriaLabel.htmlFor = `deck-seria-${displaySetNumber}`;
    seriaLabel.textContent = `Seria dla Zestawu ${displaySetNumber}: `;
    seriaLabel.style.marginRight = "5px";
    const seriaSelect = document.createElement('select');
    seriaSelect.id = `deck-seria-${displaySetNumber}`;
    seriaSelect.innerHTML = `
        <option value="bx_ux" ${setConfig.seria === 'bx_ux' ? 'selected' : ''}>BX / UX</option>
        <option value="cx" ${setConfig.seria === 'cx' ? 'selected' : ''}>CX</option>
    `;
    seriaSelect.dataset.setIndex = setIndex;
    seriaSelect.addEventListener('change', handleSeriaChangeForSet);
    seriaSelectDiv.appendChild(seriaLabel);
    seriaSelectDiv.appendChild(seriaSelect);
    deckSetCard.appendChild(seriaSelectDiv);

    const partTypes = getPartTypesForSeria(setConfig.seria);
    const magazyn = getMagazyn();

    let jestTurboRatchetWAktywnymZestawie = false;
    if (setConfig.ratchetId) {
        const aktywnyRatchet = magazyn.find(p => p.id === setConfig.ratchetId && p.typ === 'rachet');
        if (aktywnyRatchet && (String(aktywnyRatchet.id) === "205" || aktywnyRatchet.integrujeBit === true)) {
            jestTurboRatchetWAktywnymZestawie = true;
        }
    }

    if (jestTurboRatchetWAktywnymZestawie && setConfig.bitId !== null) {
        setConfig.bitId = null;
    }

    partTypes.forEach(partTypeInfo => {
        const slotDiv = document.createElement('div');
        slotDiv.className = 'deck-part-slot';
        slotDiv.dataset.setIndex = setIndex;
        slotDiv.dataset.slotType = partTypeInfo.type;

        const partIdKey = getPartIdKeyForSlot(partTypeInfo.type, setConfig.seria);
        const partId = partIdKey ? setConfig[partIdKey] : null;

        // === ZMIANA TUTAJ: Używamy nowego obrazka dla zintegrowanego bita ===
        if (partTypeInfo.type === 'bit' && jestTurboRatchetWAktywnymZestawie) {
            slotDiv.classList.add('filled'); // Dodajemy klasę filled, aby wyglądało jak zajęty slot
            slotDiv.innerHTML = `
                 <div class="part-info-container">
                    <img src="img/bitturbo.png" alt="Bit Zintegrowany" style="width: 50px; height: 50px; object-fit: contain; border-radius: 4px;">
                    <span class="part-name" style="font-style: italic; color: #aaa;">Bit zintegrowany</span>
                </div>
            `;
        // === KONIEC ZMIANY ===
        } else {
            if (partId) {
                const partDetails = magazyn.find(p => p.id === partId);
                if (partDetails) {
                    const trybIndexKey = partIdKey.replace('Id', 'AktywnyTrybIndex');
                    const aktywnyTrybIndex = setConfig[trybIndexKey] || 0;
                    const trybAktywny = (partDetails.maTryby && partDetails.tryby) ? partDetails.tryby[aktywnyTrybIndex] : null;
                    
                    const obrazek = trybAktywny?.img || partDetails.img;
                    let slotImageHTML = obrazek ? `<img src="${obrazek}" alt="${partDetails.nazwa}" style="width: 50px; height: 50px; object-fit: contain; border-radius: 4px;">` : `<div class="dnd-slot-placeholder">Brak<br>Obr.</div>`;
                    
                    let modeSwitcherHTML = '';
                    if (partDetails.maTryby && Array.isArray(partDetails.tryby) && partDetails.tryby.length > 1) {
                        const nazwaAktywnegoTrybu = trybAktywny?.nazwaTrybu || 'Tryb 1';
                        modeSwitcherHTML = `
                            <button class="mode-switch-btn" onclick="przelaczTrybCzesci(${setIndex}, '${partTypeInfo.type}')" title="Zmień tryb: ${nazwaAktywnegoTrybu}">
                                ${nazwaAktywnegoTrybu} 🔄
                            </button>
                        `;
                    }

                    slotDiv.innerHTML = `
                        <div class="part-info-container">
                            ${slotImageHTML}
                            <span class="part-name">${partDetails.nazwa}</span>
                        </div>
                        <div class="part-controls">
                            ${modeSwitcherHTML}
                            <button class="remove-part-btn" title="Usuń część">&times;</button>
                        </div>
                    `;
                    slotDiv.classList.add('filled');
                    slotDiv.dataset.currentPartId = partId;
                    slotDiv.querySelector('.remove-part-btn').addEventListener('click', () => removePartFromSlot(setIndex, partTypeInfo.type));
                } else {
                    slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj (ID: ${partId} nie znalezione)</span>`;
                    if (partIdKey) setConfig[partIdKey] = null;
                }
            } else {
                slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj</span>`;
            }

            slotDiv.addEventListener('dragover', handleDragOver);
            slotDiv.addEventListener('dragenter', handleDragEnter);
            slotDiv.addEventListener('dragleave', handleDragLeave);
            slotDiv.addEventListener('drop', handleDrop);
        }
        deckSetCard.appendChild(slotDiv);
    });

    const statsDiv = document.createElement('div');
    statsDiv.id = `deck-stats-${displaySetNumber}`;
    statsDiv.className = "deck-stats";
    statsDiv.style.cssText = "margin-top: 15px; font-weight: normal; font-size: 0.9em; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 6px; text-align: left; line-height: 1.5;";
    deckSetCard.appendChild(statsDiv);

    activeSlotsContainer.appendChild(deckSetCard);
    updateDeckStatsForSetInBuilder(displaySetNumber);
}

function przelaczTrybCzesci(setIndex, partType) {
    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets[setIndex]) return;
    const set = currentDeckBeingBuilt.sets[setIndex];

    const partId = set[`${partType}Id`];
    if (!partId) return;

    // Pobierz dane części z magazynu
    const magazyn = getMagazyn();
    const part = magazyn.find(c => c.id === partId);
    if (!part || !part.maTryby) return;

    // Ustal nazwę klucza w decku (np. bladeAktywnyTrybIndex)
    const keyIndex = `${partType}AktywnyTrybIndex`;

    // Zmień tryb w decku
    set[keyIndex] = ((set[keyIndex] || 0) + 1) % part.tryby.length;

    // Zmień też w magazynie, żeby było spójnie
    const idxMagazyn = magazyn.findIndex(c => c.id === partId);
    if (idxMagazyn !== -1) {
        magazyn[idxMagazyn].aktywnyTrybIndex = set[keyIndex];
        setMagazyn(magazyn);
    }

    renderDeckBuilderAndParts(); // odśwież widok slotów
}

function przelaczTrybMagazynu(idCzesci) {
    const magazyn = getMagazyn();
    const idx = magazyn.findIndex(c => c.id === idCzesci);
    if (idx === -1) return;

    const czesc = magazyn[idx];
    if (!czesc.maTryby || !czesc.tryby || czesc.tryby.length < 2) return;

    czesc.aktywnyTrybIndex = ((czesc.aktywnyTrybIndex || 0) + 1) % czesc.tryby.length;
    setMagazyn(magazyn);
    wyswietlMagazyn(); // odśwież UI
}
    
	
function renderAvailablePartsList() {
    const partsListContainer = document.getElementById('parts-list-for-dnd');
    if (!partsListContainer) { return; }
    partsListContainer.innerHTML = '';
    const magazyn = getMagazyn();
    const filterValue = document.getElementById('dndPartTypeFilter')?.value;

    if (!filterValue) {
        partsListContainer.innerHTML = '<p style="font-size:0.9em; color:#999; text-align:center;">Wybierz typ części.</p>';
        return;
    }

    // --- KLUCZOWA POPRAWKA LOGIKI FILTROWANIA ---
    // Używamy prostego i niezawodnego porównania 'czesc.typ === filterValue'
    const czesciDoWyswietlenia = magazyn
        .filter(czesc => czesc && czesc.ilosc > 0 && czesc.typ === filterValue)
        .sort((a, b) => a.nazwa.localeCompare(b.nazwa));
    // --- KONIEC POPRAWKI ---

    if (czesciDoWyswietlenia.length === 0) {
        partsListContainer.innerHTML = `<p style="font-size:0.9em; color:#999; text-align:center;">Brak posiadanych części tego typu.</p>`;
        return;
    }

    czesciDoWyswietlenia.forEach(czesc => {
        const aktywnyIndex = czesc.aktywnyTrybIndex || 0;
        const trybAktywny = (czesc.maTryby && czesc.tryby) ? czesc.tryby[aktywnyIndex] : null;

        const obrazek = trybAktywny?.img || czesc.img;
        const nazwa = trybAktywny ? `${czesc.nazwa} (${trybAktywny.nazwaTrybu})` : czesc.nazwa;

        const partItem = document.createElement('div');
        partItem.className = 'available-part-item';
        partItem.draggable = true;
        partItem.dataset.partData = JSON.stringify({
            id: czesc.id,
            typ: czesc.typ,
            nazwa: nazwa,
            img: obrazek,
            aktywnyTrybIndex: aktywnyIndex
        });

        let modeSwitcherHTML = '';
        if (czesc.maTryby && czesc.tryby.length > 1) {
            modeSwitcherHTML = `
                <button
                    class="mode-switch-btn"
                    style="margin-left: auto; flex-shrink: 0;"
                    onclick="event.stopPropagation(); przelaczTrybNaLiscie('${czesc.id}', event)">
                    Zmień Tryb 🔄
                </button>
            `;
        }

        partItem.innerHTML = `
            <img src="${obrazek}" alt="${nazwa}" style="width: 40px; height: 40px; object-fit: contain; border-radius: 4px; flex-shrink: 0;">
            <span style="flex-grow: 1; text-align: left;">${nazwa} (x${czesc.ilosc})</span>
            ${modeSwitcherHTML}
        `;

        partItem.addEventListener('dragstart', handleDragStart);
        partItem.addEventListener('dragend', handleDragEnd);
        partsListContainer.appendChild(partItem);
    });
}

function przelaczTrybNaLiscie(idCzesci, event) {
    // Zatrzymuje "bąbelkowanie" eventu, aby kliknięcie nie aktywowało przeciągania
    event.stopPropagation();

    const magazyn = getMagazyn();
    const idx = magazyn.findIndex(c => c.id === idCzesci);
    if (idx === -1) return;

    const czesc = magazyn[idx];
    if (!czesc.maTryby || !czesc.tryby || czesc.tryby.length < 2) return;

    // Zmień indeks trybu
    czesc.aktywnyTrybIndex = ((czesc.aktywnyTrybIndex || 0) + 1) % czesc.tryby.length;
    setMagazyn(magazyn);

    // Prerenderuj listę części, aby pokazać zmianę
    renderAvailablePartsList();
}


function renderDeckSlots() {
    const slotsContainer = document.getElementById('deck-builder-slots');
    if (!slotsContainer) { console.error("Kontener #deck-builder-slots nie znaleziony"); return; }
    slotsContainer.innerHTML = ''; // Czyścimy przed renderowaniem

    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets || currentDeckBeingBuilt.sets.length === 0) {
        console.warn("currentDeckBeingBuilt nie jest poprawnie zainicjalizowany do renderowania slotów.");
        initializeOrResetCurrentDeck(); // Spróbuj zainicjalizować
    }


    for (let i = 0; i < 4; i++) {
        const setIndex = i; // Index w tablicy (0-3)
        const displaySetNumber = i + 1; // Numer wyświetlany użytkownikowi (1-4)
        const setConfig = currentDeckBeingBuilt.sets[setIndex]; // Pobieramy konfigurację zestawu

        if (!setConfig) {
            console.error(`Brak konfiguracji dla zestawu o indeksie ${setIndex} w currentDeckBeingBuilt.`);
            continue; 
        }

        const deckSetCard = document.createElement("div");
        deckSetCard.className = "deck-set card"; // Używamy klasy .card dla spójności
        deckSetCard.style.marginBottom = "20px";
        deckSetCard.style.padding = "15px";

        const heading = document.createElement('h3');
        heading.textContent = `Zestaw ${displaySetNumber}`;
        deckSetCard.appendChild(heading);

        const seriaSelectDiv = document.createElement('div');
        seriaSelectDiv.style.marginBottom = "10px";
        const seriaLabel = document.createElement('label');
        seriaLabel.htmlFor = `deck-seria-${displaySetNumber}`;
        seriaLabel.textContent = `Seria: `;
        seriaLabel.style.marginRight = "5px";
        const seriaSelect = document.createElement('select');
        seriaSelect.id = `deck-seria-${displaySetNumber}`;
        seriaSelect.innerHTML = `
            <option value="bx_ux" ${setConfig.seria === 'bx_ux' ? 'selected' : ''}>BX / UX</option>
            <option value="cx" ${setConfig.seria === 'cx' ? 'selected' : ''}>CX</option>
        `;
        seriaSelect.dataset.setIndex = setIndex; // Przechowujemy index tablicy
        seriaSelect.addEventListener('change', handleSeriaChangeForSet);
        
        seriaSelectDiv.appendChild(seriaLabel);
        seriaSelectDiv.appendChild(seriaSelect);
        deckSetCard.appendChild(seriaSelectDiv);

        const partTypes = getPartTypesForSeria(setConfig.seria);
        partTypes.forEach(partType => {
            const slotDiv = document.createElement('div');
            slotDiv.className = 'deck-part-slot';
            slotDiv.dataset.setIndex = setIndex; // Index tablicy 0-3
            slotDiv.dataset.slotType = partType.type; // np. 'blade', 'cx-main-blade'
            // Placeholder tekstowy
            slotDiv.innerHTML = `<span>Upuść ${partType.label} tutaj</span>`;
            
            slotDiv.addEventListener('dragover', handleDragOver);
            slotDiv.addEventListener('dragenter', handleDragEnter);
            slotDiv.addEventListener('dragleave', handleDragLeave);
            slotDiv.addEventListener('drop', handleDrop);
            deckSetCard.appendChild(slotDiv);
        });
        
        const statsDiv = document.createElement('div');
        statsDiv.id = `deck-stats-${displaySetNumber}`; // ID dla aktualizacji statystyk
        statsDiv.className = "deck-stats"; // Możesz dodać style dla .deck-stats
        statsDiv.style.cssText = "margin-top: 15px; font-weight: normal; font-size: 0.9em; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 6px; text-align: left; line-height: 1.5;";
        deckSetCard.appendChild(statsDiv);
        
        slotsContainer.appendChild(deckSetCard);
    }
}

function getPartTypesForSeria(seria) {
    if (seria === 'cx') {
        return [
            { type: 'cx-lock-chip', label: 'Lock Chip' },
            { type: 'cx-main-blade', label: 'Main Blade' },
            { type: 'cx-assist-blade', label: 'Assist Blade' },
            { type: 'rachet', label: 'Ratchet' },
            { type: 'bit', label: 'Bit' }
        ];
    }
    // Domyślnie BX/UX
    // Zwracamy teraz ogólną strukturę dla obu tych serii,
    // ponieważ używają tych samych slotów.
    return [
        { type: 'blade', label: 'Blade' }, // Etykieta może być ogólna
        { type: 'rachet', label: 'Ratchet' },
        { type: 'bit', label: 'Bit' }
    ];
}


function handleSeriaChangeForSet(event) {
        const setIndex = parseInt(event.target.dataset.setIndex); // To jest indeks 0-3
        const nowaSeria = event.target.value;
        
        if (isNaN(setIndex) || !currentDeckBeingBuilt.sets[setIndex]) return;

        currentDeckBeingBuilt.sets[setIndex].seria = nowaSeria;

        // Wyczyść ID części poprzedniej serii (lub wszystkie dla bezpieczeństwa)
        if (nowaSeria === 'bx_ux') {
            currentDeckBeingBuilt.sets[setIndex].cx_lock_chipId = null;
            currentDeckBeingBuilt.sets[setIndex].cx_main_bladeId = null;
            currentDeckBeingBuilt.sets[setIndex].cx_assist_bladeId = null;
        } else if (nowaSeria === 'cx') {
            currentDeckBeingBuilt.sets[setIndex].bladeId = null;
        }
        // Można rozważyć czyszczenie ratchetId i bitId, jeśli chcesz wymusić ponowny wybór
        // currentDeckBeingBuilt.sets[setIndex].ratchetId = null;
        // currentDeckBeingBuilt.sets[setIndex].bitId = null;

        // Prerenderuj tylko sloty aktywnego zestawu i zaktualizuj jego statystyki
        renderActiveDeckSetSlots(); 
        // updateDeckStatsForSetInBuilder jest już wywoływane w renderActiveDeckSetSlots
        console.log(`Zmieniono serię dla zestawu ${setIndex + 1} na ${nowaSeria}.`);
    }
    

function fillDeckSlotsFromCurrentBuild() {
    const magazyn = getMagazyn();
    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets) {
        console.warn("Próba wypełnienia slotów, ale currentDeckBeingBuilt nie jest gotowy.");
        return;
    }

    currentDeckBeingBuilt.sets.forEach((set, setIndex) => {
        if (!set) { // Jeśli zestaw jest null (co nie powinno się zdarzyć przy dobrej inicjalizacji)
            console.warn(`Zestaw o indeksie ${setIndex} jest null w fillDeckSlotsFromCurrentBuild.`);
            // Można by tu spróbować zainicjalizować ten konkretny zestaw, jeśli to konieczne
            // currentDeckBeingBuilt.sets[setIndex] = initializeOrResetCurrentDeck().sets[0]; // Przykładowo
            return;
        }

        const partTypes = getPartTypesForSeria(set.seria);
        partTypes.forEach(partTypeInfo => {
            const slotSelector = `.deck-part-slot[data-set-index="${setIndex}"][data-slot-type="${partTypeInfo.type}"]`;
            const slotDiv = document.querySelector(slotSelector);
            if (!slotDiv) {
                console.warn(`Nie znaleziono slotu w DOM: ${slotSelector}`);
                return;
            }

            let partId = null;
            const partIdKey = getPartIdKeyForSlot(partTypeInfo.type, set.seria);
            if (partIdKey && set.hasOwnProperty(partIdKey)) {
                partId = set[partIdKey];
            }
            
            if (partId) {
                const partDetails = magazyn.find(p => p.id === partId);
                if (partDetails) {
                    let slotImageHTML;
                    if (partDetails.img && partDetails.img.trim() !== "") {
                        slotImageHTML = `<img src="${partDetails.img}" alt="${partDetails.nazwa}" style="width: 50px; height: 50px; object-fit: contain; border-radius: 4px;">`;
                    } else {
                        slotImageHTML = `<div class="dnd-slot-placeholder">Brak<br>Obr.</div>`;
                    }

                    slotDiv.innerHTML = `
                        <div class="part-info-container">
                            ${slotImageHTML}
                            <span class="part-name">${partDetails.nazwa}</span>
                        </div>
                        <button class="remove-part-btn" title="Usuń część">&times;</button>
                    `;
                    slotDiv.classList.add('filled');
                    slotDiv.dataset.currentPartId = partId;
                    slotDiv.querySelector('.remove-part-btn').addEventListener('click', () => removePartFromSlot(setIndex, partTypeInfo.type));
                } else {
                    slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj (ID: ${partId} nie znalezione)</span>`;
                    slotDiv.classList.remove('filled');
                    delete slotDiv.dataset.currentPartId;
                    // Opcjonalnie: wyczyść ID w modelu, jeśli część nie istnieje w magazynie
                    // if (partIdKey) currentDeckBeingBuilt.sets[setIndex][partIdKey] = null;
                }
            } else {
                slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj</span>`;
                slotDiv.classList.remove('filled');
                delete slotDiv.dataset.currentPartId;
            }
        });
    });
}


// =================================
// Drag and Drop - Event Handlers
// =================================
let draggedItemData = null; // Przechowuje dane przeciąganego elementu

function handleDragStart(event) {
    try {
        draggedItemData = JSON.parse(event.target.dataset.partData);
        event.dataTransfer.setData("text/plain", draggedItemData.id); // Potrzebne dla Firefoxa
        event.dataTransfer.effectAllowed = "move";
        event.target.classList.add('dragging');
        console.log("DragStart:", draggedItemData);
    } catch (e) {
        console.error("Błąd w handleDragStart podczas parsowania JSON:", e, "Dane:", event.target.dataset.partData);
        draggedItemData = null;
        event.preventDefault(); // Anuluj przeciąganie, jeśli dane są złe
    }
}

function handleDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    event.currentTarget.classList.add('drag-over-target');
}

function handleDragEnter(event) {
    event.preventDefault();
    event.currentTarget.classList.add('drag-over-target');
}

function handleDragLeave(event) {
    event.currentTarget.classList.remove('drag-over-target');
}
function handleDrop(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over-target');

    if (!draggedItemData) { return; }

    const dropZone = event.currentTarget;
    const setArrayIndex = parseInt(dropZone.dataset.setIndex);
    const slotType = dropZone.dataset.slotType; 
    
    if (isNaN(setArrayIndex) || !currentDeckBeingBuilt.sets[setArrayIndex]) {
        draggedItemData = null;
        return;
    }

    const targetSet = currentDeckBeingBuilt.sets[setArrayIndex];
    const partActualType = draggedItemData.typ; 

    const normalizedSlotType = slotType.replace(/_/g, '-');
    
    let isTypeValid = false;
    // Sprawdzamy, czy upuszczamy część 'blade' LUB 'ux-blade' na slot 'blade'
    if (normalizedSlotType === 'blade' && (partActualType === 'blade' || partActualType === 'ux-blade')) {
        isTypeValid = true;
    } else if (normalizedSlotType === partActualType) {
        // Dla wszystkich innych typów (ratchet, bit, cx-*) reguła pozostaje bez zmian
        isTypeValid = true;
    }

    if (!isTypeValid) {
        const slotLabelElement = dropZone.querySelector('span');
        const slotLabel = slotLabelElement ? slotLabelElement.textContent.replace('Upuść ', '').replace(' tutaj', '') : slotType;
        showNotification(`Nie można umieścić części typu "${partActualType}" w slocie na "${slotLabel}".`, 4000, 'warning');
        draggedItemData = null;
        return;
    }
    
    // --- OSTATECZNA POPRAWKA LOGIKI KLUCZA ID ---
    // Definiujemy mapę kluczy bezpośrednio tutaj, dla maksymalnej jasności.
    const keyMap = {
        'blade': 'bladeId',
        'ux-blade': 'bladeId', // Najważniejsza linijka: 'ux-blade' również mapuje na 'bladeId'
        'rachet': 'ratchetId',
        'bit': 'bitId',
        'cx-lock-chip': 'cx_lock_chipId',
        'cx-main-blade': 'cx_main_bladeId',
        'cx-assist-blade': 'cx_assist_bladeId'
    };
    const partIdKey = keyMap[partActualType];
    // --- KONIEC OSTATECZNEJ POPRAWKI ---
    
    if (!partIdKey) {
        // Ten błąd już się nie powinien pojawić po powyższej poprawce.
        console.error(`Błąd krytyczny: Nie znaleziono klucza ID dla typu "${partActualType}"`);
        draggedItemData = null;
        return;
    }

    const newPartId = draggedItemData.id;
    let isAlreadyInDeck = false;
    currentDeckBeingBuilt.sets.forEach((set, idx) => {
        Object.keys(set).forEach(key => {
            if (key.endsWith('Id') && set[key] === newPartId) {
                if (!(idx === setArrayIndex && key === partIdKey)) {
                    isAlreadyInDeck = true;
                }
            }
        });
    });

    if (isAlreadyInDeck) {
        showNotification(`Część "${draggedItemData.nazwa}" jest już użyta w tym decku.`, 3500, 'warning');
        draggedItemData = null;
        return;
    }
    
    targetSet[partIdKey] = draggedItemData.id;

    const trybIndexKey = partIdKey.replace('Id', 'AktywnyTrybIndex');
    if (targetSet.hasOwnProperty(trybIndexKey)) {
        targetSet[trybIndexKey] = draggedItemData.aktywnyTrybIndex || 0;
    }

    console.log(`Zaktualizowano zestaw ${setArrayIndex + 1} po dropie:`, JSON.parse(JSON.stringify(targetSet)));

    renderActiveDeckSetSlots();
    
    draggedItemData = null;
}


function handleDragEnd(event) {
    event.target.classList.remove('dragging');
    draggedItemData = null; // Zawsze resetuj na końcu przeciągania
}

function getPartIdKeyForSlot(slotType, seria) {
    // Usunięto wszystkie `if`, zastąpione prostą mapą, która jest niezawodna.
    const keyMap = {
        'blade': 'bladeId',
        'rachet': 'ratchetId',
        'bit': 'bitId',
        'cx-lock-chip': 'cx_lock_chipId',
        'cx-main-blade': 'cx_main_bladeId',
        'cx-assist-blade': 'cx_assist_bladeId'
    };

    // Normalizujemy wejściowy slotType, aby upewnić się, że nie ma w nim podkreślników.
    const normalizedSlotType = String(slotType).replace(/_/g, '-');
    
    // Zwracamy klucz z mapy. Jeśli nie zostanie znaleziony, zwróci `undefined`, co jest ok.
    return keyMap[normalizedSlotType] || null;
}


function removePartFromSlot(setArrayIndex, slotType) {
    if (isNaN(setArrayIndex) || !currentDeckBeingBuilt || !currentDeckBeingBuilt.sets[setArrayIndex]) {
        console.error("Błąd w removePartFromSlot: Nieprawidłowy indeks zestawu lub brak danych.");
        return;
    }
    
    const targetSet = currentDeckBeingBuilt.sets[setArrayIndex];
    const partIdKey = getPartIdKeyForSlot(slotType, targetSet.seria);

    if (partIdKey && targetSet.hasOwnProperty(partIdKey) && targetSet[partIdKey] !== null) {
        console.log(`Usuwanie części (ID: ${targetSet[partIdKey]}) ze slotu ${slotType} w zestawie ${setArrayIndex + 1}`);
        targetSet[partIdKey] = null; // Usuń ID części z modelu

        // Po usunięciu części (zwłaszcza jeśli to był Ratchet, który mógł wpływać na stan slotu Bit),
        // odśwież całe sloty aktywnego zestawu.
        // renderActiveDeckSetSlots zajmie się aktualizacją UI i statystyk.
        renderActiveDeckSetSlots(); 
        
        // Nie ma potrzeby wywoływać tu updateDeckStatsForSetInBuilder,
        // ponieważ renderActiveDeckSetSlots już to robi.
    } else {
        console.warn(`Próba usunięcia części ze slotu ${slotType} w zestawie ${setArrayIndex + 1}, ale slot był już pusty lub klucz nieprawidłowy.`);
    }
}

// =================================
// Deck Builder - Statystyki i Zapis
// =================================
function updateDeckStatsForSetInBuilder(displaySetNumber) {
    const setArrayIndex = displaySetNumber - 1;
    if (!currentDeckBeingBuilt.sets[setArrayIndex]) return;

    const setConfig = currentDeckBeingBuilt.sets[setArrayIndex];
    const magazyn = getMagazyn();

    const getPartDetailsWithMode = (partId, activeModeIndexKey) => {
        if (!partId) return null;
        const part = magazyn.find(p => p.id === partId);
        if (!part) return null;

        const activeModeIndex = setConfig[activeModeIndexKey] || 0;

        if (part.maTryby && Array.isArray(part.tryby) && part.tryby[activeModeIndex]) {
            const basePart = { ...part };
            delete basePart.tryby;
            const activeModeData = part.tryby[activeModeIndex];
            return { ...basePart, ...activeModeData };
        }
        return part;
    };

    let czesciDoObliczen = {};
    if (setConfig.seria === 'bx_ux') {
        czesciDoObliczen.blade = getPartDetailsWithMode(setConfig.bladeId, 'bladeAktywnyTrybIndex');
        czesciDoObliczen.rachet = getPartDetailsWithMode(setConfig.ratchetId, 'ratchetAktywnyTrybIndex');
        czesciDoObliczen.bit = getPartDetailsWithMode(setConfig.bitId, 'bitAktywnyTrybIndex');
    } else if (setConfig.seria === 'cx') {
        czesciDoObliczen.cx_lock_chip = getPartDetailsWithMode(setConfig.cx_lock_chipId, 'cx_lock_chipAktywnyTrybIndex');
        czesciDoObliczen.cx_main_blade = getPartDetailsWithMode(setConfig.cx_main_bladeId, 'cx_main_bladeAktywnyTrybIndex');
        czesciDoObliczen.cx_assist_blade = getPartDetailsWithMode(setConfig.cx_assist_bladeId, 'cx_assist_bladeAktywnyTrybIndex');
        czesciDoObliczen.rachet = getPartDetailsWithMode(setConfig.ratchetId, 'ratchetAktywnyTrybIndex');
        czesciDoObliczen.bit = getPartDetailsWithMode(setConfig.bitId, 'bitAktywnyTrybIndex');
    }

    const obliczoneStatystyki = obliczSumeStatystykZestawu(czesciDoObliczen, setConfig.seria);
    currentDeckBeingBuilt.sets[setArrayIndex].statystykiObliczone = obliczoneStatystyki;

    const statsDiv = document.getElementById(`deck-stats-${displaySetNumber}`);
    if (statsDiv) {
        let statsTextHTML = ``;
        statsTextHTML += `<b>SUMA (${setConfig.seria.toUpperCase().replace('_','/')}):</b> `;
        statsTextHTML += `ATK: ${obliczoneStatystyki.ATK}, DEF: ${obliczoneStatystyki.DEF}, STM: ${obliczoneStatystyki.STM}, Waga: ${obliczoneStatystyki.WAGA}g`;
        const jestSpecjalnyRatchet = czesciDoObliczen.rachet && (String(czesciDoObliczen.rachet.id) === "205" || czesciDoObliczen.rachet.integrujeBit === true);
        if ((setConfig.seria === 'bx_ux' && !jestSpecjalnyRatchet && czesciDoObliczen.bit) || (setConfig.seria === 'cx' && !jestSpecjalnyRatchet && czesciDoObliczen.bit) || jestSpecjalnyRatchet) {
            if (obliczoneStatystyki.DASH !== 0) statsTextHTML += `, DASH: ${obliczoneStatystyki.DASH}`;
            if (obliczoneStatystyki.B_RES !== 0) statsTextHTML += `, B-RES: ${obliczoneStatystyki.B_RES}`;
        }
        if (setConfig.seria === 'cx' && obliczoneStatystyki.CX_LC_WYTRZ !== 0) {
            statsTextHTML += `, LC-W: ${obliczoneStatystyki.CX_LC_WYTRZ}`;
        }
        statsDiv.innerHTML = statsTextHTML;
    }
    return obliczoneStatystyki;
}

function saveCurrentDeck() {
    const deckNameInput = document.getElementById('deckName');
    const deckName = deckNameInput ? deckNameInput.value.trim() : (currentDeckBeingBuilt.name || '');

    if (!deckName && !currentEditingDeckId) {
        showNotification("Wpisz nazwę dla nowego decku.", 3000, 'warning');
        deckNameInput?.focus();
        return;
    }

    const nonEmptySets = currentDeckBeingBuilt.sets.filter(set => {
        if (!set) return false;
        return set.bladeId || set.ratchetId || set.bitId || set.cx_lock_chipId || set.cx_main_bladeId || set.cx_assist_bladeId;
    });

    if (nonEmptySets.length === 0 && !currentEditingDeckId) {
        showNotification("Nie skonfigurowano żadnych części w żadnym zestawie.", 3000, 'warning');
        return;
    }

    // Walidacja duplikatów i Clock Mirage (pozostaje bez zmian, bo jest poprawna)
    const magazyn = getMagazyn();
    const allPartIdsInDeck = new Set();
    let duplicateFound = false;

    for (const set of nonEmptySets) {
        if (set.seria === 'bx_ux' && set.bladeId === ID_CLOCK_MIRAGE && set.ratchetId) {
            const ratchetDetails = magazyn.find(p => p.id === set.ratchetId);
            if (ratchetDetails && !(ratchetDetails.nazwa.match(/-\d*5$/) || ratchetDetails.nazwa.match(/^M-\d*5$/))) {
                showNotification(`Błąd w zestawie: Clock Mirage jest połączony z niekompatybilnym Ratchetem.`, 6000, 'error');
                return;
            }
        }
        const partIdsInSet = [set.bladeId, set.ratchetId, set.bitId, set.cx_lock_chipId, set.cx_main_bladeId, set.cx_assist_bladeId].filter(Boolean);
        for (const partId of partIdsInSet) {
            if (allPartIdsInDeck.has(partId)) {
                duplicateFound = true;
                break;
            }
            allPartIdsInDeck.add(partId);
        }
        if (duplicateFound) break;
    }
    if (duplicateFound) {
        showNotification(`Jedna z części jest użyta więcej niż raz w tym decku. Popraw konfigurację.`, 4000, 'error');
        return;
    }
    
    // --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
    
    // Tworzymy nową, czystą wersję decku do zapisu.
    // Używamy `map`, aby przetworzyć każdy zestaw.
    const setsToSave = nonEmptySets.map(set => {
        // Kopiujemy wszystkie właściwości zestawu, w tym ID części ORAZ `aktywnyTrybIndex`.
        const cleanSet = { ...set };
        
        // Obliczamy i nadpisujemy statystyki, aby były aktualne w momencie zapisu.
        // Znajdujemy indeks tego zestawu w oryginalnym obiekcie `currentDeckBeingBuilt`
        const originalIndex = currentDeckBeingBuilt.sets.findIndex(s => s === set);
        if (originalIndex !== -1) {
            cleanSet.statystykiObliczone = updateDeckStatsForSetInBuilder(originalIndex + 1);
        }
        
        return cleanSet;
    });
    // --- KONIEC KLUCZOWEJ POPRAWKI ---

    let savedDecks = getSavedDecks();
    const finalDeckName = deckName || (currentEditingDeckId ? savedDecks.find(d => d.id === currentEditingDeckId)?.name : `Deck ${new Date().toLocaleTimeString('pl-PL')}`);

    const deckToSave = {
        id: currentEditingDeckId || currentDeckBeingBuilt.id,
        name: finalDeckName,
        sets: setsToSave, // Zapisujemy nową, czystą tablicę zestawów
        timestamp: currentEditingDeckId ? (savedDecks.find(d => d.id === currentEditingDeckId)?.timestamp || Date.now()) : Date.now(),
        lastModified: Date.now()
    };
    
    // Logika aktualizacji lub dodawania nowego decku (bez zmian)
    if (currentEditingDeckId) {
        const deckIndex = savedDecks.findIndex(d => d.id === currentEditingDeckId);
        if (deckIndex > -1) {
            savedDecks[deckIndex] = deckToSave;
            showNotification(`Deck "${finalDeckName}" zaktualizowany!`, 3000, 'success');
        } else {
            savedDecks.push(deckToSave);
            showNotification(`Deck "${finalDeckName}" zapisany (jako nowy)!`, 3000, 'success');
        }
    } else {
        savedDecks.push(deckToSave);
        showNotification(`Deck "${finalDeckName}" zapisany!`, 3000, 'success');
    }

    setSavedDecks(savedDecks);
    clearCurrentDeckForBuilder();
}



// ======================================================================
// ======================================================================
// === OSTATECZNA, KOMPLETNA I POPRAWNA WERSJA displaySavedDecks() ===
// ======================================================================
function displaySavedDecks() {
    const container = document.getElementById('savedDecksContainer');
    if (!container) return;
    container.innerHTML = '';
    const savedDecks = getSavedDecks();
    if (!savedDecks || savedDecks.length === 0) {
        container.innerHTML = '<div class="card" style="grid-column: 1 / -1; text-align: center;"><p>Nie masz zapisanych decków.</p></div>';
        return;
    }

    savedDecks.sort((a, b) => (b.lastModified || b.timestamp || 0) - (a.lastModified || a.timestamp || 0));
    const magazynCzesci = getMagazyn();
    const iconMap = {
        seria: { 'bx_ux': 'img/bx.webp', 'cx': 'img/cx.webp' },
        rodzaj: { 'atak': 'img/attack.webp', 'obrona': 'img/defence.webp', 'wytrzymalosc': 'img/stamina.webp', 'balans': 'img/balance.webp' },
        kierunek: { 'prawy': 'img/prawo.png', 'lewy': 'img/lewo.png', 'oba': 'img/dual.png' }
    };
    const backgroundSymbolMap = { 'bx': 'img/bx.webp', 'ux': 'img/ux.webp', 'cx': 'img/cx.webp' };

    savedDecks.forEach(deck => {
        if (!deck || !deck.id || !Array.isArray(deck.sets)) return;
        const deckCard = document.createElement('div');
        deckCard.className = 'card saved-deck-card';
        deckCard.dataset.deckId = deck.id;
        
        let setsHTML = '';
        deck.sets.forEach((set, index) => {
            if (!set) return;

            const seriaZestawu = set.seria || 'bx_ux';
            const blade = set.bladeId ? magazynCzesci.find(p => p.id === set.bladeId) : null;
            let bgSymbolUrl = (seriaZestawu === 'cx') ? backgroundSymbolMap['cx'] : ((blade && blade.typ === 'ux-blade') ? backgroundSymbolMap['ux'] : backgroundSymbolMap['bx']);

            let ikonaSeriiHTML = '', ikonaSeriiUX_HTML = '', ikonaRodzajuHTML = '', ikonaKierunkuHTML = '';
            if (seriaZestawu === 'bx_ux') { if (blade && blade.typ === 'ux-blade') ikonaSeriiUX_HTML = `<img src="img/ux.webp" class="set-icon" title="Seria: UX">`; else ikonaSeriiHTML = `<img src="${iconMap.seria['bx_ux']}" class="set-icon" title="Seria: BX">`; } else if (seriaZestawu === 'cx') ikonaSeriiHTML = `<img src="${iconMap.seria['cx']}" class="set-icon" title="Seria: CX">`;
            const ratchet = set.ratchetId ? magazynCzesci.find(p => p.id === set.ratchetId) : null;
            const bit = set.bitId ? magazynCzesci.find(p => p.id === set.bitId) : null;
            let partWithRodzaj = (ratchet && ratchet.integrujeBit === true) ? ratchet : bit;
            if (partWithRodzaj && partWithRodzaj.rodzaj) ikonaRodzajuHTML = `<img src="${iconMap.rodzaj[partWithRodzaj.rodzaj] || ''}" class="set-icon" title="Typ: ${partWithRodzaj.rodzaj}">`;
            let ostrze = (seriaZestawu === 'cx') ? (set.cx_main_bladeId ? magazynCzesci.find(p => p.id === set.cx_main_bladeId) : null) : blade;
            if (ostrze && ostrze.kierunek) ikonaKierunkuHTML = `<img src="${iconMap.kierunek[ostrze.kierunek] || ''}" class="set-icon" title="Obroty: ${ostrze.kierunek}">`;
            
            const naglowekHTML = `<div class="set-header-container"><strong style="text-transform: capitalize;">Zestaw ${index + 1}</strong><div class="set-icons-container">${ikonaSeriiHTML}${ikonaSeriiUX_HTML}${ikonaRodzajuHTML}${ikonaKierunkuHTML}</div></div>`;

            const getPartDetailsAndHTML = (partId, partType, partTypeDefaultName) => {
                const part = partId ? magazynCzesci.find(p => String(p.id) == String(partId)) : null;
                let obrazekDoWyswietlenia = part?.img, nazwaDoWyswietlenia = part?.nazwa;
                if (part && part.maTryby && Array.isArray(part.tryby)) {
                    const partIdKey = getPartIdKeyForSlot(partType, seriaZestawu), trybIndexKey = partIdKey ? partIdKey.replace('Id', 'AktywnyTrybIndex') : null;
                    const zapisanyIndex = (trybIndexKey && set[trybIndexKey] !== undefined) ? set[trybIndexKey] : 0;
                    const aktywnyTryb = part.tryby[zapisanyIndex];
                    if (aktywnyTryb) { obrazekDoWyswietlenia = aktywnyTryb.img || part.img; nazwaDoWyswietlenia = `${part.nazwa} (${aktywnyTryb.nazwaTrybu})`; }
                }
                const imgHTML = obrazekDoWyswietlenia ? `<img src="${obrazekDoWyswietlenia}" alt="${part?.nazwa || partTypeDefaultName}" class="deck-part-img">` : `<div class="deck-part-placeholder">${partTypeDefaultName.substring(0,3).toUpperCase()}</div>`;
                return `<div class="part-with-name">${imgHTML}<span class="part-name-label">${nazwaDoWyswietlenia || 'Brak części'}</span></div>`;
            };

            const czySpecjalnyRatchetWDecku = ratchet && (String(ratchet.id) === "205" || ratchet.integrujeBit === true);
            let setImagesAndNamesHTML = '';
            if (seriaZestawu === 'bx_ux') {
                setImagesAndNamesHTML = `<div class="wynik-zestaw-obrazki">${getPartDetailsAndHTML(set.bladeId, 'blade', 'Blade')}${getPartDetailsAndHTML(set.ratchetId, 'rachet', 'Ratchet')}${czySpecjalnyRatchetWDecku ? `<div class="part-with-name"><img src="img/bitturbo.png" alt="Bit Zintegrowany" class="deck-part-img" title="Bit zintegrowany"><span class="part-name-label">(Bit zint.)</span></div>` : getPartDetailsAndHTML(set.bitId, 'bit', 'Bit')}</div>`;
            } else if (seriaZestawu === 'cx') {
                setImagesAndNamesHTML = `<div class="cx-images-container"><div class="cx-blade-row wynik-zestaw-obrazki">${getPartDetailsAndHTML(set.cx_lock_chipId, 'cx-lock-chip', 'LockChip')}${getPartDetailsAndHTML(set.cx_main_bladeId, 'cx-main-blade', 'MainBlade')}${getPartDetailsAndHTML(set.cx_assist_bladeId, 'cx-assist-blade', 'AssistBlade')}</div><div class="cx-drive-row wynik-zestaw-obrazki">${getPartDetailsAndHTML(set.ratchetId, 'rachet', 'Ratchet')}${czySpecjalnyRatchetWDecku ? `<div class="part-with-name"><img src="img/bitturbo.png" alt="Bit Zintegrowany" class="deck-part-img" title="Bit zintegrowany"><span class="part-name-label">(Bit zint.)</span></div>` : getPartDetailsAndHTML(set.bitId, 'bit', 'Bit')}</div></div>`;
            }

            let setStatsSummaryHTML = '<div class="stat-grid">';
            const stats = set.statystykiObliczone;
            if (stats) {
                setStatsSummaryHTML += `<span>ATK: ${stats.ATK || 0}</span><span>DEF: ${stats.DEF || 0}</span><span>STM: ${stats.STM || 0}</span><span>Waga: ${(stats.WAGA || 0)}g</span>`;
                if ((stats.DASH || 0) !== 0) setStatsSummaryHTML += `<span>DASH: ${stats.DASH || 0}</span>`;
                if ((stats.B_RES || 0) !== 0) setStatsSummaryHTML += `<span>B-RES: ${stats.B_RES || 0}</span>`;
                if (seriaZestawu === 'cx' && (stats.CX_LC_WYTRZ || 0) !== 0) setStatsSummaryHTML += `<span>LC-W: ${stats.CX_LC_WYTRZ || 0}</span>`;
            } else {
                setStatsSummaryHTML += '<span>Brak danych statystyk</span>';
            }
            setStatsSummaryHTML += `</div>`;
            const chartCanvasId = `chart-deck-${deck.id}-set-${index}`;

            // --- KLUCZOWA POPRAWKA STRUKTURY HTML ---
            setsHTML += `
                <div class="deck-card-set-preview" style="--bg-symbol-url: url('${bgSymbolUrl}');">
                    ${naglowekHTML}
                    ${setImagesAndNamesHTML}
                    <div class="set-preview-with-chart">
                        <div class="set-info-wrapper">
                            ${setStatsSummaryHTML}
                        </div>
                        <div class="set-chart-container">
                            <canvas id="${chartCanvasId}"></canvas>
                        </div>
                    </div>
                </div>
            `;
        });
        
        const actionsHTML = `<div class="item-actions"><button onclick="edytujDeck('${deck.id}')">Edytuj</button><button onclick="eksportujDeckDoPNG('${deck.id}')">PNG</button><button class="danger-btn" onclick="usunZapisanyDeck('${deck.id}')">Usuń</button></div>`;
        deckCard.innerHTML = `<h4>${deck.name || 'Deck bez nazwy'}</h4><p style="font-size: 0.75em; color: #aaa; margin-top: 0; margin-bottom:15px;">${deck.lastModified ? `Modyfikacja: ${new Date(deck.lastModified).toLocaleDateString('pl-PL')}` : `Zapisano: ${new Date(deck.timestamp || Date.now()).toLocaleDateString('pl-PL')}`}</p>${setsHTML}${actionsHTML}`;
        container.appendChild(deckCard);
    });

    initializeChartsForSavedDecks(savedDecks);
}

// ======================================================================
// === NOWA, OSOBNA FUNKCJA DO TWORZENIA WYKRESÓW ===
// ======================================================================
function initializeChartsForSavedDecks(decks) {
    if (typeof Chart === 'undefined') {
        console.error("Chart.js nie jest załadowany!");
        return;
    }

    decks.forEach(deck => {
        if (!deck || !Array.isArray(deck.sets)) return;

        deck.sets.forEach((set, index) => {
            const chartId = `chart-deck-${deck.id}-set-${index}`;
            const ctx = document.getElementById(chartId);
            if (!ctx) { return; }

            const stats = set.statystykiObliczone || {};
            
            const labels = ['ATK', 'DEF', 'STM', 'Waga', 'DASH', 'B-RES'];
            const dataValues = [
                stats.ATK || 0,
                stats.DEF || 0,
                stats.STM || 0,
                stats.WAGA || 0,
                stats.DASH || 0,
                stats.B_RES || 0
            ];

            const chartConfig = {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Statystyki',
                        data: dataValues,
                        backgroundColor: 'rgba(162, 95, 240, 0.3)',
                        borderColor: 'rgba(180, 120, 255, 1)',
                        pointBackgroundColor: 'rgba(210, 180, 255, 1)',
                        pointBorderColor: '#fff',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    elements: { line: { borderWidth: 2 } },
                    scales: {
                        r: {
                            angleLines: { color: 'rgba(255, 255, 255, 0.2)' },
                            grid: { color: 'rgba(255, 255, 255, 0.2)' },
                            pointLabels: {
                                color: '#ddd',
                                font: { family: "'Kode Mono', monospace", size: 10 }
                            },
                            ticks: { display: false, stepSize: 25 },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { 
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            bodyFont: { family: "'Kode Mono', monospace" }
                         }
                    }
                }
            };
            new Chart(ctx, chartConfig);
        });
    });
}

function eksportujDeckDoPNG(deckId) {
    const kartaDecku = document.querySelector(`.saved-deck-card[data-deck-id="${deckId}"]`);
    if (!kartaDecku) {
        showNotification("Błąd: Nie znaleziono karty decku do eksportu.", 3000, 'error');
        return;
    }

    const przyciskiAkcji = kartaDecku.querySelector('.item-actions');
    const nazwaDecku = kartaDecku.querySelector('h4')?.textContent || 'deck_bez_nazwy';
    const nazwaPliku = `${nazwaDecku.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;

    showNotification("Przygotowuję obraz PNG...", 2500, 'info');

    // Krok 1: Przygotowanie do eksportu (ukrycie niepotrzebnych elementów)
    if (przyciskiAkcji) {
        przyciskiAkcji.style.display = 'none';
    }

    const zestawyWDecku = kartaDecku.querySelectorAll('.deck-card-set-preview');
    // === KLUCZOWA POPRAWKA #1: Inicjalizujemy pustą tablicę ===
    const dodaneObrazkiTla = [];

    zestawyWDecku.forEach(zestawNode => {
        // Ukrywamy tło z CSS, aby uniknąć dublowania
        zestawNode.classList.add('exporting-png');

        const stylZestawu = zestawNode.getAttribute('style');
        if (!stylZestawu) return;

        const urlMatch = stylZestawu.match(/--bg-symbol-url:\s*url\(['"]?([^'"]+)['"]?\)/);

        if (urlMatch && urlMatch[1]) {
            const urlObrazka = urlMatch[1];
            if (urlObrazka.trim() !== "") {
                const bgImage = document.createElement('img');
                bgImage.src = urlObrazka;
                // Dodajemy klasę, aby CSS mógł nadać style (pozycja, rozmiar)
                bgImage.className = 'background-symbol-img'; 
                
                // Ustawiamy przezroczystość bezpośrednio w JS - to najważniejszy krok wizualny
                bgImage.style.opacity = '0.15';

                zestawNode.prepend(bgImage);

                // === KLUCZOWA POPRAWKA #2: Poprawiona nazwa zmiennej ===
                // Teraz poprawnie dodajemy obrazek do tablicy, aby go później usunąć.
                dodaneObrazkiTla.push(bgImage);
            }
        }
    });

    const opcjeRenderowania = {
        bgcolor: '#101018',
        cacheBust: true
    };

    // Krok 2: Generowanie obrazu (z opóźnieniem)
    setTimeout(() => {
        domtoimage.toPng(kartaDecku, opcjeRenderowania)
            .then(function (dataUrl) {
                // Logika zapisu pliku (bez zmian)
                if (window.Android && typeof window.Android.zapiszObrazPNG === 'function') {
                    const base64Data = dataUrl.split(',')[1];
                    window.Android.zapiszObrazPNG(base64Data, nazwaPliku);
                    showNotification("Przekazano obraz do zapisu...", 2500, 'success');
                } else {
                    const link = document.createElement('a');
                    link.download = nazwaPliku;
                    link.href = dataUrl;
                    link.click();
                    showNotification("Eksport do PNG zakończony!", 2500, 'success');
                }
            })
            .catch(function (error) {
                console.error('Błąd podczas generowania obrazu:', error);
                showNotification("Wystąpił błąd podczas eksportu do PNG.", 4000, 'error');
            })
            .finally(() => {
                // Krok 3: Sprzątanie po eksporcie (zawsze się wykonuje)
                console.log(`Sprzątanie po eksporcie. Znaleziono ${dodaneObrazkiTla.length} obrazków do usunięcia.`);
                
                // Usuwamy dynamicznie dodane obrazki
                dodaneObrazkiTla.forEach(img => img.remove());
                
                // Pokazujemy z powrotem przyciski
                if (przyciskiAkcji) {
                    przyciskiAkcji.style.display = 'flex';
                }
                
                // Przywracamy widoczność tła z CSS
                zestawyWDecku.forEach(zestawNode => {
                    zestawNode.classList.remove('exporting-png');
                });
            });
    }, 500);
}

function edytujDeck(deckId) {
    const savedDecks = getSavedDecks(); // Pobierz najświeższą listę decków
    const deckToEdit = savedDecks.find(d => d.id === deckId);

    if (!deckToEdit) { 
        showNotification("Nie znaleziono decku do edycji.", 3000, 'error'); 
        return; 
    }
    
    // Ustaw currentEditingDeckId PRZED nawigacją, aby navigateTo wiedziało, że edytujemy
    currentEditingDeckId = deckId;
    
    // Inicjalizuj currentDeckBeingBuilt z danymi decku do edycji
    // Ta funkcja powinna głęboko skopiować deckToEdit i upewnić się, że struktura jest kompletna (np. 4 sety)
    initializeOrResetCurrentDeck(deckToEdit); 

    // Zawsze zaczynaj edycję od wyświetlenia pierwszej zakładki/zestawu
    currentlyActiveSetIndexInBuilder = 0; 

    // Ustaw nazwę decku w polu input
    const deckNameInput = document.getElementById('deckName');
    if (deckNameInput) {
        deckNameInput.value = deckToEdit.name || '';
    }
    
    // Nawiguj do strony Deck Buildera
    const linkDoDeckBuildera = document.querySelector('.sidebar a[onclick*="navigateTo(\'deck"]');
    if(linkDoDeckBuildera) {
        // navigateTo('deck', linkDoDeckBuildera) samo wywoła renderDeckBuilderAndParts,
        // które z kolei użyje currentlyActiveSetIndexInBuilder do wyrenderowania odpowiedniej zakładki i slotów.
        navigateTo('deck', linkDoDeckBuildera); 
    } else { 
        showNotification("Błąd krytyczny: Brak linku nawigacyjnego do Deck Generatora.", 3000, 'error'); 
        currentEditingDeckId = null; // Zresetuj tryb edycji, bo nawigacja nieudana
        initializeOrResetCurrentDeck(); // Wyczyść builder
        return; 
    }
    
    // Po nawigacji i renderowaniu (które dzieje się asynchronicznie w navigateTo),
    // zaktualizuj tekst przycisku zapisu i pokaż powiadomienie.
    // Używamy setTimeout, aby dać DOM czas na aktualizację po wywołaniu navigateTo.
    setTimeout(() => { 
        const saveButton = document.getElementById('saveDeckButton');
        if (saveButton) {
            saveButton.textContent = 'Zapisz Zmiany w Decku';
        }
        showNotification(`Edytujesz deck: "${deckToEdit.name || 'Bez nazwy'}". Wyświetlono Zestaw 1.`, 3500, 'info');
        
        // Opcjonalnie: przewiń do góry strony deck buildera lub do nazwy decku
        const deckBuilderSection = document.getElementById('deck');
        if (deckBuilderSection) {
            deckBuilderSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } else if (deckNameInput) {
            deckNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 150); // Małe opóźnienie, można dostosować w razie potrzeby
}

    function usunZapisanyDeck(deckId) {
        if (!deckId) { showNotification("Błąd: Brak ID decku.", 3000, 'info'); return; }
        const savedDecks = getSavedDecks();
        const deckToDelete = savedDecks.find(deck => deck.id === deckId);
        
        if (!deckToDelete) { 
            showNotification("Nie znaleziono decku do usunięcia.", 3000, 'info'); 
            // displaySavedDecks(); // Można odświeżyć, jeśli podejrzewamy niespójność stanu
            return; 
        }
        
        // Logika usuwania wykonywana jest teraz bezpośrednio:
        const updatedDecks = savedDecks.filter(deck => deck.id !== deckId);
        setSavedDecks(updatedDecks);
        showNotification(`Deck "${deckToDelete.name || 'Bez nazwy'}" usunięty.`, 3000, 'info');
        
        // Odśwież listę, jeśli jesteśmy na stronie galerii
        if (document.getElementById('galeriaDeckow')?.classList.contains('active')) {
            displaySavedDecks();
        }
        
        // Jeśli edytowany deck został usunięty, wyczyść builder
        if (currentEditingDeckId === deckId) { 
            clearCurrentDeckForBuilder();
        }
    }
    

// =================================
// Import/Eksport Magazynu
// =================================
function eksportujDaneDoPolaTekstowego() {
    const magazyn = getMagazyn();
    const poleTekstowe = document.getElementById('poleDanychJsonMagazyn');
    if (poleTekstowe) {
        if (magazyn && magazyn.length > 0) {
            try {
                poleTekstowe.value = JSON.stringify(magazyn, null, 2); 
                showNotification('Dane magazynu skopiowane do pola.', 3000, 'success'); 
                poleTekstowe.focus(); poleTekstowe.select();
            } catch (e) { showNotification('Błąd konwersji magazynu do JSON.', 3000, 'error'); poleTekstowe.value = 'Błąd JSON.';}
        } else { poleTekstowe.value = ''; showNotification('Magazyn jest pusty.', 3000, 'info'); }
    } else showNotification('Błąd: Pole tekstowe magazynu nie znalezione.', 3000, 'error');
}

function importujDaneZPolaTekstowego() {
    const poleTekstowe = document.getElementById('poleDanychJsonMagazyn');
    if (!poleTekstowe || !poleTekstowe.value.trim()) {
        showNotification('Pole danych magazynu jest puste.', 3000, 'warning'); return;
    }
    let daneDoImportu;
    try { daneDoImportu = JSON.parse(poleTekstowe.value); } 
    catch (e) { showNotification('Błąd importu: Nieprawidłowy JSON w danych magazynu.', 3000, 'error'); console.error("Błąd parsowania JSON (magazyn):", e); return; }
    przetworzIDopiszDaneMagazynu(daneDoImportu, 'Pole Tekstowe JSON', false); // false = nie zeruj ilości
}

// Zmodyfikuj sygnaturę funkcji:
function przetworzIDopiszDaneMagazynu(daneDoImportu, zrodloDanychOpis, ustawDomyslnaIloscDlaNowychNaZero = false, trybCichy = false) {
    if (!Array.isArray(daneDoImportu)) {
        if (!trybCichy) showNotification(`Błąd importu z '${zrodloDanychOpis}': Nieprawidłowy format (oczekiwano tablicy).`, 3000, 'error');
        console.error(`[IMPORT ERROR] Dane wejściowe z '${zrodloDanychOpis}' nie są tablicą:`, daneDoImportu);
        return false;
    }

    // Prosta funkcja do tworzenia czystego obiektu części z pliku JSON
    const stworzObiektCzesci = (item) => {
        if (!item || typeof item !== 'object' || !item.id) return null;
        
        const ilosc = ustawDomyslnaIloscDlaNowychNaZero ? 0 : (parseInt(item.ilosc, 10) || 0);
        
        // --- NOWA, UPROSZCZONA LOGIKA ---
        // Zawsze bierzemy wszystkie dane z pliku źródłowego, bez skomplikowanego wypełniania.
        const nowaCzesc = { ...item }; // Kopiujemy wszystkie właściwości
        nowaCzesc.ilosc = ilosc; // Ustawiamy tylko poprawną ilość
        // --- KONIEC NOWEJ LOGIKI ---

        return nowaCzesc;
    };

    const czesciImportowaneMap = new Map(
        daneDoImportu.map(item => stworzObiektCzesci(item)).filter(Boolean).map(czesc => [String(czesc.id), czesc])
    );

    let aktualnyMagazyn = getMagazyn();
    let dodanoNowychCzesci = 0;
    let zaktualizowanoDaneCzesci = 0;

    // Przejdź przez istniejący magazyn, zaktualizuj go danymi z importu
    aktualnyMagazyn.forEach(istniejacaCzesc => {
        const id = String(istniejacaCzesc.id);
        if (czesciImportowaneMap.has(id)) {
            const importowanaCzesc = czesciImportowaneMap.get(id);
            const iloscDoZachowania = ustawDomyslnaIloscDlaNowychNaZero ? istniejacaCzesc.ilosc : importowanaCzesc.ilosc;
            
            const finalnaCzesc = { ...importowanaCzesc, ilosc: iloscDoZachowania };

            // Sprawdzamy, czy dane (oprócz ilości) się zmieniły
            if (JSON.stringify({ ...istniejacaCzesc, ilosc: null }) !== JSON.stringify({ ...finalnaCzesc, ilosc: null })) {
                zaktualizowanoDaneCzesci++;
            }
            
            // Nadpisujemy starą część w magazynie
            const index = aktualnyMagazyn.findIndex(c => String(c.id) === id);
            if (index !== -1) {
                aktualnyMagazyn[index] = finalnaCzesc;
            }
            czesciImportowaneMap.delete(id); // Usuwamy, aby nie dodawać jej ponownie
        }
    });

    // Dodaj pozostałe (nowe) części z mapy importu do magazynu
    if (czesciImportowaneMap.size > 0) {
        dodanoNowychCzesci = czesciImportowaneMap.size;
        aktualnyMagazyn.push(...czesciImportowaneMap.values());
    }

    setMagazyn(aktualnyMagazyn);
    
    // Logika powiadomień (bez zmian)
    let msg = '';
    if (dodanoNowychCzesci > 0) msg += `Dodano ${dodanoNowychCzesci} nowych części. `;
    if (zaktualizowanoDaneCzesci > 0) msg += `Zaktualizowano dane dla ${zaktualizowanoDaneCzesci} istniejących części. `;

    if (!trybCichy) {
        if (msg) showNotification(`Import z '${zrodloDanychOpis}' zakończony! ${msg.trim()}`, 4500, 'success');
        else showNotification(`Magazyn jest aktualny.`, 3000, 'info');
    } else {
        if (msg) console.log(`[TRYB CICHY] Import z '${zrodloDanychOpis}': ${msg.trim()}`);
        else console.log(`[TRYB CICHY] Magazyn aktualny.`);
    }

    const aktywnaStronaId = document.querySelector('.page.active')?.id;
    if (aktywnaStronaId === 'magazyn') wyswietlMagazyn();
    if (aktywnaStronaId === 'deck') renderDeckBuilderAndParts();

    return (dodanoNowychCzesci > 0 || zaktualizowanoDaneCzesci > 0);
}

// Zmodyfikuj sygnaturę funkcji:
function importujMagazynZBazyDomyslnejHTML(trybCichy = false) {
    const nazwaZrodla = 'Domyślna Baza (z HTML)';
    try {
        const scriptTag = document.getElementById('domyslnaBazaDanychJson');
        if (!scriptTag) { 
            if (!trybCichy) showNotification("Błąd: Brak źródła danych domyślnych (#domyslnaBazaDanychJson).", 4000, 'error');
            return false; // Dodano zwracanie wartości
        }
        // ... (reszta kodu pobierania JSONa - bez zmian) ...
        const jsonString = scriptTag.textContent;
        if (!jsonString || jsonString.trim() === '') {
            if (!trybCichy) showNotification("Błąd: Domyślna baza danych w HTML jest pusta.", 4000, 'error');
            return false;
        }
        let daneDoImportu;
        try { daneDoImportu = JSON.parse(jsonString); } 
        catch (parseError) { 
            if (!trybCichy) showNotification("Błąd: Nieprawidłowy JSON w domyślnej bazie danych.", 5000, 'error');
            console.error("Błąd parsowania JSON (baza domyślna):", parseError); 
            return false; 
        }
        
        // true = ustaw ilość na 0 dla nowych części, nie nadpisuj ilości istniejących na te z bazy (bo tam jest 0)
        // przekazujemy trybCichy do przetworzIDopiszDaneMagazynu
        const wynikPrzetwarzania = przetworzIDopiszDaneMagazynu(daneDoImportu, nazwaZrodla, true, trybCichy); 
        return wynikPrzetwarzania; // Zwróć wynik z przetworzIDopiszDaneMagazynu

    } catch (error) { 
        if (!trybCichy) showNotification(`Krytyczny błąd importu z domyślnej bazy: ${error.message}`, 4000, 'error');
        console.error(error); 
        return false;
    }
}


// =================================
// Import/Eksport Decków
// =================================
function eksportujDeckiDoPolaTekstowego() {
    const savedDecks = getSavedDecks();
    const poleTekstoweDecki = document.getElementById('poleDanychJsonDecki');
    if (poleTekstoweDecki) {
        if (savedDecks && savedDecks.length > 0) {
            try {
                const jsonString = JSON.stringify(savedDecks, null, 2);
                poleTekstoweDecki.value = jsonString;
                showNotification('Zapisane decki skopiowane do pola.', 3000, 'success');
                poleTekstoweDecki.focus(); poleTekstoweDecki.select();
            } catch (e) { showNotification('Błąd konwersji decków do JSON.', 3000, 'error'); poleTekstoweDecki.value = 'Błąd JSON.'; }
        } else { poleTekstoweDecki.value = ''; showNotification('Brak decków do eksportu.', 3000, 'info'); }
    } else showNotification('Błąd: Pole tekstowe decków nie znalezione.', 3000, 'error');
}

function walidujIPrzygotujPojedynczyDeckDoDodania(deckObj, defaultNamePrefix = "Importowany Deck") {
    if (!deckObj || typeof deckObj !== 'object') {
        console.warn("[VALIDATE_DECK_WARN] Dane wejściowe nie są obiektem.", deckObj); return null;
    }
    if (typeof deckObj.id !== 'string' || !deckObj.id.trim() || 
        !(typeof deckObj.name === 'string' || deckObj.name === null || deckObj.name === undefined) || 
        !Array.isArray(deckObj.sets)) {
        console.warn("[VALIDATE_DECK_WARN] Nieprawidłowa struktura decku (ID, nazwa lub zestawy).", deckObj); return null;
    }

    const gotowyDeck = {
        id: deckObj.id.trim(),
        name: String(deckObj.name || `${defaultNamePrefix}_${Date.now() % 10000}`).trim(),
        timestamp: parseInt(deckObj.timestamp, 10) || Date.now(),
        lastModified: parseInt(deckObj.lastModified, 10) || (parseInt(deckObj.timestamp, 10) || Date.now()),
        sets: []
    };

    const parseFloatOrZero = (val) => { const num = parseFloat(val); return isNaN(num) ? 0 : num; };
    const parseIntOrZero = (val) => { const num = parseInt(val, 10); return isNaN(num) ? 0 : num; };

    deckObj.sets.forEach((set) => {
        if (!set || typeof set.seria !== 'string' || !['bx_ux', 'cx'].includes(set.seria)) { 
            console.warn(`[VALIDATE_DECK_WARN_SET] Nieprawidłowy lub brak serii w zestawie decku ID: ${gotowyDeck.id}. Pomijam zestaw.`); 
            return; 
        }
        
        const przygotowanyZestaw = { 
            seria: set.seria,
            bladeId: set.bladeId === undefined ? null : String(set.bladeId || '').trim() || null,
            ratchetId: set.ratchetId === undefined ? null : String(set.ratchetId || '').trim() || null,
            bitId: set.bitId === undefined ? null : String(set.bitId || '').trim() || null,
            cx_lock_chipId: set.cx_lock_chipId === undefined ? null : String(set.cx_lock_chipId || '').trim() || null,
            cx_main_bladeId: set.cx_main_bladeId === undefined ? null : String(set.cx_main_bladeId || '').trim() || null,
            cx_assist_bladeId: set.cx_assist_bladeId === undefined ? null : String(set.cx_assist_bladeId || '').trim() || null,
            statystykiObliczone: {}
        };
        
        if (set.seria === 'bx_ux') {
            przygotowanyZestaw.cx_lock_chipId = null;
            przygotowanyZestaw.cx_main_bladeId = null;
            przygotowanyZestaw.cx_assist_bladeId = null;
        } else if (set.seria === 'cx') {
            przygotowanyZestaw.bladeId = null; 
        }

        if (set.statystykiObliczone && typeof set.statystykiObliczone === 'object') {
            const stats = set.statystykiObliczone;
            przygotowanyZestaw.statystykiObliczone = { 
                ATK: parseFloatOrZero(stats.ATK), DEF: parseFloatOrZero(stats.DEF), STM: parseFloatOrZero(stats.STM), 
                WAGA: parseFloatOrZero(stats.WAGA || stats.waga), DASH: parseFloatOrZero(stats.DASH), 
                B_RES: parseFloatOrZero(stats.B_RES || stats.BURST_RES), CX_LC_WYTRZ: parseIntOrZero(stats.CX_LC_WYTRZ) 
            };
        }
        gotowyDeck.sets.push(przygotowanyZestaw);
    });

    if (deckObj.sets.length > 0 && gotowyDeck.sets.length === 0) { 
        console.warn(`[VALIDATE_DECK_WARN_NO_VALID_SETS] Deck ID: ${gotowyDeck.id} nie zawierał poprawnych zestawów. Odrzucam.`); 
        return null; 
    }
    
    console.log(`[VALIDATE_DECK_SUCCESS] Deck ID: ${gotowyDeck.id} zwalidowany z ${gotowyDeck.sets.length} zestawami.`);
    return gotowyDeck;
}

function importujDeckiZPolaTekstowego() {
    console.log("[IMPORT_DECK_FIELD_1] Rozpoczęto import decków z pola tekstowego.");
    const poleTekstoweDecki = document.getElementById('poleDanychJsonDecki');
    if (!poleTekstoweDecki || !poleTekstoweDecki.value.trim()) {
        showNotification('Pole danych decków jest puste.', 3000, 'warning'); return;
    }
    let daneSuroweZInputu;
    try { daneSuroweZInputu = JSON.parse(poleTekstoweDecki.value); } 
    catch (e) { showNotification('Błąd importu: Nieprawidłowy JSON w danych decków.', 3000, 'error'); console.error("Błąd parsowania JSON (decki z pola):", e); return; }

    let deckiDoSprawdzenia;
    if (daneSuroweZInputu && typeof daneSuroweZInputu === 'object' && !Array.isArray(daneSuroweZInputu)) {
        deckiDoSprawdzenia = [daneSuroweZInputu];
    } else if (Array.isArray(daneSuroweZInputu)) {
        deckiDoSprawdzenia = daneSuroweZInputu;
    } else {
        showNotification('Błąd importu: Dane muszą być listą decków lub pojedynczym obiektem decku.', 3000, 'error'); return;
    }
    
    const istniejaceDecki = getSavedDecks();
    let nowoDodaneDecki = []; let pominieteDuplikatyCount = 0; let bledneFormatyCount = 0;

    deckiDoSprawdzenia.forEach((potencjalnyDeck, index) => {
        const zwalidowanyDeck = walidujIPrzygotujPojedynczyDeckDoDodania(potencjalnyDeck, `Import z pola #${index + 1}`);
        if (zwalidowanyDeck) {
            const indexIstniejacego = istniejaceDecki.findIndex(d => d.id === zwalidowanyDeck.id);
            if (indexIstniejacego > -1) {
                pominieteDuplikatyCount++; 
                console.warn(`[IMPORT_DECK_FIELD_WARN_DUPLICATE] Deck ID '${zwalidowanyDeck.id}' ("${zwalidowanyDeck.name}") już istnieje. Pomijam.`);
            } else {
                istniejaceDecki.push(zwalidowanyDeck);
                nowoDodaneDecki.push(zwalidowanyDeck);
            }
        } else {
            bledneFormatyCount++;
        }
    });

    setSavedDecks(istniejaceDecki); 

    let komunikatKoncowy = "";
    if (nowoDodaneDecki.length > 0) komunikatKoncowy += `Dodano ${nowoDodaneDecki.length} nowych deck(ów). `;
    if (pominieteDuplikatyCount > 0) komunikatKoncowy += `${pominieteDuplikatyCount} deck(ów) pominięto (duplikaty ID). `;
    if (bledneFormatyCount > 0) komunikatKoncowy += `Pominięto ${bledneFormatyCount} nieprawidłowych decków. `;

    if (komunikatKoncowy.trim() === "" && deckiDoSprawdzenia.length > 0) {
        showNotification('Żadne nowe decki nie zostały dodane (mogą być duplikatami lub błędami formatu).', 3000, 'info');
    } else if (komunikatKoncowy.trim() === "" && deckiDoSprawdzenia.length === 0) {
        showNotification('Pole nie zawierało danych decków do importu.', 3000, 'info');
    } else {
        showNotification(`Import decków zakończony! ${komunikatKoncowy.trim()}`, 4500, 'success');
    }

    if (nowoDodaneDecki.length > 0 && poleTekstoweDecki) poleTekstoweDecki.value = ''; 
    
    if (document.getElementById('galeriaDeckow')?.classList.contains('active')) {
        displaySavedDecks();
    }
    console.log(`[IMPORT_DECK_FIELD_5] Zakończono import decków. Dodano: ${nowoDodaneDecki.length}, Duplikaty: ${pominieteDuplikatyCount}, Błędne: ${bledneFormatyCount}`);
}

// =================================
// Czyszczenie Danych i Inicjalizacja
// =================================
function wykonajWyczyszczenieDanych() {
    console.log("Rozpoczynanie pełnego czyszczenia danych aplikacji...");

    // Czyszczenie localStorage
    localStorage.removeItem(MAGAZYN_KEY);
    localStorage.removeItem(SAVED_DECKS_KEY);
    localStorage.removeItem(SCORES_KEY);
    localStorage.removeItem(DOMYSLNA_BAZA_ZALADOWANA_KEY); // Upewnij się, że ta flaga też jest usuwana

    console.log("Klucze localStorage usunięte.");

    // Resetowanie zmiennych globalnych przechowujących stan
    // Magazyn (jeśli jest jakaś zmienna globalna oprócz localStorage)
    // Jeśli np. masz globalną zmienną `let aktualnyMagazynGlobalny = []`, zresetuj ją:
    // aktualnyMagazynGlobalny = []; // Przykład

    // Zapisane Decki (jeśli jest zmienna globalna)
    // np. ostatnioWylosowaneZestawyGlobalnie już jest resetowane w wyczyscLosowanie

    // Wyniki licznika punktów
    scores = { player1: 0, player2: 0 };
    playerNames = { player1: "Gracz 1", player2: "Gracz 2" };
    // Wyczyść ewentualne timeouty związane z licznikiem (masz to już dla fullscreenOverlayHideTimeout)
    if (imageHideTimeouts.player1) clearTimeout(imageHideTimeouts.player1);
    if (imageHideTimeouts.player2) clearTimeout(imageHideTimeouts.player2);
    imageHideTimeouts = { player1: null, player2: null };
    if (fullscreenOverlayHideTimeout) {
        clearTimeout(fullscreenOverlayHideTimeout);
        fullscreenOverlayHideTimeout = null;
    }
    console.log("Zmienne globalne wyników zresetowane.");

    // Stan Deck Buildera
    initializeOrResetCurrentDeck(); // To powinno resetować currentDeckBeingBuilt do pustego stanu
    currentEditingDeckId = null;
    currentlyActiveSetIndexInBuilder = 0;
    const deckNameInput = document.getElementById('deckName');
    if (deckNameInput) deckNameInput.value = "";
    const saveBtn = document.getElementById('saveDeckButton');
    if (saveBtn) saveBtn.textContent = 'Zapisz Aktualny Deck';
    console.log("Stan Deck Buildera zresetowany.");


    // Stan Generatora Losowych Zestawów
    ostatnioWylosowaneZestawyGlobalnie = [];
    if (wynikiDivGenerator) wynikiDivGenerator.innerHTML = '';
    if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
    const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
    if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'none';
    const nazwaDeckuInputGenerator = document.getElementById('nazwa-glownego-decku');
    if (nazwaDeckuInputGenerator) nazwaDeckuInputGenerator.value = "";
    console.log("Stan Generatora Losowych Zestawów zresetowany.");

    // Czyszczenie pól tekstowych na stronie Import/Eksport (jeśli jest aktywna)
    // Robimy to tutaj, bo odświeżenie widoku może nie nastąpić od razu,
    // a chcemy, żeby użytkownik widział, że pola są czyste.
    const poleJsonMagazyn = document.getElementById('poleDanychJsonMagazyn');
    const poleJsonDecki = document.getElementById('poleDanychJsonDecki');
    if (poleJsonMagazyn) poleJsonMagazyn.value = '';
    if (poleJsonDecki) poleJsonDecki.value = '';
    console.log("Pola tekstowe Import/Eksport wyczyszczone.");


    // Ukryj pełnoekranową nakładkę licznika, jeśli była widoczna
    const overlayElement = document.getElementById('fullscreenFinishOverlay');
    const imageElement = document.getElementById('fullscreenFinishImage');
    if (overlayElement && imageElement && overlayElement.classList.contains('visible')) {
        overlayElement.classList.remove('visible');
        // Opóźnione czyszczenie src, aby uniknąć mignięcia, jeśli przejście trwa
        setTimeout(() => {
            if (!overlayElement.classList.contains('visible')) { // Sprawdź ponownie na wszelki wypadek
                imageElement.src = '#';
            }
        }, 300); // Dopasuj do czasu przejścia opacity
        console.log("Nakładka licznika ukryta.");
    }


    console.log("Pełne czyszczenie danych aplikacji (zmiennych i UI powiązanych) zakończone.");
    // UWAGA: Ta funkcja NIE powinna odświeżać całych widoków (jak wyswietlMagazyn),
    // to zadanie dla funkcji nadrzędnej po załadowaniu nowej bazy.
    // Powinna jednak resetować stan UI, który jest bezpośrednio powiązany ze zmiennymi globalnymi,
    // np. wyświetlacze wyników, inputy.
}

function wykonajPelnyResetAplikacji() {
    console.log("Rozpoczynanie pełnego resetu aplikacji...");

    // Krok 1: Wykonaj czyszczenie wszystkich danych
    wykonajWyczyszczenieDanych(); // Upewnij się, że ta funkcja jest teraz kompletna

    console.log("Pełne czyszczenie danych aplikacji (localStorage i zmienne globalne) zakończone.");

    // Krok 2: Załaduj domyślną bazę danych
    console.log("Próba załadowania domyślnej bazy danych po resecie...");
    let czyBazaZaladowanaPoprawnieLubNieWymagalaZmian = false;
    try {
        // Wywołujemy z trybemCichy=false, aby użytkownik widział ewentualne komunikaty z importu.
        // `ustawDomyslnaIloscDlaNowychNaZero = true` jest przekazywane wewnątrz importujMagazynZBazyDomyslnejHTML
        // do przetworzIDopiszDaneMagazynu.
        const importWynik = importujMagazynZBazyDomyslnejHTML(false); // false = nie tryb cichy

        // importWynik to true, jeśli były zmiany; false, jeśli nie było zmian lub błąd w danych importu.
        // Dla resetu uznajemy za sukces, jeśli sama funkcja importu nie rzuciła krytycznego błędu.
        czyBazaZaladowanaPoprawnieLubNieWymagalaZmian = true; 

        if (importWynik) {
            console.log("Domyślna baza danych załadowana i dokonano zmian w magazynie.");
        } else {
            console.log("Próba załadowania domyślnej bazy danych nie wprowadziła nowych zmian (magazyn mógł być już zgodny lub pusty po czyszczeniu, lub dane bazy były niepoprawne i przetworz... zwróciło false).");
        }
        localStorage.setItem(DOMYSLNA_BAZA_ZALADOWANA_KEY, 'true'); // Ustaw flagę po udanej próbie
        showNotification("Aplikacja została zresetowana. Domyślna baza części załadowana (lub podjęto próbę).", 4000, 'success');

    } catch (error) { // Ten catch łapie błędy rzucone przez importujMagazynZBazyDomyslnejHTML (np. brak skryptu)
        console.error("Krytyczny błąd podczas próby ładowania domyślnej bazy danych po resecie:", error);
        showNotification("Dane zostały wyczyszczone, ale wystąpił KRYTYCZNY błąd podczas ładowania domyślnej bazy części. Sprawdź konsolę.", 6000, 'error');
        // Flaga DOMYSLNA_BAZA_ZALADOWANA_KEY nie jest ustawiana, co jest poprawne.
    }

    console.log("Proces ładowania domyślnej bazy zakończony.");

    // Krok 3: Odśwież widoki, które mogły być aktywne, aby odzwierciedliły nowy, czysty stan
    // oraz ewentualnie nowo załadowaną bazę.
    console.log("Odświeżanie aktywnych widoków po resecie...");
    const aktywnaStronaId = document.querySelector('.page.active')?.id;
    if (aktywnaStronaId) {
        console.log(`Aktywna strona to: ${aktywnaStronaId}. Odświeżam...`);
        if (aktywnaStronaId === 'magazyn') wyswietlMagazyn();
        else if (aktywnaStronaId === 'generator') {
             // wyczyscLosowanie jest już częścią wykonajWyczyszczenieDanych,
             // ale można tu upewnić się, że UI jest czyste
            if (wynikiDivGenerator) wynikiDivGenerator.innerHTML = '';
            if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        } else if (aktywnaStronaId === 'deck') {
            // clearCurrentDeckForBuilder jest już w wykonajWyczyszczenieDanych,
            // ale renderDeckBuilderAndParts odświeży listę dostępnych części z nowej bazy.
            renderDeckBuilderAndParts();
        } else if (aktywnaStronaId === 'galeriaDeckow') displaySavedDecks();
        else if (aktywnaStronaId === 'licznikPunktow') {
            if (typeof displayScores === 'function') displayScores();
            if (typeof displayPlayerNames === 'function') displayPlayerNames();
        }
        // Strona 'importexport' powinna mieć już wyczyszczone pola przez wykonajWyczyszczenieDanych.
    } else {
        console.log("Brak aktywnej strony do odświeżenia.");
    }
    console.log("Pełny reset aplikacji zakończony.");
}
   
// Używamy 'load' zamiast 'DOMContentLoaded', ponieważ 'load' czeka na wszystkie zasoby,
// w tym obrazki i arkusze stylów, co jest idealne dla naszej logiki.
window.addEventListener('load', function() {
    console.log("Wydarzenie 'load': Strona i wszystkie zasoby (w tym obrazki) załadowane.");

    // Znajdź kluczowe elementy DOM do odsłonięcia
    const loaderOverlay = document.getElementById('loader-overlay');
    const localAppContainer = document.getElementById('app-container');
    const localSidebar = document.getElementById('sidebar');

    // === Odsłonięcie strony ===
    if (loaderOverlay) {
        loaderOverlay.classList.add('hidden');
        // Po zakończeniu animacji usuń go z DOM, aby nie przeszkadzał
        setTimeout(() => {
            loaderOverlay.remove();
        }, 800); // Czas musi być nieco dłuższy niż transition w CSS
    }

    // Pokaż płynnie główną zawartość aplikacji
    if (localAppContainer && localSidebar) {
        localAppContainer.classList.add('loaded');
        localSidebar.classList.add('loaded');
    }

    // === POPRAWKA: Inicjalizujemy zmienne globalne, a nie tworzymy nowych ===
    // Usuwamy 'const' i 'let' z tych linii, aby przypisać wartość do zmiennych zdefiniowanych na górze skryptu
    sidebar = document.getElementById('sidebar');
    appContainer = document.getElementById('app-container');
    sidebarToggleBtn = document.getElementById('sidebarToggleBtn');
    menuIcon = document.getElementById('menu-icon');
    menuBtnText = document.getElementById('menu-btn-text');
    wynikiDivGenerator = document.getElementById('wyniki');
    placeholderActualImgGenerator = document.getElementById('placeholder-img');
    // === KONIEC POPRAWKI ===

    // Inicjalizacja danych aplikacji
    initializeOrResetCurrentDeck();

    // ---- AUTOMATYCZNA SYNCHRONIZACJA BAZY DANYCH ----
    try {
        console.log("Rozpoczynanie automatycznej synchronizacji magazynu z domyślną bazą...");
        const czyCosSieZmienilo = importujMagazynZBazyDomyslnejHTML(true);
        if (czyCosSieZmienilo) {
            console.log("Magazyn został zsynchronizowany z domyślną bazą.");
        } else {
            console.log("Magazyn jest aktualny względem domyślnej bazy.");
        }
    } catch (e) {
        console.error("Błąd podczas automatycznej synchronizacji magazynu:", e);
        showNotification("Wystąpił błąd przy aktualizacji bazy części.", 3000, 'error');
    }

    // ---- INICJALIZACJA TŁA VANTA ----
    if (typeof VANTA !== 'undefined' && VANTA.NET && typeof THREE !== 'undefined') {
        const vantaContainer = document.getElementById('vanta-background');
        if (vantaContainer) {
            try {
                window.vantaEffect = VANTA.NET({
                    el: "#vanta-background",
                    mouseControls: true,
                    touchControls: true,
                    gyroControls: false,
                    minHeight: 200.00,
                    minWidth: 200.00,
                    scale: 1.00,
                    scaleMobile: 1.00,
                    backgroundColor: 0x101018,
                    color: 0x8a2be2,
                    points: 11.00,
                    maxDistance: 20.00,
                    spacing: 16.00,
                    showDots: true
                });
                console.log("Vanta.NET zainicjalizowana pomyślnie.");
            } catch (e) {
                console.error("Błąd podczas inicjalizacji VANTA:", e);
                showNotification("Nie udało się załadować animowanego tła.", 3000, 'warning');
            }
        }
    }

    // Ustawienie marginesu kontenera aplikacji (teraz `appContainer` jest zdefiniowany)
    if (appContainer) {
        appContainer.style.marginLeft = sidebarWidthCollapsed + 'px';
    }

    // Domyślna nawigacja (teraz `navigateTo` ma dostęp do poprawnych zmiennych)
    const domyslnyLink = document.querySelector('.sidebar a[onclick*="navigateTo(\'info"]');
    if (domyslnyLink) {
        navigateTo('info', domyslnyLink);
    } else {
        console.error("Brak linku nawigacyjnego do strony 'Info'.");
        navigateTo('info', null);
    }

    // Listener dla przycisku sidebar (teraz `toggleSidebar` ma dostęp do poprawnych zmiennych)
    if (sidebarToggleBtn) {
        sidebarToggleBtn.addEventListener('click', toggleSidebar);
    }
});


</script>

<!-- Domyślna Baza Danych JSON -->
</script>
<script id="domyslnaBazaDanychJson" type="application/json">
[
  {
  "id": "1", "typ": "ux-blade","kierunek": "prawy", "nazwa": "AeroPegasus", "ilosc": 0, "img":"img/BladeAeroPegasus.webp", "ATK": 70, "DEF": 30, "STM": 35, "waga": 38.3},
  {
  "id": "2", "typ": "ux-blade","kierunek": "prawy", "nazwa": "DranBuster", "ilosc": 0, "img": "img/BladeDranBuster.webp", "ATK": 70, "DEF": 20, "STM": 10, "waga": 36.5},
  {
  "id": "3", "typ": "ux-blade","kierunek": "prawy", "nazwa": "GhostCircle", "ilosc": 0, "img": "img/BladeGhostCircle.webp", "ATK": 5, "DEF": 40, "STM": 55, "waga": 26.7},
  {
  "id": "4", "typ": "ux-blade","kierunek": "prawy", "nazwa": "GolemRock", "ilosc": 0, "img": "img/BladeGolemRock.webp", "ATK": 30, "DEF": 60, "STM": 10, "waga": 34},
  {
  "id": "5", "typ": "ux-blade","kierunek": "prawy", "nazwa": "HellsHammer", "ilosc": 0, "img": "img/BladeHellsHammer.webp", "ATK": 50, "DEF": 25, "STM": 25, "waga": 33},
  {
  "id": "6", "typ": "ux-blade","kierunek": "prawy", "nazwa": "ImpactDrake", "ilosc": 0, "img": "img/BladeImpactDrake.webp", "ATK": 75, "DEF": 25, "STM":10, "waga": 39},
  {
  "id": "7", "typ": "ux-blade","kierunek": "prawy", "nazwa": "KnightMail", "ilosc": 0, "img": "img/BladeKnightMail.webp", "ATK": 10, "DEF": 65, "STM": 35, "waga": 36.7},
  {
  "id": "8", "typ": "ux-blade","kierunek": "prawy", "nazwa": "LeonCrest", "ilosc": 0, "img": "img/BladeLeonCrest.webp", "ATK": 15, "DEF": 70, "STM": 15, "waga": 35},
  {
  "id": "9", "typ": "ux-blade","kierunek": "prawy", "nazwa": "PhoenixRudder", "ilosc": 0, "img": "img/BladePhoenixRudder.webp", "ATK": 10, "DEF": 35, "STM": 55, "waga": 34.5},
  {
  "id": "10", "typ": "ux-blade","kierunek": "prawy", "nazwa": "SamuraiSaber", "ilosc": 0, "img": "img/BladeSamuraiSaber.webp", "ATK": 65, "DEF": 20, "STM": 25, "waga": 36.5},
  {
  "id": "11", "typ": "ux-blade","kierunek": "prawy", "nazwa": "ScorpioSpear", "ilosc": 0, "img": "img/BladeScorpioSpear.webp", "ATK": 25, "DEF": 55, "STM": 30, "waga": 39.6},
  {
  "id": "12", "typ": "ux-blade","kierunek": "prawy", "nazwa": "SharkScale", "ilosc": 0, "img": "img/BladeSharkScale.webp", "ATK": 70, "DEF": 15, "STM": 15, "waga": 37.6},
  {
  "id": "13", "typ": "ux-blade","kierunek": "prawy", "nazwa": "ShinobiShadow", "ilosc": 0, "img": "img/BladeShinobiShadow.webp", "ATK": 10, "DEF": 70, "STM": 20, "waga": 28.2},
  {
  "id": "14", "typ": "ux-blade","kierunek": "prawy", "nazwa": "SilverWolf", "ilosc": 0, "img": "img/BladeSilverWolf.webp", "ATK": 15, "DEF": 30, "STM": 65, "waga": 36.8},
  {
  "id": "15", "typ": "ux-blade","kierunek": "prawy", "nazwa": "WizardRod", "ilosc": 0, "img": "img/BladeWizardRod.webp", "ATK": 15, "DEF": 25, "STM": 60, "waga": 35.3},
  {
  "id": "16", "typ": "ux-blade","kierunek": "prawy", "nazwa": "WyvernHover", "ilosc": 0, "img": "img/BladeWyvernHover.webp", "ATK": 13, "DEF": 60, "STM": 27, "waga": 35},
  {
  "id": "17", "typ": "blade","kierunek": "prawy", "nazwa": "BlackShell", "ilosc": 0, "img": "img/BladeBlackShell.webp", "ATK": 10, "DEF": 65, "STM": 25, "waga": 32.4},
  {
  "id": "18", "typ": "blade","kierunek": "lewy", "nazwa": "CobaltDragoon", "ilosc": 0, "img": "img/BladeCobaltDragoon.webp", "ATK": 60, "DEF":15, "STM": 25, "waga": 37.8},
  {
  "id": "19", "typ": "blade","kierunek": "prawy", "nazwa": "CobaltDrake", "ilosc": 0, "img": "img/BladeCobaltDrake.webp", "ATK": 65, "DEF": 30, "STM": 20, "waga": 37.3},
  {
  "id": "20", "typ": "blade","kierunek": "prawy", "nazwa": "CrimsonGaruda", "ilosc": 0, "img": "img/BladeCrimsonGaruda.webp", "ATK": 45, "DEF": 25, "STM": 30, "waga": 35},
  {
  "id": "21", "typ": "blade","kierunek": "prawy", "nazwa": "DranDagger", "ilosc": 0, "img": "img/BladeDranDagger.webp", "ATK": 50, "DEF": 25, "STM": 25, "waga": 36},
  {
  "id": "22", "typ": "blade","kierunek": "prawy", "nazwa": "DranSword", "ilosc": 0, "img": "img/BladeDranSword.webp", "ATK": 55, "DEF": 25, "STM": 20, "waga": 35.1},
  {
  "id": "23", "typ": "blade","kierunek": "prawy", "nazwa": "HellsChain", "ilosc": 0, "img": "img/BladeHellsChain.webp", "ATK": 35, "DEF": 40, "STM": 25, "waga": 32.2},
  {
  "id": "24", "typ": "blade","kierunek": "prawy", "nazwa": "HellsScythe", "ilosc": 0, "img": "img/BladeHellsScythe.webp", "ATK": 30, "DEF": 35, "STM": 35, "waga": 33},
  {
  "id": "25", "typ": "blade","kierunek": "prawy", "nazwa": "KnightLance", "ilosc": 0, "img": "img/BladeKnightLance.webp", "ATK": 25, "DEF": 60, "STM": 15, "waga": 32.9},
  {
  "id": "26", "typ": "blade","kierunek": "prawy", "nazwa": "KnightShield", "ilosc": 0, "img": "img/BladeKnightShield.webp", "ATK": 20, "DEF": 55, "STM": 25, "waga": 34.8},
  {
  "id": "27", "typ": "blade","kierunek": "prawy", "nazwa": "LeonClaw", "ilosc": 0, "img": "img/BladeLeonClaw.webp", "ATK": 40, "DEF": 40, "STM": 20, "waga": 31.4},
  {
  "id": "28", "typ": "blade","kierunek": "prawy", "nazwa": "PhoenixFeather", "ilosc": 0, "img": "img/BladePhoenixFeather.webp", "ATK": 50, "DEF": 20, "STM": 30, "waga": 33.3},
  {
  "id": "29", "typ": "blade","kierunek": "prawy", "nazwa": "PhoenixWing", "ilosc": 0, "img": "img/BladePhoenixWing.webp", "ATK": 60, "DEF": 25, "STM": 15, "waga": 39},
  {
  "id": "30", "typ": "blade","kierunek": "prawy", "nazwa": "RhinoHorn", "ilosc": 0, "img": "img/BladeRhinoHorn.webp", "ATK": 20, "DEF": 50, "STM": 30, "waga": 32.7},
  {
  "id": "31", "typ": "blade","kierunek": "prawy", "nazwa": "SamuraiCalibur", "ilosc": 0, "img": "img/BladeSamuraiCalibur.webp", "ATK": 40, "DEF": 30, "STM": 30, "waga":36},
  {
  "id": "32", "typ": "blade","kierunek": "prawy", "nazwa": "SharkEdge", "ilosc": 0, "img": "img/BladeSharkEdge.webp", "ATK": 60, "DEF": 25, "STM": 15, "waga": 34.5},
  {
  "id": "33", "typ": "blade","kierunek": "prawy", "nazwa": "ShelterDrake", "ilosc": 0, "img": "img/BladeShelterDrake.webp", "ATK": 25, "DEF": 40, "STM": 35, "waga": 32.6},
  {
  "id": "34", "typ": "blade","kierunek": "prawy", "nazwa": "SphinxCowl", "ilosc": 0, "img": "img/BladeSphinxCowl.webp", "ATK": 35, "DEF": 55, "STM": 10, "waga": 32.7},
  {
  "id": "35", "typ": "blade","kierunek": "prawy", "nazwa": "TriceraPress", "ilosc": 0, "img": "img/BladeTriceraPress.webp", "ATK":20, "DEF": 65, "STM": 15, "waga": 36.5},
  {
  "id": "36", "typ": "blade","kierunek": "prawy", "nazwa": "TyrannoBeat", "ilosc": 0, "img": "img/BladeTyrannoBeat.webp", "ATK": 65, "DEF": 30, "STM": 5, "waga":37},
  {
  "id": "37", "typ": "blade","kierunek": "prawy", "nazwa": "UnicornSting", "ilosc": 0, "img": "img/BladeUnicornSting.webp", "ATK": 35, "DEF": 35, "STM": 30, "waga": 34},
  {
  "id": "38", "typ": "blade","kierunek": "prawy", "nazwa": "ViperTail", "ilosc": 0, "img": "img/BladeViperTail.webp", "ATK": 30, "DEF": 20, "STM": 50, "waga": 34.7},
  {
  "id": "39", "typ": "blade","kierunek": "prawy", "nazwa": "WeissTiger", "ilosc": 0, "img": "img/BladeWeissTiger.webp", "ATK": 45, "DEF": 30, "STM": 25, "waga": 34.6},
  {
  "id": "40", "typ": "blade","kierunek": "prawy", "nazwa": "WhaleWave", "ilosc": 0, "img": "img/BladeWhaleWave.webp", "ATK": 45, "DEF": 35, "STM": 20, "waga": 38.2},
  {
  "id": "41", "typ": "blade","kierunek": "prawy", "nazwa": "WizardArrow", "ilosc": 0, "img": "img/BladeWizardArrow.webp", "ATK": 15, "DEF": 30, "STM": 55, "waga": 31.8},
  {
  "id": "42", "typ": "blade","kierunek": "prawy", "nazwa": "WyvernGale", "ilosc": 0, "img": "img/BladeWyvernGale.webp", "ATK": 10, "DEF": 40, "STM": 50, "waga": 31.9},
  {
  "id": "43", "typ": "blade","kierunek": "prawy",
    "nazwa": "Bite Croc",
    "ilosc": 1,
    "img": "img/BladeBite-Croc.webp",
    "ATK": 60,
    "DEF": 22,
    "STM": 18,
    "waga": 34.1
  },
{
  "id": "44", "typ": "blade","kierunek": "prawy", "nazwa": "GillShark", "ilosc": 0, "img": "img/BladeGill-Shark.webp", "ATK": 20, "DEF": 25, "STM": 55, "waga": 29.6},
  {
  "id": "45", "typ": "blade","kierunek": "prawy", "nazwa": "ShinobiKnife", "ilosc": 0, "img": "img/BladeKnifeShinobi.webp", "ATK": 23, "DEF": 50, "STM": 27, "waga": 30.9},
  {
  "id": "46", "typ": "blade","kierunek": "prawy", "nazwa": "TriceraSpiky", "ilosc": 0, "img": "img/BladeTriceraSpiky.webp", "ATK": 32, "DEF": 55, "STM": 13, "waga": 29.9},
  {
  "id": "47", "typ": "blade","kierunek": "prawy", "nazwa": "TyrannoRoar", "ilosc": 0, "img": "img/BladeRoar-Tyranno.webp", "ATK": 60, "DEF": 28, "STM": 12, "waga": 36},
  {
  "id": "48", "typ": "blade","kierunek": "prawy", "nazwa": "BearScratch", "ilosc": 0, "img": "img/BladeSavage-Bear.webp", "ATK": 25, "DEF": 45, "STM": 30, "waga": 29.6},
  {
  "id": "49", "typ": "blade","kierunek": "prawy", "nazwa": "SamuraiSteel", "ilosc": 0, "img": "img/BladeSteel-Samurai.webp", "ATK": 40, "DEF": 37, "STM": 23, "waga": 31.2},
  {
  "id": "50", "typ": "blade","kierunek": "prawy", "nazwa": "GoatTackle", "ilosc": 0, "img": "img/BladeTackle-Goat.webp", "ATK": 13, "DEF": 65, "STM": 22, "waga": 31.5},
  {
  "id": "51", "typ": "blade","kierunek": "prawy", "nazwa": "PteraSwing", "ilosc": 0, "img": "img/BladeTalon-Ptera.webp", "ATK": 27, "DEF": 23, "STM": 50, "waga": 34.4},
  {
  "id": "52", "typ": "blade","kierunek": "prawy", "nazwa": "MammothTusk", "ilosc": 0, "img": "img/BladeTusk-Mammoth.webp", "ATK": 33, "DEF": 35, "STM": 32, "waga": 32},
  {
  "id": "53", "typ": "blade","kierunek": "prawy", "nazwa": "KongYell", "ilosc": 0, "img": "img/BladeYell-Kong.webp", "ATK": 13, "DEF": 37, "STM": 50, "waga": 31.1},
  {
  "id": "54", "typ": "blade","kierunek": "lewy", "nazwa": "DragoonStorm", "ilosc": 0, "img": "img/BladeDragoon-Storm.webp", "ATK": 55, "DEF": 30, "STM": 15, "waga": 25.1},
  {
  "id": "55", "typ": "blade","kierunek": "prawy", "nazwa": "DranzerSpiral", "ilosc": 0, "img": "img/BladeDranzerSpiral.webp", "ATK": 35, "DEF": 30, "STM": 35, "waga": 27.7},
  {
  "id": "56", "typ": "blade","kierunek": "prawy", "nazwa": "DrigerSlash", "ilosc": 0, "img": "img/BladeDrigerSlash.webp", "ATK": 40, "DEF": 35, "STM": 25, "waga": 28.6},
  {
  "id": "57", "typ": "blade","kierunek": "prawy", "nazwa": "DracielShield", "ilosc": 0, "img": "img/BladeDracielShield.webp", "ATK": 30, "DEF": 50, "STM": 20, "waga": 28},
  {
  "id": "58", "typ": "blade","kierunek": "lewy", "nazwa": "Lightning L-Drago (Rapid-Hit Type)", "ilosc": 0, "img": "img/BladeLightningL_(Rapid-Hit_Type).webp", "ATK": 50, "DEF": 30, "STM": 20, "waga": 33.5},
  {
  "id": "59", "typ": "blade","kierunek": "lewy", "nazwa": "Lightning L-Drago (Upper Type)", "ilosc": 0, "img": "img/BladeLightningL_(Upper_Type).webp", "ATK": 55, "DEF": 25, "STM": 20, "waga": 34},
  {
  "id": "60", "typ": "blade","kierunek": "prawy", "nazwa": "Rock Leone", "ilosc": 0, "img": "img/BladeRockLeone.webp", "ATK": 30, "DEF": 55, "STM": 15, "waga": 29.8},
  {
  "id": "61", "typ": "blade","kierunek": "prawy", "nazwa": "StormPegasis", "ilosc": 0, "img": "img/BladeStorm-Pegasis.webp", "ATK": 55, "DEF": 15, "STM": 30, "waga": 31},
  {
  "id": "62", "typ": "blade","kierunek": "prawy", "nazwa": "Trypio", "ilosc": 0, "img": "img/Trypio_3-60N.webp", "ATK": 0, "DEF": 0, "STM": 0, "waga": 0},
  {
  "id": "63", "typ": "blade","kierunek": "prawy", "nazwa": "VictoryValkyrie", "ilosc": 0, "img": "img/BladeVictory-Valkyrie.webp", "ATK": 55, "DEF": 20, "STM": 25, "waga": 33.2},
  {
  "id": "64", "typ": "blade","kierunek": "prawy", "nazwa": "XenoXcalibur", "ilosc": 0, "img": "img/BladeXenoXcalibur.webp", "ATK": 65, "DEF": 25, "STM": 10, "waga": 31},
   {
  "id": "64", "typ": "blade","kierunek": "prawy", "nazwa": "Quetzalcoatlus", "ilosc": 0, "img": "img/BladeQuetzalcoatlus.webp", "ATK": 27, "DEF": 23, "STM": 50, "waga": 34.3},
   {
  "id": "65", "typ": "blade","kierunek": "prawy", "nazwa": "Spinosaurus", "ilosc": 0, "img": "img/BladeSpinosaurus.webp", "ATK": 60, "DEF": 28, "STM": 12, "waga": 36},
   {
  "id": "66", "typ": "blade","kierunek": "prawy", "nazwa": "T.Rex", "ilosc": 0, "img": "img/BladeT._Rex.webp", "ATK": 65, "DEF": 30, "STM": 5, "waga": 37},
   {
  "id": "67", "typ": "blade","kierunek": "prawy", "nazwa": "Captain America", "ilosc": 0, "img": "img/BladeCaptainAmerica.webp", "ATK": 55, "DEF": 28, "STM": 17, "waga": 32.3},
   {
  "id": "68", "typ": "blade","kierunek": "prawy", "nazwa": "Green Goblin", "ilosc": 0, "img": "img/BladeGreen_Goblin.webp", "ATK": 17, "DEF": 28, "STM": 55, "waga": 31.7},
   {
  "id": "69", "typ": "blade","kierunek": "prawy", "nazwa": "Iron Man", "ilosc": 0, "img": "img/BladeIron_Man.webp", "ATK": 17, "DEF": 55, "STM": 28, "waga": 33.6},
   {
  "id": "70", "typ": "blade","kierunek": "prawy", "nazwa": "Miles Morales", "ilosc": 0, "img": "img/BladeMiles_Morales.webp", "ATK": 12, "DEF": 33, "STM": 55, "waga": 31.7},
   {
  "id": "71", "typ": "blade","kierunek": "prawy", "nazwa": "Red Hulk", "ilosc": 0, "img": "img/BladeRed_Hulk.webp", "ATK": 65, "DEF": 27, "STM": 8, "waga": 36.3},
   {
  "id": "72", "typ": "blade","kierunek": "prawy", "nazwa": "Spider-Man", "ilosc": 0, "img": "img/BladeSpider-Man.webp", "ATK": 33, "DEF": 17, "STM": 50, "waga": 33.2},
   {
  "id": "73", "typ": "blade","kierunek": "prawy", "nazwa": "Thanos", "ilosc": 0, "img": "img/BladeThanos.webp", "ATK": 22, "DEF": 60, "STM": 18, "waga": 29.5},
   {
  "id": "74", "typ": "blade","kierunek": "prawy", "nazwa": "Venom", "ilosc": 0, "img": "img/BladeVenom.webp", "ATK": 55, "DEF": 22, "STM": 23, "waga": 34.3},
   {
  "id": "75", "typ": "blade","kierunek": "prawy", "nazwa": "Chewbacca", "ilosc": 0, "img": "img/BladeChewbacca.webp", "ATK": 22, "DEF": 23, "STM": 55, "waga": 31.8},
   {
  "id": "76", "typ": "blade","kierunek": "prawy", "nazwa": "Darth Vader", "ilosc": 0, "img": "img/BladeDarth_Vader.webp", "ATK": 28, "DEF": 60, "STM": 12, "waga": 30.7},
   {
  "id": "77", "typ": "blade","kierunek": "prawy", "nazwa": "General Grievous", "ilosc": 0, "img": "img/BladeGeneral_Grievous.webp", "ATK": 22, "DEF": 55, "STM": 28, "waga": 31},
   {
  "id": "78", "typ": "blade","kierunek": "prawy", "nazwa": "Luke Skywalker", "ilosc": 0, "img": "img/BladeLuke_Skywalker.webp", "ATK": 23, "DEF": 55, "STM": 22, "waga": 31.5},
   {
  "id": "79", "typ": "blade","kierunek": "prawy", "nazwa": "Moff Gideon", "ilosc": 0, "img": "img/BladeMoff_Gideon.webp", "ATK": 32, "DEF": 35, "STM": 33, "waga": 30.5},
   {
  "id": "80", "typ": "blade","kierunek": "prawy", "nazwa": "Obi-Wan Kenobi", "ilosc": 0, "img": "img/BladeObi-Wan_Kenobi.webp", "ATK": 23, "DEF": 60, "STM": 17, "waga": 30.6},
   {
  "id": "81", "typ": "blade","kierunek": "prawy", "nazwa": "Stormtrooper", "ilosc": 0, "img": "img/BladeStormtrooper.webp", "ATK": 18, "DEF": 50, "STM": 32, "waga": 33.6},
  {
  "id": "82", "typ": "blade","kierunek": "prawy", "nazwa": "Mandalorian", "ilosc": 0, "img": "img/BladeMandalorian.webp", "ATK": 30.3, "DEF": 40, "STM": 43, "waga": 17},
    {
  "id": "83", "typ": "blade","kierunek": "prawy", "nazwa": "Bumblebee", "ilosc": 0, "img": "img/BladeBumblebee.webp", "ATK": 21, "DEF": 55, "STM": 24, "waga": 34.8},
   {
  "id": "84", "typ": "blade","kierunek": "prawy", "nazwa": "Megatron", "ilosc": 0, "img": "img/BladeMegatron.webp", "ATK": 27, "DEF": 35, "STM": 38, "waga": 31.1},
 {
  "id": "85", "typ": "blade","kierunek": "prawy", "nazwa": "Optimus Primal", "ilosc": 0, "img": "img/BladeOptimus_Primal.webp", "ATK": 60, "DEF": 27, "STM": 13, "waga": 35.7},
     {
  "id": "86", "typ": "blade","kierunek": "prawy", "nazwa": "Optimus Prime", "ilosc": 0, "img": "img/BladeOptimus_Prime.webp", "ATK": 22, "DEF": 55, "STM": 23, "waga": 33.3},
   {
  "id": "87", "typ": "ublade","kierunek": "prawy", "nazwa": "Shockwave", "ilosc": 0, "img": "img/BladeShockwave.webp", "ATK": 32, "DEF": 18, "STM": 50, "waga": 34.7},
   {
  "id": "88", "typ": "blade","kierunek": "prawy", "nazwa": "Starscream", "ilosc": 0, "img": "img/BladeStarscream.webp", "ATK": 18, "DEF": 27, "STM": 55, "waga": 29.5},
  
  {
  "id": "96", "typ": "rachet", "nazwa": "1-70", "ilosc": 0, "img": "img/Ratchet1-70.webp", "ATK": 17, "DEF": 6, "STM": 7, "waga": 7.3},
  {
  "id": "97", "typ": "rachet", "nazwa": "2-60", "ilosc": 0, "img": "img/Ratchet2-60.webp", "ATK": 16, "DEF": 8, "STM": 6, "waga": 6.2},
  {
  "id": "98", "typ": "rachet", "nazwa": "2-80", "ilosc": 0, "img": "img/Ratchet2-80.webp", "ATK": 10, "DEF": 11, "STM": 9, "waga": 6.9},
  {
  "id": "99", "typ": "rachet", "nazwa": "3-60", "ilosc": 0, "img": "img/Ratchet3-60.webp", "ATK": 15, "DEF": 9, "STM": 6, "waga": 6.4},
  {
  "id": "100", "typ": "rachet", "nazwa": "3-80", "ilosc": 0, "img": "img/Ratchet3-80.webp", "ATK":15, "DEF": 7, "STM": 8, "waga": 7.1},
  {
  "id": "101", "typ": "rachet", "nazwa": "4-60", "ilosc": 0, "img": "img/Ratchet4-60.webp", "ATK": 11, "DEF": 13, "STM": 6, "waga": 6.3},
  {
  "id": "102", "typ": "rachet", "nazwa": "4-70", "ilosc": 0, "img": "img/Ratchet4-70.webp", "ATK": 11, "DEF": 12, "STM": 7, "waga": 6.4},
  {
  "id": "103", "typ": "rachet", "nazwa": "4-80", "ilosc": 0, "img": "img/Ratchet4-80.webp", "ATK": 11, "DEF": 11, "STM": 8, "waga": 7},
  {
  "id": "104", "typ": "rachet", "nazwa": "5-60", "ilosc": 0, "img": "img/Ratchet5-60.webp", "ATK": 12, "DEF": 9, "STM": 9, "waga": 6.6},
  {
  "id": "105", "typ": "rachet", "nazwa": "5-80", "ilosc": 0, "img": "img/Ratchet5-80.webp", "ATK": 12, "DEF": 8, "STM": 10, "waga": 7.3},
  {
  "id": "106", "typ": "rachet", "nazwa": "6-70", "ilosc": 0, "img": "img/Ratchet6-70.webp", "ATK": 14, "DEF": 7, "STM": 9, "waga": 7.3},
  {
  "id": "107", "typ": "rachet", "nazwa": "7-80", "ilosc": 0, "img": "img/Ratchet7-80.webp", "ATK": 7, "DEF": 14, "STM": 9, "waga": 7.8},
  {
  "id": "108", "typ": "rachet", "nazwa": "9-60", "ilosc": 0, "img": "img/Ratchet9-60.webp", "ATK": 13, "DEF": 10, "STM": 7, "waga": 6.2},
  {
  "id": "109", "typ": "rachet", "nazwa": "9-80", "ilosc": 0, "img": "img/Ratchet9-80.webp", "ATK": 13, "DEF": 10, "STM": 7, "waga": 6.9},
  {
  "id": "110", "typ": "rachet", "nazwa": "M-85", "ilosc": 0, "img": "img/RatchetM-85.webp", "ATK": 8, "DEF": 19, "STM": 13, "waga": 10.6},
  {
  "id": "111", "typ": "rachet", "nazwa": "0-70", "ilosc": 0, "img": "img/Ratchet0-70.webp", "ATK": 3, "DEF": 13, "STM": 14, "waga": 7.0},
  {
  "id": "112", "typ": "rachet", "nazwa": "0-80", "ilosc": 0, "img": "img/Ratchet0-80.webp", "ATK": 3, "DEF": 12, "STM": 15, "waga": 7.6},
  {
  "id": "113", "typ": "rachet", "nazwa": "1-60", "ilosc": 0, "img": "img/Ratchet1-60.webp", "ATK": 17, "DEF": 9, "STM": 4, "waga": 6.0},
  {
  "id": "114", "typ": "rachet", "nazwa": "1-80", "ilosc": 0, "img": "img/Ratchet1-80.webp", "ATK": 17, "DEF": 4, "STM": 9, "waga":6.7},
  {
  "id": "115", "typ": "rachet", "nazwa": "2-70", "ilosc": 0, "img": "img/Ratchet2-70.webp", "ATK": 10, "DEF": 12, "STM": 8, "waga": 6.4},
  {
  "id": "116", "typ": "rachet", "nazwa": "3-70", "ilosc": 0, "img": "img/Ratchet3-70.webp", "ATK": 15, "DEF": 8, "STM": 7, "waga": 6.4},
  {
  "id": "117", "typ": "rachet", "nazwa": "3-85", "ilosc": 0, "img": "img/Ratchet3-85.webp", "ATK": 5, "DEF": 15, "STM": 10, "waga": 4.7},
  {
  "id": "118", "typ": "rachet", "nazwa": "4-50", "ilosc": 0, "img": "img/Ratchet4-50.webp", "ATK": 12, "DEF": 13, "STM": 5, "waga": 5.9},
  {
  "id": "119", "typ": "rachet", "nazwa": "5-70", "ilosc": 0, "img": "img/Ratchet5-70.webp", "ATK": 12, "DEF": 8, "STM": 10, "waga": 6.7},
  {
  "id": "120", "typ": "rachet", "nazwa": "7-60", "ilosc": 0, "img": "img/Ratchet7-60.webp", "ATK": 8, "DEF": 14, "STM": 8, "waga": 7.1},
  {
  "id": "121", "typ": "rachet", "nazwa": "7-70", "ilosc": 0, "img": "img/Ratchet7-70.webp", "ATK": 8, "DEF": 12, "STM": 10, "waga": 7.3},
  {
  "id": "122", "typ": "rachet", "nazwa": "9-70", "ilosc": 0, "img": "img/Ratchet9-70.webp", "ATK": 13, "DEF": 10, "STM": 7, "waga": 6.3},
  {
  "id": "123", "typ": "rachet", "nazwa": "4-55", "ilosc": 0, "img": "img/Ratchet4-55.webp", "ATK": 7, "DEF": 11, "STM": 12, "waga": 4.8 },
  {
  "id": "124", "typ": "rachet", "nazwa": "6-60", "ilosc": 0, "img": "img/Ratchet6-60.webp", "ATK": 14, "DEF": 8, "STM": 8, "waga": 6.1 },
  {
  "id": "125", "typ": "rachet", "nazwa": "6-80", "ilosc": 0, "img": "img/Ratchet6-80.webp", "ATK": 14, "DEF": 6, "STM": 10, "waga": 6.9 },
  {
  "id": "126", "typ": "bit","rodzaj": "wytrzymalosc", "nazwa": "Ball", "ilosc": 0, "img": "img/BitBall.webp", "ATK":15, "DEF": 25, "STM": 50, "waga": 2.1, "DASH": 10, "BURST_RES": 30},
  {
  "id": "127", "typ": "bit","rodzaj": "atak", "nazwa": "Cyclone", "ilosc": 0, "img": "img/BitCyclone.webp", "ATK": 40, "DEF": 5, "STM": 10, "waga":2.1, "DASH": 45, "BURST_RES": 80},
  {
  "id": "128", "typ": "bit","rodzaj": "obrona", "nazwa": "Dot", "ilosc": 0, "img": "img/BitDot.webp", "ATK": 10, "DEF": 55, "STM": 25, "waga": 2.0, "DASH": 10, "BURST_RES": 30},
  {
  "id": "129", "typ": "bit","rodzaj": "balans", "nazwa": "Elevate", "ilosc": 0, "img": "img/BitElevate.webp", "ATK": 30, "DEF": 15, "STM": 20, "waga": 3.2, "DASH": 35, "BURST_RES": 30},
  {
  "id": "130", "typ": "bit","rodzaj": "atak", "nazwa": "Flat", "ilosc": 0, "img": "img/BitFlat.webp", "ATK": 40, "DEF": 15, "STM": 10, "waga": 2.2, "DASH": 35, "BURST_RES": 80},
  {
  "id": "131", "typ": "bit","rodzaj": "wytrzymalosc", "nazwa": "Gear Ball", "ilosc": 0, "img": "img/BitGearBall.webp", "ATK": 10, "DEF": 15, "STM": 45, "waga": 2.0, "DASH": 30, "BURST_RES": 30},
  {
  "id": "132", "typ": "bit","rodzaj": "atak", "nazwa": "Gear Flat", "ilosc": 0, "img": "img/BitGearFlat.webp", "ATK": 50, "DEF": 5, "STM": 5, "waga": 2.3, "DASH": 40, "BURST_RES": 80},
  {
  "id": "133", "typ": "bit","rodzaj": "obrona", "nazwa": "Gear Needle", "ilosc": 0, "img": "img/BitGearNeedle.webp", "ATK": 20, "DEF": 40, "STM": 10, "waga": 2.0, "DASH": 30, "BURST_RES": 30},
  {
  "id": "134", "typ": "bit","rodzaj": "balans", "nazwa": "Gear Point", "ilosc": 0, "img": "img/BitGearPoint.webp", "ATK": 30, "DEF": 25, "STM": 15, "waga": 2.3, "DASH": 30, "BURST_RES": 80},
  {
  "id": "135", "typ": "bit","rodzaj": "obrona", "nazwa": "High Needle", "ilosc": 0, "img": "img/BitHighNeedle.webp", "ATK": 15, "DEF": 55, "STM": 20, "waga": 2.2, "DASH": 10, "BURST_RES": 30},
  {
  "id": "136", "typ": "bit","rodzaj": "balans", "nazwa": "High Taper", "ilosc": 0, "img": "img/BitHighTaper.webp", "ATK": 30, "DEF": 25, "STM": 20, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "137", "typ": "bit","rodzaj": "atak", "nazwa": "Low Flat", "ilosc": 0, "img": "img/BitLowFlat.webp", "ATK": 45, "DEF": 5, "STM": 10, "waga": 2.1, "DASH": 40, "BURST_RES": 80},
  {
  "id": "138", "typ": "bit","rodzaj": "balans", "nazwa": "Merge", "ilosc": 0, "img": "img/BitMerge.webp", "ATK": 50, "DEF": 20, "STM": 10, "waga": 3.4, "DASH": 20, "BURST_RES": 80},
  {
  "id": "139", "typ": "bit","rodzaj": "obrona", "nazwa": "Needle", "ilosc": 0, "img": "img/BitNeedle.webp", "ATK": 10, "DEF": 50, "STM": 30, "waga": 2.0, "DASH": 10, "BURST_RES": 30},
  {
  "id": "140", "typ": "bit","rodzaj": "wytrzymalosc", "nazwa": "Orb", "ilosc": 0, "img": "img/BitOrb.webp", "ATK": 10, "DEF": 30, "STM": 50, "waga": 2.0, "DASH": 10, "BURST_RES": 30},
  {
  "id": "141", "typ": "bit","rodzaj": "balans", "nazwa": "Point", "ilosc": 0, "img": "img/BitPoint.webp", "ATK": 25, "DEF": 25, "STM": 25, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "142", "typ": "bit","rodzaj": "atak", "nazwa": "Quake", "ilosc": 0, "img": "img/BitQuake.webp", "ATK": 55, "DEF": 15, "STM": 5, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "143", "typ": "bit","rodzaj": "atak", "nazwa": "Rush", "ilosc": 0, "img": "img/BitRush.webp", "ATK": 40, "DEF": 10, "STM": 20, "waga": 2.1, "DASH": 30, "BURST_RES": 80},
  {
  "id": "144", "typ": "bit","rodzaj": "obrona", "nazwa": "Spike", "ilosc": 0, "img": "img/BitSpike.webp", "ATK": 10, "DEF": 45, "STM": 35, "waga": 2, "DASH": 10, "BURST_RES": 30},
  {
  "id": "145", "typ": "bit","rodzaj": "balans", "nazwa": "Taper", "ilosc": 0, "img": "img/BitTaper.webp", "ATK": 35, "DEF": 20, "STM": 20, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "146", "typ": "bit","rodzaj": "balans", "nazwa": "Trans Point", "ilosc": 0, "img": "img/BitTransPoint.webp", "ATK": 35, "DEF": 25, "STM": 25, "waga": 2.4, "DASH": 15, "BURST_RES": 80},
  {
  "id": "147", "typ": "bit","rodzaj": "balans", "nazwa": "Unite", "ilosc": 0, "img": "img/BitUnite.webp", "ATK": 25, "DEF": 25, "STM": 30, "waga": 2.1, "DASH": 25, "BURST_RES": 80},
  {
  "id": "148", "typ": "bit","rodzaj": "atak", "nazwa": "Accel", "ilosc": 0, "img": "img/BitAccel.webp", "ATK": 40, "DEF": 10, "STM": 10, "waga": 2.6, "DASH": 40, "BURST_RES": 80},
  {
  "id": "149", "typ": "bit","rodzaj": "obrona", "nazwa": "Bound Spike", "ilosc": 0, "img": "img/BitBoundSpike.webp", "ATK": 5, "DEF": 60, "STM": 30, "waga": 2.0, "DASH": 5, "BURST_RES": 30},
  {
    "typ": "cx-lock-chip",
    "nazwa": "Dran",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipDran.webp",
    "id": "150"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Cerberus",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipCerberus.webp",
    "id": "151"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Fox",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipFox.webp",
    "id": "152"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Hornet",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipHornet.webp",
    "id": "153"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Kraken",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipKraken.webp",
    "id": "154"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Leon",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipLeon.webp",
    "id": "155"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Pegasus",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipPegasus.webp",
    "id": "156"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Perseus",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipPerseus.webp",
    "id": "157"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Rhino",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipRhino.webp",
    "id": "158"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Sol",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipSol.webp",
    "id": "159"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Stag",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipStag.webp",
    "id": "160"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Valkyrie",
    "ilosc": 0,
    "waga": 5.6,
    "img": "img/LockChipValkyrie.webp",
    "id": "161"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Whale",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipWhale.webp",
    "id": "162"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Wizard",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipWizard.webp",
    "id": "163"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Flame",
    "ilosc": 0,
    "ATK": 5,
    "DEF": 15,
    "STM": 40,
    "waga": 28.5,
    "img": "img/MainBladeFlame.webp",
    "id": "164"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Antler",
    "ilosc": 0,
    "ATK": 8,
    "DEF": 15,
    "STM": 37,
    "waga": 28.8,
    "img": "img/Antler.webp",
    "id": "165"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Arc",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 10,
    "STM": 40,
    "waga": 29.2,
    "img": "img/MainBladeArc.webp",
    "id": "166"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Blast",
    "ilosc": 0,
    "ATK": 50,
    "DEF": 10,
    "STM": 15,
    "waga": 32.8,
    "img": "img/MainBladeBlast.webp",
    "id": "167"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Brave",
    "ilosc": 0,
    "ATK": 40,
    "DEF": 10,
    "STM": 10,
    "waga": 31.2,
    "img": "img/MainBladeBrave.webp",
    "id": "168"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Brush",
    "ilosc": 0,
    "ATK": 40,
    "DEF": 15,
    "STM": 5,
    "waga": 30.3,
    "img": "img/MainBladeBrush.webp",
    "id": "169"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Dark",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 40,
    "STM": 10,
    "waga": 30.3,
    "img": "img/MainBladeDark.webp",
    "id": "170"
  },
{
  "id": "171",
  "typ": "cx-main-blade","kierunek": "prawy",
  "nazwa": "Eclipse",
  "ilosc": 0,
  "maTryby": true,
  "tryby": [
    {
      "nazwaTrybu": "Upper",
      "img": "img/eclipse.webp",
      "ATK": 30,
      "DEF": 20,
      "STM": 10,
      "waga": 32.3
    },
    {
      "nazwaTrybu": "Smash",
      "img": "img/MainBladeEclipse_29.webp",
      "ATK": 20,
      "DEF": 30,
      "STM": 10,
      "waga": 32.3
    }
  ]
},


  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Fang",
    "ilosc": 0,
    "ATK": 35,
    "DEF": 10,
    "STM": 15,
    "waga": 29.1,
    "img": "img/MainBladeFang.webp",
    "id": "172"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Fort",
    "ilosc": 0,
    "ATK": 24,
    "DEF": 12,
    "STM": 24,
    "waga": 29.0,
    "img": "img/MainBladeFort.webp",
    "id": "173"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Reaper",
    "ilosc": 0,
    "ATK": 25,
    "DEF": 10,
    "STM": 25,
    "waga": 29.0,
    "img": "img/MainBladeReaper.webp",
    "id": "174"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Volt",
    "ilosc": 0,
    "ATK": 45,
    "DEF": 15,
    "STM": 15,
    "waga": 31.0,
    "img": "img/MainBladeVolt.webp",
    "id": "175"
  },
  {
    "typ": "cx-main-blade","kierunek": "prawy",
    "nazwa": "Wriggle",
    "ilosc": 0,
    "ATK": 18,
    "DEF": 2,
    "STM": 40,
    "waga": 29.3,
    "img": "img/MainBladeWriggle.webp",
    "id": "176"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Assault",
    "ilosc": 0,
    "ATK": 25,
    "DEF": 10,
    "STM": 5,
    "waga": 5,
    "img": "img/AssistBladeAssault.webp",
    "id": "177"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Bumper",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 20,
    "STM": 10,
    "waga": 5.3,
    "img": "img/AssistBladeBumper.webp",
    "id": "178"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Charge",
    "ilosc": 0,
    "ATK": 15,
    "DEF": 20,
    "STM": 5,
    "waga": 5.0,
    "img": "img/AssistBladeCharge.webp",
    "id": "179"
  },

    {
    "id": "180",
    "typ": "cx-assist-blade",
    "nazwa": "Dual",
    "ilosc": 0,
    "maTryby": true,
    "tryby": [
      {
        "nazwaTrybu": "Upper",
        "img": "img/AssistBladeDual.webp",
        "ATK": 17,
        "DEF": 13,
        "STM": 10,
        "waga": 5.9
      },
      {
        "nazwaTrybu": "Smash",
        "img": "img/AssistBladeDual_29.webp",
        "ATK": 13,
        "DEF": 17,
        "STM": 10,
        "waga": 5.9
      }
    ]
  },

  {
    "typ": "cx-assist-blade",
    "nazwa": "Jaggy",
    "ilosc": 0,
    "ATK": 20,
    "DEF": 15,
    "STM": 5,
    "waga": 4.9,
    "img": "img/AssistBladeJaggy.webp",
    "id": "181"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Massive",
    "ilosc": 0,
    "ATK": 15,
    "DEF": 15,
    "STM": 10,
    "waga": 5.3,
    "img": "img/AssistBladeMassive.webp",
    "id": "182"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Round",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 10,
    "STM": 20,
    "waga": 4.7,
    "img": "img/AssistBladeRound.webp",
    "id": "183"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Slash",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 20,
    "STM": 10,
    "waga": 4.7,
    "img": "img/AssistBladeSlash.webp",
    "id": "184"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Turn",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 10,
    "STM": 20,
    "waga": 5.8,
    "img": "img/AssistBladeTurn.webp",
    "id": "185"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Wheel",
    "ilosc": 0,
    "ATK": 5,
    "DEF": 15,
    "STM": 20,
    "waga": 7.2,
    "img": "img/AssistBladeWheel.webp",
    "id": "186"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Hells",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipHells.webp",
    "id": "187"
  },
  {
    "id": "188",
    "typ": "bit","rodzaj": "atak",
    "nazwa": "Gear Rush",
    "ilosc": 0,
    "img": "img/BitGearRush.webp",
    "ATK": 45,
    "DEF": 10,
    "STM": 10,
    "waga": 2.1,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "189",
    "typ": "bit","rodzaj": "balans",
    "nazwa": "Kick",
    "ilosc": 0,
    "img": "img/BitKick.webp",
    "ATK": 35,
    "DEF": 25,
    "STM": 15,
    "waga": 2.2,
    "DASH": 25,
    "BURST_RES": 80
  },
  {
    "id": "190",
    "typ": "bit","rodzaj": "wytrzymalosc",
    "nazwa": "Low Orb",
    "ilosc": 0,
    "img": "img/BitLowOrb.webp",
    "ATK": 5,
    "DEF": 25,
    "STM": 55,
    "waga": 1.85,
    "DASH": 15,
    "BURST_RES": 30
  },
  {
    "id": "191",
    "typ": "bit","rodzaj": "balans",
    "nazwa": "Trans Kick",
    "ilosc": 0,
    "img": "img/BitTransKick.webp",
    "ATK": 35,
    "DEF": 30,
    "STM": 20,
    "waga": 2.3,
    "DASH": 15,
    "BURST_RES": 80
  },
  {
    "id": "192",
    "typ": "bit","rodzaj": "atak",
    "nazwa": "Vortex",
    "ilosc": 0,
    "img": "img/BitVortex.webp",
    "ATK": 45,
    "DEF": 10,
    "STM": 5,
    "waga": 2.2,
    "DASH": 40,
    "BURST_RES": 80
  },
  {
    "id": "193_wallball", 
    "typ": "bit","rodzaj": "wytrzymalosc",
    "nazwa": "Wall Ball",
    "ilosc": 0,
    "img": "img/BitWallBall.webp",
    "ATK": 15,
    "DEF": 30,
    "STM": 45,
    "waga": 2.41,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "193_wedge", 
    "typ": "bit","rodzaj": "obrona",
    "nazwa": "Wedge",
    "ilosc": 0,
    "img": "img/BitWedge.webp",
    "ATK": 5,
    "DEF": 55,
    "STM": 30,
    "waga": 1.83,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "194",
    "typ": "bit","rodzaj": "wytrzymalosc",
    "nazwa": "Disk Ball",
    "ilosc": 0,
    "img": "img/BitDiskBall.webp",
    "ATK": 15,
    "DEF": 20,
    "STM": 55,
    "waga": 3.2,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "195",
    "typ": "bit","rodzaj": "wytrzymalosc",
    "nazwa": "Free Ball",
    "ilosc": 0,
    "img": "img/BitFreeBall.webp",
    "ATK": 10,
    "DEF": 25,
    "STM": 60,
    "waga": 1.9,
    "DASH": 15,
    "BURST_RES": 30
  },
  {
    "id": "196",
    "typ": "bit","rodzaj": "wytrzymalosc",
    "nazwa": "Glide",
    "ilosc": 0,
    "img": "img/BitGlide.webp",
    "ATK": 20,
    "DEF": 10,
    "STM": 55,
    "waga": 2.5,
    "DASH": 15,
    "BURST_RES": 30
  },
  {
    "id": "197",
    "typ": "bit","rodzaj": "balans",
    "nazwa": "Hexa",
    "ilosc": 0,
    "img": "img/BitHexa.webp",
    "ATK": 30,
    "DEF": 35,
    "STM": 20,
    "waga": 2.6,
    "DASH": 15,
    "BURST_RES": 80
  },
  {
    "id": "198",
    "typ": "bit","rodzaj": "atak",
    "nazwa": "Level",
    "ilosc": 0,
    "img": "img/BitLevel.webp",
    "ATK": 40,
    "DEF": 5,
    "STM": 15,
    "waga": 2.7,
    "DASH": 40,
    "BURST_RES": 80
  },
  {
    "id": "199",
    "typ": "bit","rodzaj": "atak",
    "nazwa": "Low Rush",
    "ilosc": 0,
    "img": "img/BitLowRush.webp",
    "ATK": 45,
    "DEF": 5,
    "STM": 10,
    "waga": 1.9,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "200",
    "typ": "bit","rodzaj": "obrona",
    "nazwa": "Metal Needle",
    "ilosc": 0,
    "img": "img/BitMetalNeedle.webp",
    "ATK": 8,
    "DEF": 57,
    "STM": 30,
    "waga": 2.8,
    "DASH": 5,
    "BURST_RES": 30
  },
  {
    "id": "201",
    "typ": "bit","rodzaj": "atak",
    "nazwa": "Rubber Accel",
    "ilosc": 0,
    "img": "img/BitRubberAccel.webp",
    "ATK": 60,
    "DEF": 17,
    "STM": 3,
    "waga": 3.1,
    "DASH": 20,
    "BURST_RES": 80
  },
  {
    "id": "202",
    "typ": "bit","rodzaj": "atak",
    "nazwa": "Under Flat",
    "ilosc": 0,
    "img": "img/BitUnderFlat.webp",
    "ATK": 55,
    "DEF": 5,
    "STM": 5,
    "waga": 2.0,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "203",
    "typ": "bit","rodzaj": "obrona",
    "nazwa": "Under Needle",
    "ilosc": 0,
    "img": "img/BitUnderNeedle.webp",
    "ATK": 10,
    "DEF": 60,
    "STM": 20,
    "waga": 1.9,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "204",
    "typ": "bit","rodzaj": "balans",
    "nazwa": "Zap",
    "ilosc": 0,
    "img": "img/BitZap.webp",
    "ATK": 30,
    "DEF": 20,
    "STM": 15,
    "waga": 2.5,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "205",
    "typ": "rachet",
    "nazwa": "Turbo",
	"rodzaj": "atak",
    "ilosc": 0,
    "img": "img/RatchetBitTurbo.webp",
    "ATK": 30,
    "DEF": 30,
    "STM": 60,
    "waga": 9.0,
    "DASH": 10,
    "BURST_RES": 30,
    "integrujeBit": true
 },
  {
  "id": "206", "typ": "ux-blade","kierunek": "prawy", "nazwa": "ClockMirage", "ilosc": 0, "img": "img/BladeClockMirage.webp", "ATK": 0, "DEF": 0, "STM": 0, "waga": 0}
  
  
]




</script>


</body>
</html>


