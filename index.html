<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Beyblade ANANAS</title>
<link rel="icon" href="tlo.png" type="image/png">
<link href="https://fonts.googleapis.com/css2?family=Kode+Mono:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
<style>
html, body {
    height:100%;
    margin:0;
    padding:0;
    font-family:'Kode Mono', monospace;
    background:#101018;
    color:#f0f0f0;
    overflow-x:hidden;
	   text-align: center
}
#vanta-background {
    position:fixed;
    width:100%;
    height:100%;
    top:0;
    left:0;
    z-index:0;
}
.sidebar {
    height:100%;
    width:50px; 
    position:fixed;
    top:0;
    left:0;
    background:rgba(30,30,30,0.75);
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
    box-shadow:3px 0 15px rgba(0,0,0,0.6);
    transition:width 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius:0 15px 15px 0;
    z-index:2000;
    display: flex;
    flex-direction: column;
    box-sizing: border-box; 
    overflow-x: hidden; 
}
.sidebar.expanded { width:260px; }
.openbtn-container {
    width: 100%; 
    padding-top: 10px; 
    padding-bottom: 8px; 
    display: flex; 
    box-sizing: border-box;
}
.openbtn {
    cursor:pointer; display:flex; align-items:center; gap: 12px; 
    border-radius:10px; transition: background-color 0.25s ease;
    box-sizing: border-box; padding: 10px; margin: 0 auto; 
}
.sidebar.expanded .openbtn-container { padding-left: 10px; padding-right: 10px; }
.sidebar.expanded .openbtn { margin: 0; }
.openbtn:focus-visible { 
    border-color: rgba(138, 43, 226, 0.7);
    box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.3);
}
.openbtn img { width:28px; height:28px; display: block; flex-shrink: 0; }
.openbtn .menu-text {
    color:#f0f0f0; font-size:1.0em; font-weight:bold; opacity:0;
    max-width:0; overflow:hidden; white-space:nowrap;
    transition:opacity 0.25s ease 0.1s, max-width 0.25s ease 0.1s;
}
.sidebar.expanded .openbtn .menu-text { opacity:1; max-width:120px; }
.sidebar-links {
    width: 100%; overflow-y: auto; max-height: calc(100% - 70px); 
    box-sizing: border-box;
}
.sidebar a {
    display:flex; align-items:center; gap:12px; color:#e0e0e0; 
    text-decoration:none; transition: background-color 0.25s ease, color 0.25s ease;
    border-radius:8px; box-sizing: border-box; white-space: nowrap; 
    overflow: hidden; padding: 12px; justify-content: center;
    width: auto; margin: 4px auto; 
}
.sidebar:not(.expanded) a span { display: none; }
.sidebar.expanded a {
    width: calc(100% - 20px); margin: 4px 10px;         
    padding: 12px 10px; justify-content: flex-start; 
}
.sidebar.expanded a span { display: inline; opacity:1; }
.sidebar a:hover { background:rgba(70,70,70,0.8); color: #ffffff; }
.sidebar a img { width: 22px; height: 22px; flex-shrink: 0; }
.sidebar a.active-link {
    background: rgba(138,43,226,0.4); font-weight: bold; color: #fff;
}
.sidebar a.active-link:hover { background: rgba(138,43,226,0.5); }
#app-container {
    position:relative; z-index:1; min-height:100vh; padding: 20px; 
    box-sizing:border-box; margin-left:50px; 
    transition: margin-left 0.35s cubic-bezier(0.4, 0, 0.2, 1);
}
.page { display:none; padding-top: 20px; animation: fadeInPage 0.5s ease-in-out; }
.page.active { display:block;}
@keyframes fadeInPage {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
label { display: block; margin-bottom: 5px; color: #ccc; font-size: 0.9em;}
select, input[type="text"], input[type="number"], input[type="url"], textarea {
    width:100%; padding:12px 15px; margin:0 0 10px 0;
    background:rgba(45,45,55,0.8); color:#f0f0f0;
    font-family:'Kode Mono', monospace; font-size:1em;
    box-sizing:border-box; border-radius:8px;
    border: 1px solid rgba(255,255,255,0.15); 
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
select:focus, input[type="text"]:focus, input[type="number"]:focus, input[type="url"]:focus, textarea:focus {
    border-color: rgba(138, 43, 226, 0.7);
    box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.25); 
}
textarea { resize:vertical; min-height: 80px; margin-bottom:12px; }
button {
    cursor:pointer; background:rgba(80,85,95,0.8); color: #f0f0f0;
    transition:background-color 0.2s ease, transform 0.1s ease;
    border: 1px solid rgba(255,255,255,0.1); padding: 12px 18px; 
    font-family:'Kode Mono', monospace; font-size: 1em;
    border-radius:8px; font-weight: bold;
}
button:hover { background:rgba(100,105,115,0.9); }
button:active { transform: scale(0.97); background:rgba(70,75,85,0.9); }
button:disabled { background: rgba(60,60,70,0.7); color: #888; cursor: not-allowed; }
.button-auto-width { width:auto; }
button.cancel-btn, button.danger-btn { background: rgba(190, 50, 50, 0.7); }
button.cancel-btn:hover, button.danger-btn:hover { background: rgba(210, 60, 60, 0.8); }
button.cancel-btn:active, button.danger-btn:active { background: rgba(170, 40, 40, 0.8); }

.card {
    background:rgba(35,35,45,0.75); backdrop-filter:blur(6px); 
    -webkit-backdrop-filter:blur(6px); border-radius:15px; 
    box-shadow:0 8px 20px rgba(0,0,0,0.5); padding:20px; 
    margin:15px 0; text-align:center; width: 100%; box-sizing: border-box;
}
.card h2, .page > h2 { margin-top:0; margin-bottom: 20px; color: #a25ff0; font-weight: bold; text-align: center;}
.card h3 { margin-top:0; margin-bottom: 15px; color: #b27ff0; font-weight: bold;}
.card h4 { margin-top:0; margin-bottom: 8px; color: #c080ff; font-weight: bold;}
.card p { font-size: 0.95em; line-height: 1.6; color: #d0d0d0; }

img.part-img { 
    max-width: 130px; height: 130px; object-fit:contain;
    display:block; margin:10px auto 15px auto; border-radius: 10px; 
}
.part-img-placeholder { 
    width: 130px; height: 130px; display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.15); border-radius: 10px; margin: 10px auto 15px auto;
    color: #999; font-size: 0.9em; text-align: center;
}

.wynik-zestaw-obrazki {
    display: flex; justify-content: center; align-items: center;
    gap: 8px; padding: 8px 5px; width: 100%;
    min-height: auto; overflow: hidden; box-sizing: border-box; 
}
.wynik-zestaw-obrazki img.deck-part-img,
.wynik-zestaw-obrazki div.deck-part-placeholder {
    height: 60px; max-width: 60px; object-fit: contain; border-radius: 4px;
}
.deck-part-placeholder {
    width:60px; height:60px; border:1px dashed #555; 
    background-color: rgba(0,0,0,0.15); 
    display:flex; align-items:center; justify-content:center; 
    font-size:0.55em; color:#999; border-radius:4px;
}
.wynik-zestaw-obrazki div.deck-part-placeholder[title*="Bit zintegrowany"] {
    font-size: 0.5em; line-height: 1.2; padding: 5px; box-sizing: border-box; 
}
.wynik-nazwy { 
    text-align: center; margin-top: 10px; margin-bottom: 5px; 
    font-size: 0.9em; font-weight: bold; word-break: break-word; color: #e0e0e0; line-height: 1.4;
}
.card p strong { color: #a25ff0; }
.item-actions {
    display:flex; justify-content:space-around; gap: 8px; margin-top:15px;
}
.item-actions button {
    flex-grow: 1; flex-basis: 0; padding: 10px; font-size: 0.85em;
}
.wylosowany-zestaw-cx .cx-blade-komponenty, .wylosowany-zestaw-cx .cx-drive-komponenty {
    border: 1px solid rgba(138,43,226,0.3); padding: 8px; margin-bottom: 10px; border-radius: 8px;
}
.wylosowany-zestaw-cx .cx-blade-komponenty h5, .wylosowany-zestaw-cx .cx-drive-komponenty h5 {
    margin:0 0 8px 0; text-align:center; color:#c080ff; font-size: 0.9em;
}
.cx-images-container .cx-blade-row,
.cx-images-container .cx-drive-row {}
.cx-images-container .cx-drive-row { margin-top: 5px; }
.import-export-section { margin-bottom:25px; }
.action-button-container {
    background:rgba(40,40,50,0.7); backdrop-filter:blur(10px); 
    -webkit-backdrop-filter:blur(10px); border-radius:12px;
    padding:20px; margin-top:15px; box-shadow:0 6px 15px rgba(0,0,0,0.45);
}
.action-button-container h4 {
    margin-top:0; margin-bottom:12px; color: #a25ff0; font-size: 1.1em;
}
#notification-bar {
    position:fixed; top:0; left:0; width:100%; color:white;
    text-align:center; padding:14px; font-size: 1em; font-weight: bold;
    z-index:10000; display:none; border-radius:0 0 12px 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
    opacity:0; transition: opacity 0.3s ease-in-out;
}
#notification-bar.notification-show { opacity:1; }
#generator-obraz img {
    display: block; width: 70%; max-width: 220px; height: auto;   
    margin: 10px auto; animation: rotateImg 10s linear infinite; 
    opacity: 0.99; /* Zmienione z 0.99x */ border-radius: 12px;
}
@keyframes rotateImg {
    from { transform: rotate(0deg); } to { transform: rotate(360deg); }
}
* { -webkit-tap-highlight-color: transparent; }
button, a, select, input, textarea { outline: none; }
#lista-magazyn {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  gap: 15px;
}
#lista-magazyn .card { 
  display: flex; flex-direction: column;
  align-items: center; justify-content: space-between;
  padding: 15px; 
}
#lista-magazyn img.part-img {
  width: 100px; height: 100px; object-fit: contain; margin-bottom: 10px;
}
#lista-magazyn h3 { font-size: 1.05em; margin: 5px 0; color: #e0e0e0;}
#lista-magazyn p { font-size: 0.8em; margin: 3px 0; line-height: 1.3; color: #bbb;}
#savedDecksContainer {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
    gap: 15px;
}
.saved-deck-card { text-align: left; }
.deck-card-set-preview { 
    margin-bottom: 10px; padding-bottom: 10px; 
    border-bottom: 1px solid rgba(255,255,255,0.08);
}
.deck-card-set-preview:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0;}
.deck-card-set-preview strong { font-size:0.9em; display: block; margin-bottom: 6px; color: #c080ff;}
.deck-card-set-preview .wynik-zestaw-obrazki { 
    justify-content: center; gap: 6px; margin-bottom: 6px; padding: 0;
}
.stat-grid { 
    display: flex; flex-wrap: wrap; justify-content: center; gap: 5px 10px; 
    margin-top: 5px; font-size: 0.8em; line-height: 1.5;
}
.stat-grid span { padding: 3px 6px; border-radius: 3px; white-space:nowrap; }
/* #formularz .card { padding: 20px; } */ /* Jeśli formularz nie jest już używany, można usunąć */
/* #formularz label { display: block; margin-bottom: 4px; text-align: left; font-size:0.9em; color:#ccc;} */
/* #formularz input[type="text"], 
#formularz input[type="number"], 
#formularz input[type="url"] {
    margin-bottom: 12px; 
} */
.item-quantity-controls {
    display: flex; align-items: center; justify-content: center;
    gap: 10px; margin-top: 12px; margin-bottom: 8px;
}
.quantity-btn {
    font-size: 1.2em; padding: 6px 12px; min-width: 40px; 
    line-height: 1; font-weight: bold;
}
.quantity-btn:disabled {
    background: rgba(60,60,70,0.5); color: #777; cursor: not-allowed;
}
.quantity-display {
    font-size: 1.1em; font-weight: bold; padding: 5px 10px;
    background-color: rgba(0,0,0,0.15); border-radius: 6px;
    min-width: 30px; text-align: center;
}
.item-management-actions {
    display: flex; justify-content: space-around; gap: 8px; margin-top: 10px;
}
.small-action-btn {
    padding: 8px 12px; font-size: 0.8em; flex-grow: 1; flex-basis: 0;
}
.small-action-btn.danger-btn { background: rgba(190, 50, 50, 0.7); }
.small-action-btn.danger-btn:hover { background: rgba(210, 60, 60, 0.8); }
.beta-label {
    color: red; font-size: 0.8em; margin-left: 6px; font-weight: bold;
}
.score-counter-card {
    display: flex; /* Włącz Flexbox */
    flex-direction: row; /* Domyślnie elementy będą w rzędzie */
    flex-wrap: wrap; /* Pozwól na zawijanie na mniejszych ekranach */
    justify-content: space-around; /* Rozkłada przestrzeń wokół elementów */
    gap: 20px; /* Odstęp między sekcjami graczy */
    padding: 25px;
    align-items: flex-start; /* Wyrównaj elementy do góry, jeśli mają różne wysokości */
}
}
.player-section {
    background-color: rgba(25, 25, 35, 0.6); padding: 20px; border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3); width: 100%; max-width: 450px;
    box-sizing: border-box; text-align: center;
}
.player-section h3 {
    color: #c080ff; margin-top: 0; margin-bottom: 15px; font-size: 1.5em;
}
.score-display {
    font-size: 4.5em; font-weight: bold; color: #fff;
    background-color: rgba(10,10,10,0.4); padding: 15px 25px;
    border-radius: 10px; margin-bottom: 20px; min-width: 100px;
    display: inline-block; line-height: 1; border: 2px solid rgba(138, 43, 226, 0.3);
}
.score-buttons button {
    font-size: 1.1em; padding: 10px 18px; margin: 5px; min-width: 60px;
}
.score-buttons button.danger-btn { background-color: rgba(200, 60, 60, 0.7); }
.score-buttons button.danger-btn:hover { background-color: rgba(220, 70, 70, 0.8); }
.player-section input[type="text"] {
    margin-top: 15px; margin-bottom: 0; text-align: center;
    font-size: 0.9em; padding: 10px;
}
.game-controls { margin-top: 20px; width: 100%; text-align: center; }
.game-controls button { font-size: 1.2em; }

/* Style dla Drag and Drop Deck Buildera */
.deck-builder-container { display: flex; gap: 20px; }
.available-parts-panel {
    width: 300px; padding: 15px; background: rgba(40,40,50,0.7);
    border-radius: 10px; height: fit-content; max-height: 70vh; overflow-y: auto;
}
.available-parts-panel h4 { margin-top: 0; margin-bottom: 10px; color: #c080ff; text-align: center;}
.available-part-item {
    display: flex; align-items: center; gap: 10px; padding: 8px; margin-bottom: 8px;
    background: rgba(55,55,65,0.8); border-radius: 6px; cursor: grab; transition: background-color 0.2s;
}
.available-part-item:hover { background: rgba(70,70,80,0.9); }
.available-part-item img { width: 40px; height: 40px; object-fit: contain; border-radius: 4px; }
.available-part-item span { font-size: 0.9em; color: #e0e0e0; }
.dragging { opacity: 0.5; border: 2px dashed #8a2be2; } /* Styl dla elementu, który jest aktualnie przeciągany */
.deck-set-slots-container { flex-grow: 1; }
.deck-part-slot {
    min-height: 70px; padding: 10px; margin-bottom: 10px; background: rgba(30,30,40,0.6);
    border: 2px dashed rgba(255,255,255,0.2); border-radius: 8px; display: flex;
    align-items: center; justify-content: center; gap: 10px;
    transition: background-color 0.2s, border-color 0.2s;
    text-align: center; color: #888; font-size: 0.9em;
}
.deck-part-slot.drag-over-target { background-color: rgba(138,43,226,0.2); border-color: #8a2be2; }
.deck-part-slot.filled {
    border-style: solid; border-color: rgba(255,255,255,0.1); background: rgba(45,45,55,0.7);
    justify-content: space-between; padding: 5px 10px;
}
.deck-part-slot .part-info-container { display: flex; align-items: center; gap: 8px;}
.deck-part-slot img { width: 50px; height: 50px; object-fit: contain; border-radius: 4px; }
.deck-part-slot span.part-name { font-size: 0.95em; color: #e0e0e0; }
.deck-part-slot .remove-part-btn {
    background: none; border: none; color: #ff6b6b; font-size: 1.3em;
    font-weight: bold; cursor: pointer; padding: 5px; line-height: 1;
}
.deck-part-slot .remove-part-btn:hover { color: #ff4757; }


@media (max-width: 768px) { /* Poprawka dla responsywności D&D buildera */
    .deck-builder-container {
        flex-direction: column;
    }
    .available-parts-panel {
        width: 100%; /* Pełna szerokość na mobilnych */
        max-height: 40vh; /* Dostosuj wysokość panelu części */
    }
}
@media (max-width: 600px) {
    .score-counter-card { padding: 15px; }
    .player-section { padding: 15px; }
    .score-display { font-size: 3.5em; padding: 10px 20px; }
    .score-buttons button { font-size: 1em; padding: 8px 15px; min-width: 50px; }
}
/* === RESPONSYWNOŚĆ DECK BUILDERA DLA URZĄDZEŃ MOBILNYCH === */
@media (max-width: 768px) {
    .deck-builder-container {
        flex-direction: column; /* Układa panel części i sloty jeden pod drugim */
        align-items: center; /* Opcjonalnie: wycentruj elementy w kontenerze flex */
    }

    .available-parts-panel {
        width: 100%; /* Panel części zajmuje całą dostępną szerokość */
        max-width: 500px; /* Opcjonalnie: można ustawić maksymalną szerokość, jeśli nie chcesz, by był zbyt szeroki na tabletach w trybie portretowym */
        max-height: 45vh; /* Zmniejszona maksymalna wysokość, aby więcej miejsca było na sloty poniżej. Dostosuj według potrzeb. */
        margin-bottom: 25px; /* Dodaje odstęp między panelem części a kontenerem slotów decku */
        /* overflow-y: auto; -- już powinno być zdefiniowane, ale upewnijmy się */
    }

    .deck-set-slots-container {
        width: 100%; /* Kontener ze slotami na zestawy również zajmuje całą szerokość */
    }

    /* Opcjonalnie: dostosowanie marginesów kart zestawów na mobilnych */
    .deck-set-slots-container .deck-set.card {
        margin-left: 0;
        margin-right: 0;
    }

    /* Jeśli używasz inputa do filtrowania w panelu części, upewnij się, że jest responsywny */
    .available-parts-panel .filter-parts-dnd {
        display: flex;
        flex-direction: column; /* Etykieta nad selectem */
        gap: 5px; /* Mały odstęp */
    }
    .available-parts-panel .filter-parts-dnd label {
        text-align: left; /* Wyrównaj etykietę do lewej */
    }
    .available-parts-panel .filter-parts-dnd select {
        width: 100%; /* Select na całą szerokość */
    }
}

/* Dodatkowe drobne poprawki dla bardzo małych ekranów, jeśli potrzebne */
@media (max-width: 480px) {
    .available-parts-panel {
        max-height: 40vh; /* Jeszcze mniejsza wysokość dla bardzo małych ekranów */
    }

    .deck-part-slot {
        /* Możesz chcieć zmniejszyć minimalną wysokość slotu lub padding na bardzo małych ekranach */
        min-height: 60px;
        font-size: 0.8em; /* Mniejszy tekst w placeholderze slotu */
    }

    .deck-part-slot img { /* Obrazek części w slocie */
        width: 40px;
        height: 40px;
    }

    .available-part-item img { /* Obrazek części na liście D&D */
        width: 35px;
        height: 35px;
    }
    .available-part-item span {
        font-size: 0.85em;
    }
}
/* Style dla zakładek w Deck Builderze */
.tabs-container {
    display: flex;
    margin-bottom: 15px; /* Odstęp od slotów poniżej */
    border-bottom: 2px solid rgba(138, 43, 226, 0.3); /* Linia pod zakładkami */
}

.tab-button {
    padding: 10px 18px;
    cursor: pointer;
    background-color: rgba(55, 55, 65, 0.7);
    color: #ccc;
    border: none;
    border-top-left-radius: 6px;
    border-top-right-radius: 6px;
    font-family: 'Kode Mono', monospace;
    font-size: 0.95em;
    font-weight: bold;
    transition: background-color 0.2s, color 0.2s;
    margin-right: 4px; /* Mały odstęp między guzikami */
    border-bottom: 2px solid transparent; /* Miejsce na "aktywną" krawędź */
}

.tab-button:hover {
    background-color: rgba(70, 70, 80, 0.8);
    color: #fff;
}

.tab-button.active {
    background-color: rgba(35,35,45,0.75); /* Ten sam kolor co .card */
    color: #a25ff0; /* Kolor akcentu */
    border-bottom: 2px solid #a25ff0; /* Podkreślenie aktywnej zakładki */
    position: relative; /* Aby border-bottom był na wierzchu linii kontenera */
    /* top: 2px;  Można dodać, aby "podnieść" zakładkę nad linię */
}

/* Kontener na sloty aktywnego zestawu */
#deck-builder-active-set-slots .deck-set.card {
    margin-top: 0; /* Usuń margines górny, jeśli zakładki są bezpośrednio nad */
}
.inline-icon {
    height: 2em; /* Ustawia wysokość ikonki na równą wysokości bieżącej czcionki */
    width: auto;  /* Szerokość dostosuje się automatycznie, zachowując proporcje */
    vertical-align: middle; /* Wyrównuje ikonkę pionowo ze środkiem tekstu */
    margin: 0 5px; /* Dodaje mały margines po bokach ikonki dla lepszego odstępu */
    /* Możesz też użyć:
    vertical-align: text-bottom; lub text-top; w zależności od preferencji */
}
#info ul li strong + .inline-icon {
    margin-left: 6px;  /* Odstęp od tekstu strong */
    margin-right: 3px; /* Mniejszy odstęp do następnego tekstu */
}
#info ul li .inline-icon { /* Ogólne dla wszystkich ikonek w liście */
    height: 2em; /* Można lekko zwiększyć, jeśli tekst jest duży */
    vertical-align: -0.6em; /* Delikatne przesunięcie w dół dla lepszego dopasowania wizualnego */
}

.player-section {
    background-color: rgba(25, 25, 35, 0.6);
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    width: 100%;
    max-width: 450px;
    box-sizing: border-box;
    text-align: center;
    position: relative; /* Może być przydatne, ale nie jest już kluczowe dla tła */
}

/* NOWE Style dla pełnoekranowej nakładki Finishu */
    .fullscreen-finish-overlay { /* POPRAWKA */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 1);
        display: none; /* Początkowo ukryty */
        justify-content: center;
        align-items: center;
        z-index: 9000;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }

    .fullscreen-finish-overlay.visible { /* POPRAWKA */
        display: flex;
        opacity: 1;
    }

    .fullscreen-finish-overlay img { /* POPRAWKA */
        max-width: 80vw;
        max-height: 80vh;
        object-fit: contain;
        animation: zoomInFinishImage 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

/* --- OSTATECZNE STYLE DLA PANELI INFO (STAŁA WYSOKOŚĆ I SCROLL) --- */

.info-panels-container {
    display: grid;
    grid-template-columns: 1fr 1fr; /* Dwie równe kolumny */
    gap: 20px;
    margin-top: 30px;
}

.info-panel {
    margin: 0; /* Reset marginesu z domyślnej klasy .card */
    text-align: left;
    display: flex;
    flex-direction: column;
}

.info-panel h4 {
    text-align: center;
    flex-shrink: 0; /* Nagłówek nie kurczy się */
}

.info-list {
    /* KLUCZOWE USTAWIENIA: Ograniczenie wysokości i scroll */
    max-height: calc(1.6em * 6 + 10px * 5); /* Oblicza wysokość dla ~6 linii */
    overflow-y: auto; /* Pokaż pasek przewijania, gdy treść jest za długa */
    
    /* Reszta stylów dla wyglądu */
    list-style-position: inside;
    margin: 10px 0 0 20px;
    padding: 0 10px 0 0; /* Padding po prawej, by tekst nie dotykał paska przewijania */
    line-height: 1.6;
    font-size: 0.9em;
}

.info-list li {
    margin-bottom: 10px;
}

/* Responsywność dla mniejszych ekranów */
@media (max-width: 768px) {
    .info-panels-container {
        grid-template-columns: 1fr; /* Przełącz na jedną kolumnę */
    }
}
/*
 *  NOWE STYLE - Niestandardowy wygląd paska przewijania
 */

/* --- Dla przeglądarek opartych na WebKit (Chrome, Safari, Edge, Opera) --- */
::-webkit-scrollbar {
    width: 10px; /* Szerokość paska przewijania */
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2); /* Kolor tła "toru" paska */
    border-radius: 10px; /* Zaokrąglenie toru */
}

::-webkit-scrollbar-thumb {
    background: rgba(138, 43, 226, 0.5); /* Główny kolor paska (fioletowy z Twojego motywu) */
    border-radius: 10px; /* Zaokrąglenie samego paska */
    border: 2px solid transparent; /* Tworzy wewnętrzny odstęp */
    background-clip: content-box; /* Sprawia, że border jest przezroczysty */
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(138, 43, 226, 0.8); /* Jaśniejszy kolor paska po najechaniu */
}

/* --- Dla przeglądarki Firefox --- */
/* Firefox używa nowszej, standardowej specyfikacji */
* {
    scrollbar-width: thin; /* Można użyć 'auto', 'thin' lub 'none' */
    scrollbar-color: rgba(138, 43, 226, 0.7) rgba(0, 0, 0, 0.2); /* Kolor paska i kolor tła toru */
}
.deck-part-slot .part-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}
.mode-switch-btn {
    font-size: 0.75em;
    padding: 4px 8px;
    background-color: rgba(138, 43, 226, 0.4);
    border: 1px solid rgba(138, 43, 226, 0.6);
    font-weight: normal;
}


</style>
</head>
<body>

<div id="vanta-background"></div>
<div id="notification-bar"></div>

<!-- Sidebar -->
<div class="sidebar" id="sidebar">
    <div class="openbtn-container">
        <div class="openbtn" id="sidebarToggleBtn" title="Rozwiń/Zwiń menu">
            <img src="menu.png" alt="Menu Icon" id="menu-icon">
            <span class="menu-text" id="menu-btn-text">MENU</span>
        </div>
    </div>
    <div class="sidebar-links">
        <a href="#" onclick="navigateTo('info', this)" title="Informacje i Instrukcja"><img src="info.png" alt="Info"><span>Info</span></a>
        <a href="#" onclick="navigateTo('generator', this)" title="Generator Zestawów"><img src="1.png" alt="Generator"><span>Generator</span></a>
        <a href="#" onclick="navigateTo('magazyn', this)" title="Mój Magazyn Części"><img src="2.png" alt="Magazyn"><span>Magazyn</span></a>
        <a href="#" onclick="navigateTo('licznikPunktow', this)" title="Licznik Punktów"><img src="3.png" alt="Licznik"><span>Licznik</span></a>
        <a href="#" onclick="navigateTo('deck', this)" title="Deck Generator"><img src="4.png" alt="Deck" class="menu-icon"><span>Deck Generator</span></a>
        <a href="#" onclick="navigateTo('galeriaDeckow', this)" title="Moje Zapisane Decki"><img src="5.png" alt="Galeria"><span>Moje Decki</span></a>
        <a href="#" onclick="navigateTo('importexport', this)" title="Ustawienia"><img src="6.png" alt="Import/Eksport"><span>Dane</span></a>
    </div>
</div>

<!-- NOWY ELEMENT DLA PEŁNOEKRANOWEGO OBRAZKA FINISHU -->
<div id="fullscreenFinishOverlay" class="fullscreen-finish-overlay">
    <img id="fullscreenFinishImage" src="#" alt="Finish Effect">
</div>

<div id="app-container">
    <section id="info" class="page">
        <h2>Witaj w Beyblade App by Ananasek</h2>
        <div id="generator-obraz" style="margin-top:20px; margin-bottom: 20px;">
            <img id="placeholder-img" src="tlo.png" alt="Animowane tło generatora">
        </div>
        <div class="card">
            <h3>Krótka Instrukcja Obsługi</h3>
            <p style="text-align: left; line-height: 1.8;">
                Witaj w aplikacji wspomagającej Twoje rozgrywki i zarządzanie kolekcją Beyblade! Oto kilka wskazówek, jak zacząć:
            </p>
            <ul style="text-align: left; margin-left: 20px; line-height: 1.8;">
                <li><strong>Generator Zestawów:</strong><img src="1.png" alt="Generator Icon" class="inline-icon">Wybierz serię i ilość, a aplikacja wylosuje dla Ciebie części z Twojego magazynu.</li>
                <li><strong>Mój Magazyn:</strong><img src="2.png" alt="Magazyn Icon" class="inline-icon"> Tutaj zarządzasz swoją kolekcją części</li>
                <li><strong>Licznik Punktów:</strong><img src="3.png" alt="Licznik Icon" class="inline-icon"> Prosty licznik do śledzenia wyników podczas rozgrywki</li>
                <li><strong>Deck Generator:</strong><img src="4.png" alt="Deck Icon" class="inline-icon"> Składaj własne decki w oparciu o zasady turniejowe</li>
                <li><strong>Moje Decki:</strong><img src="5.png" alt="Galeria Icon" class="inline-icon"> Przeglądaj, edytuj lub usuwaj decki</li>
                <li><strong>Dane:</strong><img src="6.png" alt="Dane Icon" class="inline-icon"> W tej sekcji możesz importować/eksportować swoje części jak i decki</li>
            </ul>
            <p style="text-align: left; margin-top: 15px;">
                Pamiętaj, aby regularnie zapisywać swoje dane (magazyn i decki) za pomocą opcji eksportu, aby uniknąć ich utraty!
            </p>
            <p style="text-align: center; margin-top: 20px; font-weight: bold;">
                Miłej zabawy i udanych pojedynków!
            </p>
        </div>
    <div class="info-panels-container">

    <div class="card info-panel">
        <h4>Co nowego / W planach:</h4>
        <ul class="info-list">
            <li><strong>Aktualnie:</strong> Rozbudowa bazy części, aktualizacja brakujących statystyk.</li>
            <li><strong>W planach:</strong> Optymalizacja obecnych oraz dodawanie nowych funkcji.</li>
            <li style="margin-top: 10px;"><em>Masz sugestie? Daj znać!</em></li>
        </ul>
    </div>

    <div class="card info-panel">
        <h4>Patch Notes:</h4>
        <ul class="info-list">
		<li><strong>v2.2.0:</strong> dodanie systemu trybów na elementach np.<em>Eclipse</em> i <em>Dual</em> </li>
		<li><strong>v2.1.4:</strong> Rozdzielenie <em>Eclipse</em> na upper i smash mode </li>
		<li><strong>v2.1.3:</strong> Dodano część brakujących statystyk</li>
		<li><strong>v2.1.2:</strong> Dodano Patch Note</li>
		<li><strong>v2.1.1:</strong> Dodano <em>ClockMirage</em> wraz z zasadami dopasowania do niego</li>
        <li><strong>v2.1.0:</strong> Nowa Strona główna Info</li>
		<li><strong>v2.0.3:</strong> Poprawki Graficnze licznika punktów</li>
		<li><strong>v2.0.2:</strong> Dodane Automatyczny update Bazy Dysków</li>
		<li><strong>v2.0.1:</strong> Bugfixy, zwiększony cap losowań</li>
        <li><strong>v2.0.0:</strong> Deck Builder 2.0 Zmiany graficzne</li>
		<li><strong>v1.2.0:</strong> Dodano licznik punków</li>
        <li><strong>v1.1.2:</strong> Poprawa deck buildera</li>
		<li><strong>v1.1.1:</strong> Poprawa zasad dla <em>Turbo</em></li>
        <li><strong>v1.1.0:</strong> Dodano import export dla decków i magazynu</li>
        <li><strong>v1.0.1:</strong> Dodano deck builder oraz status beta części w magazynie oraz obsługe cx</li>
        <li><strong>v1.0.0:</strong> Dodano generator zestawów losowych wraz z ręcznym dodawaniem części</li>
        </ul>
    </div>

</div>
    </section>

    <section id="licznikPunktow" class="page">
        <h2>Licznik Punktów Rozgrywki</h2>
        <div class="card score-counter-card">
            <div class="player-section" data-player-id="player1">
                <h3 id="playerName1">Gracz 1</h3>
                <!-- Obrazek finishu jest teraz globalny, usuwamy stąd lokalne kontenery -->
                <div class="score-display" id="scorePlayer1">0</div>
                <div class="score-buttons">
                    <button onclick="updateScore('player1', 1, 'spin_finish')">Spin </button>
                    <button onclick="updateScore('player1', 2, 'over_finish')">Over </button>
                    <button onclick="updateScore('player1', 2, 'burst_finish')">Burst </button>
                    <button onclick="updateScore('player1', 3, 'xtreme_finish')">Xtreme </button>
                    <button class="danger-btn" onclick="updateScore('player1', -1)" style="margin-left: 10px;">-1</button>
                </div>
                <input type="text" id="inputPlayerName1" placeholder="Wpisz imię Gracza 1" onchange="updatePlayerName('player1')">
            </div>

            <div class="player-section" data-player-id="player2">
                <h3 id="playerName2">Gracz 2</h3>
                 <!-- Obrazek finishu jest teraz globalny, usuwamy stąd lokalne kontenery -->
                <div class="score-display" id="scorePlayer2">0</div>
                <div class="score-buttons">
                    <button onclick="updateScore('player2', 1, 'spin_finish')">Spin </button>
                    <button onclick="updateScore('player2', 2, 'over_finish')">Over </button>
                    <button onclick="updateScore('player2', 2, 'burst_finish')">Burst </button>
                    <button onclick="updateScore('player2', 3, 'xtreme_finish')">Xtreme </button>
                    <button class="danger-btn" onclick="updateScore('player2', -1)" style="margin-left: 10px;">-1</button>
                </div>
                <input type="text" id="inputPlayerName2" placeholder="Wpisz imię Gracza 2" onchange="updatePlayerName('player2')">
            </div>
            <div class="game-controls">
                <button onclick="resetScoresAndImages()">Resetuj Wyniki</button>
            </div>
        </div>
    </section>

    <section id="generator" class="page">
        <h2>Generator Zestawów</h2>
        <div class="card">
            <label for="seriaLosowania">Wybierz Serię do Losowania:</label>
            <select id="seriaLosowania" aria-label="Seria Beybladów do losowania">
                <option value="bx_ux">BX / UX (Blade, Ratchet, Bit)</option>
                <option value="cx">CX (LockChip, Main, Assist, Ratchet, Bit)</option>
            </select>
            <label for="ilosc" style="margin-top:15px;">Wybierz ilość Beybladów do wylosowania:</label>
            <select id="ilosc" aria-label="Ilość Beybladów do wylosowania">
                <option value="1">1</option><option value="2">2</option><option value="3">3</option>
                <option value="4">4</option><option value="5">5</option><option value="6">6</option>
                <option value="7">7</option><option value="8">8</option><option value="9">9</option>
                <option value="10">10</option><option value="11">11</option><option value="12">12</option>
                <option value="13">13</option><option value="14">14</option><option value="15">15</option>
                <option value="16">16</option><option value="17">17</option><option value="18">18</option>
                <option value="19">19</option><option value="20">20</option><option value="21">21</option>
                <option value="22">22</option><option value="23">23</option><option value="24">24</option>
            </select>
            <div style="display:flex; gap:10px; margin-top:20px;">
                <button onclick="LOSUJ()">Losuj Zestawy</button>
                <button onclick="wyczyscLosowanie()" class="cancel-btn">Wyczyść Wyniki</button>
            </div>
        </div>
        <div id="wyniki" style="margin-top:20px;"></div>
        <!-- Dodany kontener dla przycisków zapisu wylosowanego zestawu -->
    
    </section>

    <section id="magazyn" class="page">
        <h2>Mój Magazyn Części</h2>
        <div class="card" style="display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-end;">
            <div style="flex-grow: 1; min-width: 200px;">
                <label for="filterKategoria">Filtruj według kategorii:</label>
                <select id="filterKategoria" onchange="wyswietlMagazyn()" aria-label="Filtr kategorii części">
                    <option value="all">Wszystkie Kategorie</option>
                    <optgroup label="Seria BX / UX">
                        <option value="blade">Blade (BX/UX)</option>
                    </optgroup>
                    <optgroup label="Seria CX">
                        <option value="cx-lock-chip">CX Lock Chip</option>
                        <option value="cx-main-blade">CX Main Blade</option>
                        <option value="cx-assist-blade">CX Assist Blade</option>
                    </optgroup>
                    <optgroup label="Komponenty Wspólne">
                        <option value="rachet">Ratchet</option>
                        <option value="bit">Bit</option>
                    </optgroup>
                </select>
            </div>
            <div style="flex-grow: 1; min-width: 200px;">
                <label for="filterPosiadane">Pokaż części:</label>
                <select id="filterPosiadane" onchange="wyswietlMagazyn()" aria-label="Filtr posiadanych części">
                    <option value="posiadane">Posiadane</option>
                    <option value="nieposiadane">Nieposiadane</option>
                    <option value="wszystkie_w_bazie">Wszystkie</option>
                </select>
            </div>
        </div>
        <div id="lista-magazyn" style="margin-top:15px;"></div>
    </section>

    <section id="deck" class="page">
        <h2>Deck Generator</h2>
        <p style="text-align: center;">Przeciągnij części z panelu do odpowiednich slotów aktywnego zestawu.</p>
        <div class="card" style="margin-bottom: 20px;">
            <h3>Zarządzanie Deckiem</h3>
            <div>
                <label for="deckName" style="display: block; margin-bottom: 5px;">Nazwa Decku:</label>
                <input type="text" id="deckName" placeholder="Np. Mój Deck Turniejowy" style="margin-bottom: 10px;">
            </div>
            <button id="saveDeckButton" onclick="saveCurrentDeck()">Zapisz Aktualny Deck</button>
             <button onclick="clearCurrentDeckForBuilder()" class="cancel-btn" style="margin-left:10px;">Wyczyść Builder</button>
        </div>
        <div class="deck-builder-container">
            <div class="available-parts-panel" id="available-parts-panel">
                <h4>Dostępne Części</h4>
                <div class="filter-parts-dnd" style="margin-bottom:15px;">
                    <label for="dndPartTypeFilter">Filtruj części:</label>
                    <select id="dndPartTypeFilter" onchange="renderAvailablePartsList()">
                        <option value="blade">Blade (BX/UX)</option>
                        <option value="cx-lock-chip">CX Lock Chip</option>
                        <option value="cx-main-blade">CX Main Blade</option>
                        <option value="cx-assist-blade">CX Assist Blade</option>
                        <option value="rachet">Ratchet</option>
                        <option value="bit">Bit</option>
                    </select>
                </div>
                <div id="parts-list-for-dnd">
                    <!-- Lista części do przeciągania -->
                </div>
            </div>
            <div class="deck-set-slots-container">
                <div id="deck-set-tabs-container" class="tabs-container">
                    <!-- Guziki zakładek będą generowane przez JS -->
                </div>
                <div id="deck-builder-active-set-slots">
                    <!-- Slotów na aktywny zestaw będą renderowane tutaj przez JS -->
                </div>
            </div>
        </div>
    </section>

    <section id="galeriaDeckow" class="page">
        <h2>Moje Zapisane Decki</h2>
        <p style="text-align: center;">Tutaj znajdziesz wszystkie swoje zapisane konfiguracje decków.</p>
        <div id="savedDecksContainer" style="margin-top: 20px;"></div>
    </section>

    <section id="importexport" class="page">
        <h2>Zarządzanie Danymi Aplikacji</h2>
        <div class="action-button-container import-export-section">
            <h4>Importuj lub Eksportuj Dane Magazynu Części</h4>
            <p style="font-size:0.9em; color:#bbb; margin-bottom:10px;">
                Skopiuj dane z pola poniżej, aby utworzyć kopię zapasową magazynu, lub wklej wcześniej zapisane dane, aby je przywrócić.
            </p>
            <button class="button-auto-width" onclick="eksportujDaneDoPolaTekstowego()">Eksportuj Magazyn</button>
            <textarea id="poleDanychJsonMagazyn" rows="8" placeholder="Dane magazynu JSON..." aria-label="Pole JSON magazynu"></textarea>
            <button class="button-auto-width" onclick="importujDaneZPolaTekstowego()">Importuj Magazyn</button>
        </div>
        <div class="action-button-container import-export-section">
            <h4>Importuj lub Eksportuj Zapisane Decki</h4>
            <p style="font-size:0.9em; color:#bbb; margin-bottom:10px;">
                Skopiuj dane z pola poniżej, aby utworzyć kopię zapasową swoich decków, lub wklej wcześniej zapisane dane, aby je przywrócić.
            </p>
            <button class="button-auto-width" onclick="eksportujDeckiDoPolaTekstowego()">Eksportuj Decki</button>
            <textarea id="poleDanychJsonDecki" rows="8" placeholder="Dane decków JSON..." aria-label="Pole JSON decków"></textarea>
            <button class="button-auto-width" onclick="importujDeckiZPolaTekstowego()">Importuj Decki</button>
        </div>
        <div class="action-button-container">
            <h4>Resetowanie Aplikacji</h4>
            <p style="font-size:0.9em; color:#bbb; margin-bottom:10px;">
                Ta operacja <strong>usunie wszystkie Twoje dane</strong> (magazyn części, zapisane decki, wyniki)
                i przywróci aplikację do stanu początkowego z domyślną bazą części.
            </p>
            <button id="resetAppButton" class="button-auto-width danger-btn" onclick="wykonajPelnyResetAplikacji()" style="margin-top:10px;">
                Resetuj Aplikację (Nieodwracalne)
            </button>
        </div>
    </section>
</div>



<script>
// =================================
// Konfiguracja i Zmienne Globalne
// =================================
const ID_CLOCK_MIRAGE = "206"
let sidebarExpanded = false;
const sidebarWidthExpanded = 260;
const sidebarWidthCollapsed = 50;
let currentEditingDeckId = null; 

let sidebar, appContainer, sidebarToggleBtn, menuIcon, menuBtnText;
let wynikiDivGenerator, placeholderActualImgGenerator;

let ostatnioWylosowaneZestawyGlobalnie = [];

const MAGAZYN_KEY = 'beybladeMagazynAnanasCX_v3';
const SAVED_DECKS_KEY = 'savedBeybladeDecksAnanasCX_v3';
const SCORES_KEY = 'beybladeScoreCounterAnanas';
const DOMYSLNA_BAZA_ZALADOWANA_KEY = 'ananasAppDomyślnaBazaZaladowana_v1'; // Nowy klucz
let currentDeckBeingBuilt = {}; // Zostanie zainicjalizowane w DOMContentLoaded lub przy nawigacji
    let currentlyActiveSetIndexInBuilder = 0; // Domyślnie pierwszy zestaw (indeks 0)
	let imageHideTimeouts = { player1: null, player2: null };
	let fullscreenOverlayHideTimeout = null;
function initializeOrResetCurrentDeck(deckData = null) {
    const defaultSetStructure = () => ({
        seria: 'bx_ux',
        bladeId: null, bladeAktywnyTrybIndex: 0, // Indeks dla trybu Blade
        ratchetId: null,
        bitId: null,
        cx_lock_chipId: null,
        cx_main_bladeId: null, cx_main_bladeAktywnyTrybIndex: 0, // Indeks dla trybu Main Blade
        cx_assist_bladeId: null,
        statystykiObliczone: {}
    });

    if (deckData && deckData.id) {
        currentDeckBeingBuilt = JSON.parse(JSON.stringify(deckData)); // Głęboka kopia
        // Upewnij się, że każdy zestaw ma wszystkie potrzebne klucze, nawet jeśli są null
        currentDeckBeingBuilt.sets = currentDeckBeingBuilt.sets.map(set => ({
            ...defaultSetStructure(), // Zacznij od domyślnej struktury
            ...set // Nadpisz wartościami z wczytanego zestawu
        }));
        // Uzupełnij do 4 zestawów, jeśli jest mniej
        while (currentDeckBeingBuilt.sets.length < 4) {
            currentDeckBeingBuilt.sets.push(defaultSetStructure());
        }
        if (document.getElementById('deckName')) {
            document.getElementById('deckName').value = currentDeckBeingBuilt.name || "";
        }
        currentEditingDeckId = deckData.id; // Ustaw ID edytowanego decku
    } else {
        currentDeckBeingBuilt = {
            name: "",
            id: `temp_deck_${Date.now()}_${Math.random().toString(16).slice(2)}`,
            sets: Array(4).fill(null).map(() => defaultSetStructure())
        };
        if (document.getElementById('deckName')) {
            document.getElementById('deckName').value = "";
        }
        currentEditingDeckId = null; // Resetuj ID edytowanego decku
    }
    console.log("Zainicjalizowano/Zresetowano currentDeckBeingBuilt:", JSON.parse(JSON.stringify(currentDeckBeingBuilt)));
}

    function clearCurrentDeckForBuilder() {
        const deckNameInput = document.getElementById('deckName');
        if(deckNameInput) deckNameInput.value = "";
        initializeOrResetCurrentDeck(); 
        currentEditingDeckId = null; 
        const saveBtn = document.getElementById('saveDeckButton');
        if (saveBtn) saveBtn.textContent = 'Zapisz Aktualny Deck';
        
        currentlyActiveSetIndexInBuilder = 0; // Zresetuj do pierwszej zakładki
        renderDeckBuilderAndParts(); // Odśwież widok buildera (zakładki i sloty)
        showNotification("Builder decku wyczyszczony.", 2000, 'info');
    }
// =================================
// Zarządzanie Magazynem (localStorage)
// =================================
function getMagazyn() {
    try {
        const magazynString = localStorage.getItem(MAGAZYN_KEY);
        return magazynString ? JSON.parse(magazynString) : [];
    } catch (e) { showNotification("Błąd odczytu danych magazynu.", 3000, 'error'); console.error("Błąd odczytu magazynu:", e); return []; }
}
function setMagazyn(magazynArray) {
    try {
        if (Array.isArray(magazynArray)) {
            localStorage.setItem(MAGAZYN_KEY, JSON.stringify(magazynArray));
        } else {
            showNotification("Błąd zapisu: Dane magazynu muszą być tablicą.", 3000, 'error');
            console.error("setMagazyn: Przekazano nie-tablicę:", magazynArray);
        }
    } catch (e) { showNotification("Błąd zapisu danych magazynu.", 3000, 'error'); console.error("Błąd zapisu magazynu:", e); }
}

// =================================
// Zarządzanie Zapisanymi Deckami (localStorage)
// =================================
function getSavedDecks() {
    try {
        const decksString = localStorage.getItem(SAVED_DECKS_KEY);
        return decksString ? JSON.parse(decksString) : [];
    } catch (e) {
        showNotification("Błąd odczytu zapisanych decków.", 3000, 'error');
        console.error("getSavedDecks Błąd:", e);
        return [];
    }
}
function setSavedDecks(decksArray) {
    try {
        if (Array.isArray(decksArray)) {
            localStorage.setItem(SAVED_DECKS_KEY, JSON.stringify(decksArray));
        } else {
            showNotification("Błąd zapisu decków: Nieprawidłowe dane (nie jest tablicą).", 3000, 'error');
            console.error("setSavedDecks: Próba zapisu nie-tablicy:", decksArray);
        }
    } catch (e) {
        showNotification("Błąd zapisu decków do localStorage.", 3000, 'error');
        console.error("setSavedDecks Błąd:", e);
    }
}

// =================================
// Logika Licznika Punktów
// =================================
let scores = { player1: 0, player2: 0 };
let playerNames = { player1: "Gracz 1", player2: "Gracz 2" };

function displayScores() {
    const scoreP1 = document.getElementById('scorePlayer1');
    const scoreP2 = document.getElementById('scorePlayer2');
    if (scoreP1) scoreP1.textContent = scores.player1;
    if (scoreP2) scoreP2.textContent = scores.player2;
}
function displayPlayerNames() {
    const nameP1Display = document.getElementById('playerName1');
    const nameP2Display = document.getElementById('playerName2');
    const nameP1Input = document.getElementById('inputPlayerName1');
    const nameP2Input = document.getElementById('inputPlayerName2');
    if (nameP1Display) nameP1Display.textContent = playerNames.player1;
    if (nameP2Display) nameP2Display.textContent = playerNames.player2;
    if (nameP1Input) nameP1Input.value = playerNames.player1 === "Gracz 1" ? "" : playerNames.player1;
    if (nameP2Input) nameP2Input.value = playerNames.player2 === "Gracz 2" ? "" : playerNames.player2;
}
let backgroundResetTimeouts = { player1: null, player2: null };
const finishBackgroundClasses = ['has-background-spin_finish', 'has-background-over_finish', 'has-background-burst_finish', 'has-background-xtreme_finish']; // Pomocnicza tablica klas

function updateScore(player, points, finishType = null) {
    console.log("updateScore called for:", player, "points:", points, "finishType:", finishType);

    if (!scores || !scores.hasOwnProperty(player)) {
        console.error("Błąd: Obiekt 'scores' lub właściwość dla gracza nie istnieje.", player);
        return;
    }

    scores[player] += points;
    if (typeof displayScores === 'function') displayScores();
    if (typeof saveScoresToLocalStorage === 'function') saveScoresToLocalStorage();

    const overlayElement = document.getElementById('fullscreenFinishOverlay');
    const imageElement = document.getElementById('fullscreenFinishImage');

    if (overlayElement && imageElement) {
        // Wyczyść poprzedni timeout ukrywania nakładki, jeśli istnieje
        if (fullscreenOverlayHideTimeout) {
            clearTimeout(fullscreenOverlayHideTimeout);
            fullscreenOverlayHideTimeout = null;
        }

        if (finishType && points > 0) {
            const imagePath = `img/${finishType}.png`;
            console.log("Setting fullscreen image path to:", imagePath);
            imageElement.src = imagePath;
            imageElement.alt = finishType.replace('_', ' ') + " Finish";

            overlayElement.classList.add('visible'); // Pokaż nakładkę z przejściem

            // Timeout do ukrycia nakładki
            fullscreenOverlayHideTimeout = setTimeout(() => {
                console.log("Timeout: Hiding fullscreen overlay");
                overlayElement.classList.remove('visible');
                // Można dodać opóźnienie na wyczyszczenie src, aby uniknąć "mignięcia"
                setTimeout(() => {
                    if (!overlayElement.classList.contains('visible')) { // Sprawdź, czy nadal jest ukryta
                        imageElement.src = '#';
                    }
                }, 300); // Czas trwania przejścia opacity
                fullscreenOverlayHideTimeout = null;
            }, 1000); // Nakładka zniknie po 2.8 sekundach (dostosuj)

        } else {
            // Jeśli punkty są odejmowane lub brak finishType, upewnij się, że nakładka jest ukryta
            // (chociaż normalnie powinna być już ukryta po timeout'cie)
            if (overlayElement.classList.contains('visible')) {
                 overlayElement.classList.remove('visible');
                 setTimeout(() => { imageElement.src = '#'; }, 300);
            }
        }
    } else {
        console.warn(`Nie znaleziono elementu nakładki (#fullscreenFinishOverlay) lub obrazka (#fullscreenFinishImage)`);
    }
}

function resetScoresAndImages() {
    scores.player1 = 0;
    scores.player2 = 0;
    if (typeof displayScores === 'function') displayScores();
    if (typeof saveScoresToLocalStorage === 'function') saveScoresToLocalStorage();

    const overlayElement = document.getElementById('fullscreenFinishOverlay');
    const imageElement = document.getElementById('fullscreenFinishImage');

    if (overlayElement && imageElement) {
        if (overlayElement.classList.contains('visible')) {
            overlayElement.classList.remove('visible');
            setTimeout(() => { imageElement.src = '#'; }, 300); // Dopasuj do czasu przejścia opacity
        }
    }

    if (fullscreenOverlayHideTimeout) {
        clearTimeout(fullscreenOverlayHideTimeout);
        fullscreenOverlayHideTimeout = null;
    }

    if (typeof showNotification === 'function') {
        showNotification("Wyniki zostały zresetowane.", 2000, 'info');
    }
}


function updatePlayerName(player) {
    const inputElement = document.getElementById(`inputPlayerName${player === 'player1' ? '1' : '2'}`);
    if (inputElement && playerNames.hasOwnProperty(player)) {
        const newName = inputElement.value.trim();
        playerNames[player] = newName !== '' ? newName : (player === 'player1' ? "Gracz 1" : "Gracz 2");
        displayPlayerNames();
        saveScoresToLocalStorage();
    }
}


function saveScoresToLocalStorage() {
    try {
        localStorage.setItem(SCORES_KEY, JSON.stringify({ scores, playerNames }));
    } catch (e) { console.error("Błąd zapisu wyników do localStorage:", e); }
}
function loadScoresFromLocalStorage() {
    try {
        const savedDataString = localStorage.getItem(SCORES_KEY);
        if (savedDataString) {
            const savedData = JSON.parse(savedDataString);
            if (savedData.scores) scores = savedData.scores;
            if (savedData.playerNames) playerNames = savedData.playerNames;
            scores.player1 = parseInt(scores.player1, 10) || 0;
            scores.player2 = parseInt(scores.player2, 10) || 0;
            playerNames.player1 = playerNames.player1 || "Gracz 1";
            playerNames.player2 = playerNames.player2 || "Gracz 2";
        }
    } catch (e) {
        console.error("Błąd odczytu wyników z localStorage:", e);
        scores = { player1: 0, player2: 0 };
        playerNames = { player1: "Gracz 1", player2: "Gracz 2" };
    }
    displayScores(); displayPlayerNames();
}
// =================================
// Funkcje Pomocnicze i Nawigacyjne
// =================================
function showNotification(message, duration = 3000, type = 'info') {
    const bar = document.getElementById("notification-bar");
    if (!bar) { console.error("Element #notification-bar nie znaleziony!"); return; }
    bar.textContent = message;
    bar.className = 'notification-show'; 
    let bgColor = 'rgba(138, 43, 226, 0.9)'; let textColor = '#fff';
    if (type === 'error') bgColor = 'rgba(220, 53, 69, 0.9)';
    else if (type === 'success') bgColor = 'rgba(40, 167, 69, 0.9)';
    else if (type === 'warning') { bgColor = 'rgba(255, 193, 7, 0.9)'; textColor = '#333'; } 
    bar.style.backgroundColor = bgColor; bar.style.color = textColor;
    bar.style.backdropFilter = 'blur(5px)'; bar.style.webkitBackdropFilter = 'blur(5px)';
    bar.style.display = "block"; bar.style.opacity = "1";
    if (bar._hideTimeout) clearTimeout(bar._hideTimeout);
    bar._hideTimeout = setTimeout(() => {
        bar.style.opacity = "0";
        setTimeout(() => { bar.style.display = "none"; }, 300); 
    }, duration);
}

function toggleSidebar() {
    sidebarExpanded = !sidebarExpanded;
    if (sidebar) sidebar.classList.toggle('expanded', sidebarExpanded);
    if (appContainer) appContainer.style.marginLeft = (sidebarExpanded ? sidebarWidthExpanded : sidebarWidthCollapsed) + 'px';
    if (menuIcon && menuBtnText) {
        if (sidebarExpanded) {
            menuIcon.src = 'menu2.png'; menuIcon.alt = "Zamknij"; menuBtnText.textContent = 'ZAMKNIJ MENU';
            if(sidebarToggleBtn) sidebarToggleBtn.title = "Zwiń menu";
        } else {
            menuIcon.src = 'menu.png'; menuIcon.alt = "Menu"; menuBtnText.textContent = 'MENU';
            if(sidebarToggleBtn) sidebarToggleBtn.title = "Rozwiń menu";
        }
    }
}

function navigateTo(pageId, clickedLinkElement) { // Usunięto forceRenderDeckBuilder, bo logika jest teraz wewnątrz
    console.log(`Nawigacja do: ${pageId}`);
    document.querySelectorAll('.sidebar a').forEach(link => link.classList.remove('active-link'));
    if (clickedLinkElement) clickedLinkElement.classList.add('active-link');
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    const page = document.getElementById(pageId);
    if (page) page.classList.add('active');
    else { 
        console.error(`Strona ID '${pageId}' nie znaleziona.`); 
        const fallbackLink = document.querySelector('.sidebar a[onclick*="navigateTo(\'generator"]');
        if (fallbackLink && pageId !== 'generator') navigateTo('generator', fallbackLink); // Wywołanie bez force
        return; 
    }

    if (pageId !== 'deck' && currentEditingDeckId) { 
        const deckNameInput = document.getElementById('deckName');
        if (deckNameInput) deckNameInput.value = '';
        currentEditingDeckId = null; 
        // initializeOrResetCurrentDeck(); // Już niepotrzebne tutaj, bo deck jest czyszczony przed każdym renderowaniem
        const saveBtn = document.getElementById('saveDeckButton');
        if (saveBtn) saveBtn.textContent = 'Zapisz Aktualny Deck';
        console.log("Zresetowano stan edycji decku po opuszczeniu strony 'deck'.");
    }
    
    if (pageId === 'magazyn') wyswietlMagazyn(); 
    else if (pageId === 'deck') {
        if (!currentEditingDeckId) { // Jeśli nie edytujemy, to inicjujemy pusty
             initializeOrResetCurrentDeck();
        }
        // Jeśli currentEditingDeckId jest ustawione, to dane zostaną załadowane przez `edytujDeck` -> `initializeOrResetCurrentDeck(deckData)`
        // a następnie `renderDeckBuilderAndParts`
        renderDeckBuilderAndParts(); 
    } else if (pageId === 'galeriaDeckow') displaySavedDecks();
    else if (pageId === 'licznikPunktow') loadScoresFromLocalStorage();
    
    if (sidebarExpanded && window.innerWidth < 768) toggleSidebar();
}

// =================================
// Wyświetlanie Magazynu
// =================================
function wyswietlMagazyn() {
    const magazynPelny = getMagazyn();
    const lista = document.getElementById('lista-magazyn');
    if (!lista) { console.error("Element #lista-magazyn nie istnieje."); return; }
    lista.innerHTML = '';

    if (!Array.isArray(magazynPelny)) {
        lista.innerHTML = '<div class="card" style="grid-column: 1 / -1; text-align:center;"><p>Błąd wczytywania.</p></div>';
        return;
    }

    const filtrKategorii = document.getElementById('filterKategoria')?.value || 'all';
    const filtrPosiadania = document.getElementById('filterPosiadane')?.value || 'posiadane';
    let czesciDoWyswietlenia = [...magazynPelny];

    if (filtrPosiadania === 'posiadane') {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => c && (parseInt(c.ilosc, 10) || 0) > 0);
    } else if (filtrPosiadania === 'nieposiadane') {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => c && (parseInt(c.ilosc, 10) || 0) === 0);
    }
    
    if (filtrKategorii !== 'all' && filtrKategorii) {
        czesciDoWyswietlenia = czesciDoWyswietlenia.filter(c => c && c.typ === filtrKategorii);
    }

    if (czesciDoWyswietlenia.length === 0) {
        lista.innerHTML = '<div class="card" style="grid-column: 1 / -1; text-align:center;"><p>Brak części pasujących do filtrów.</p></div>';
        return;
    }
    
    czesciDoWyswietlenia.sort((a, b) => {
        const typA = (a?.typ || "").toLowerCase(); const typB = (b?.typ || "").toLowerCase();
        const nazwaA = (a?.nazwa || "").toLowerCase(); const nazwaB = (b?.nazwa || "").toLowerCase();
        if (typA < typB) return -1; if (typA > typB) return 1;
        if (nazwaA < nazwaB) return -1; if (nazwaA > nazwaB) return 1;
        return 0;
    });

    czesciDoWyswietlenia.forEach((czesc) => {
        if (!czesc || !czesc.typ || typeof czesc.nazwa !== 'string') return;
        const ilosc = parseInt(czesc.ilosc, 10) || 0;
        
        let statyString = '';
        let isBeta = false;
        let buttonHTML = '';
        
        const aktywnyIndex = czesc.aktywnyTrybIndex || 0;
        const aktywnyTryb = (czesc.maTryby && Array.isArray(czesc.tryby)) ? czesc.tryby[aktywnyIndex] : null;

        const obrazekDoWyswietlenia = aktywnyTryb?.img || czesc.img;
        const nazwaDoWyswietlenia = aktywnyTryb ? `${czesc.nazwa} <span style="color:#a25ff0;">(${aktywnyTryb.nazwaTrybu})</span>` : czesc.nazwa;
        
        // Pobieramy dane do statystyk z aktywnego trybu lub z głównego obiektu
        const daneStatystyk = aktywnyTryb || czesc;
        const maStat = (statName) => typeof daneStatystyk[statName] === 'number';
        const jestZeroLubBrak = (statName) => !maStat(statName) || daneStatystyk[statName] === 0;

        // === LOGIKA STATYSTYK ZOSTAŁA UJEDNOLICONA ===
        if (czesc.typ === 'blade' || czesc.typ === 'rachet' || czesc.typ === 'cx-main-blade' || czesc.typ === 'cx-assist-blade') {
            if (jestZeroLubBrak('ATK') || jestZeroLubBrak('DEF') || jestZeroLubBrak('STM') || jestZeroLubBrak('waga')) isBeta = true;
            statyString = `ATK:${maStat('ATK') ? daneStatystyk.ATK : 'N/A'}, DEF:${maStat('DEF') ? daneStatystyk.DEF : 'N/A'}, STM:${maStat('STM') ? daneStatystyk.STM : 'N/A'}, Waga:${maStat('waga') ? daneStatystyk.waga : 'N/A'}g`;
        } else if (czesc.typ === 'bit') {
            if (jestZeroLubBrak('ATK') || jestZeroLubBrak('DEF') || jestZeroLubBrak('STM') || jestZeroLubBrak('waga') || jestZeroLubBrak('DASH') || jestZeroLubBrak('BURST_RES')) isBeta = true;
            statyString = `ATK:${maStat('ATK') ? daneStatystyk.ATK : 'N/A'}, DEF:${maStat('DEF') ? daneStatystyk.DEF : 'N/A'}, STM:${maStat('STM') ? daneStatystyk.STM : 'N/A'}, Waga:${maStat('waga') ? daneStatystyk.waga : 'N/A'}g, DASH:${maStat('DASH') ? daneStatystyk.DASH : 'N/A'}, B-RES:${maStat('BURST_RES') ? daneStatystyk.BURST_RES : 'N/A'}`;
        } else if (czesc.typ === 'cx-lock-chip') {
            if (jestZeroLubBrak('waga')) isBeta = true;
            statyString = `Waga:${maStat('waga') ? daneStatystyk.waga : 'N/A'}g`;
            if (maStat('cx_lc_wytrz')) statyString += `, Wytrz:${daneStatystyk.cx_lc_wytrz}`;
            if (maStat('cx_lc_atk_bonus')) statyString += `, ATK+:${daneStatystyk.cx_lc_atk_bonus}`;
            if (maStat('cx_lc_def_bonus')) statyString += `, DEF+:${daneStatystyk.cx_lc_def_bonus}`;
        }
        statyString = `<p style="font-size:0.85em; line-height:1.4;">${statyString}</p>`;

        // Logika przycisku (bez zmian)
        if (czesc.maTryby && czesc.tryby && czesc.tryby.length > 1 && aktywnyTryb) {
            buttonHTML = `
                <div style="margin-top: 10px;">
                    <button class="mode-switch-btn" onclick="przelaczTrybMagazynu('${czesc.id}')" title="Zmień tryb: ${aktywnyTryb.nazwaTrybu}">
                        ${aktywnyTryb.nazwaTrybu} 🔄
                    </button>
                </div>
            `;
        }
        
        const imgHTML = obrazekDoWyswietlenia ? `<img class="part-img" src="${obrazekDoWyswietlenia}" alt="${czesc.nazwa}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"><div class="part-img-placeholder" style="display:none;">Brak<br>obr.</div>` : `<div class="part-img-placeholder">Brak<br>obr.</div>`;
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        if (ilosc === 0) cardDiv.classList.add('part-not-owned');
        if (isBeta) cardDiv.classList.add('part-beta-item');
        const typNazwaFormatowana = czesc.typ.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const quantityControlsHTML = `
            <div class="item-quantity-controls">
                <button class="quantity-btn" onclick="zmienIloscCzesci('${czesc.id}', -1)" title="Zmniejsz ilość ${czesc.nazwa}" ${ilosc === 0 ? 'disabled' : ''}>-</button>
                <span class="quantity-display" title="Aktualna ilość: ${ilosc}">${ilosc}</span>
                <button class="quantity-btn" onclick="zmienIloscCzesci('${czesc.id}', 1)" title="Zwiększ ilość ${czesc.nazwa}">+</button>
            </div>`;
        
        cardDiv.innerHTML = `${imgHTML}<h3>${nazwaDoWyswietlenia}${isBeta ? '<span class="beta-label">BETA</span>' : ''}</h3><p style="font-size:0.8em; color:#bbb; margin-top:-10px; margin-bottom:8px;"><em>${typNazwaFormatowana}</em></p>${statyString}${buttonHTML}${quantityControlsHTML}`;
        lista.appendChild(cardDiv);
    });
}

function zmienIloscCzesci(idCzesci, zmiana) {
    const magazyn = getMagazyn();
    const indexCzesci = magazyn.findIndex(c => c && c.id === idCzesci);
    if (indexCzesci === -1) { showNotification("Błąd: Nie znaleziono części.", 3000, 'error'); return; }
    const czesc = magazyn[indexCzesci];
    let nowaIlosc = (parseInt(czesc.ilosc, 10) || 0) + zmiana;
    if (nowaIlosc < 0) nowaIlosc = 0;
    if (czesc.ilosc === nowaIlosc && zmiana !== 0) return;
    czesc.ilosc = nowaIlosc;
    magazyn[indexCzesci] = czesc;
    setMagazyn(magazyn);
    const aktywnaStronaId = document.querySelector('.page.active')?.id;
    if (aktywnaStronaId === 'magazyn') wyswietlMagazyn();
    if (aktywnaStronaId === 'deck') renderAvailablePartsList(); // Odśwież listę części dla D&D
}

// =================================
// Obliczanie Statystyk Zestawu
// =================================
function obliczSumeStatystykZestawu(czesciZestawu, seria) { // czesciZestawu to obiekt z częściami, np. {blade: objBlade, rachet: objRatchet, ...}
    const suma = { ATK: 0, DEF: 0, STM: 0, WAGA: 0, DASH: 0, B_RES: 0, CX_LC_WYTRZ: 0 };
    const getStat = (czesc, statName, defaultValue = 0) => {
        if (!czesc || typeof czesc[statName] === 'undefined' || czesc[statName] === null) return defaultValue;
        const val = parseFloat(czesc[statName]);
        return isNaN(val) ? defaultValue : val;
    };

    if (seria === 'bx_ux') {
        const { blade, rachet, bit } = czesciZestawu;
        if (blade) { suma.ATK += getStat(blade, 'ATK'); suma.DEF += getStat(blade, 'DEF'); suma.STM += getStat(blade, 'STM'); suma.WAGA += getStat(blade, 'waga'); }
        if (rachet) {
            suma.ATK += getStat(rachet, 'ATK'); suma.DEF += getStat(rachet, 'DEF'); suma.STM += getStat(rachet, 'STM'); suma.WAGA += getStat(rachet, 'waga');
            if (String(rachet.id) === "205" || rachet.integrujeBit === true) { // Specjalny Ratchet Turbo
                suma.DASH = getStat(rachet, 'DASH'); suma.B_RES = getStat(rachet, 'BURST_RES');
            }
        }
        const jestSpecjalnyRatchet = rachet && (String(rachet.id) === "205" || rachet.integrujeBit === true);
        if (bit && !jestSpecjalnyRatchet) {
            suma.DASH += getStat(bit, 'DASH'); suma.B_RES += getStat(bit, 'BURST_RES'); suma.WAGA += getStat(bit, 'waga');
        }
    } else if (seria === 'cx') {
        const { cx_lock_chip, cx_main_blade, cx_assist_blade, rachet, bit } = czesciZestawu;
        if (cx_lock_chip) { suma.WAGA += getStat(cx_lock_chip, 'waga'); suma.CX_LC_WYTRZ += getStat(cx_lock_chip, 'cx_lc_wytrz'); suma.ATK += getStat(cx_lock_chip, 'cx_lc_atk_bonus'); suma.DEF += getStat(cx_lock_chip, 'cx_lc_def_bonus'); }
        if (cx_main_blade) { suma.ATK += getStat(cx_main_blade, 'ATK'); suma.DEF += getStat(cx_main_blade, 'DEF'); suma.STM += getStat(cx_main_blade, 'STM'); suma.WAGA += getStat(cx_main_blade, 'waga'); }
        if (cx_assist_blade) { suma.ATK += getStat(cx_assist_blade, 'ATK'); suma.DEF += getStat(cx_assist_blade, 'DEF'); suma.STM += getStat(cx_assist_blade, 'STM'); suma.WAGA += getStat(cx_assist_blade, 'waga'); }
        if (rachet) {
            suma.ATK += getStat(rachet, 'ATK'); suma.DEF += getStat(rachet, 'DEF'); suma.STM += getStat(rachet, 'STM'); suma.WAGA += getStat(rachet, 'waga');
             if (String(rachet.id) === "205" || rachet.integrujeBit === true) { // Specjalny Ratchet Turbo
                suma.DASH = getStat(rachet, 'DASH'); suma.B_RES = getStat(rachet, 'BURST_RES');
            }
        }
        const jestSpecjalnyRatchetCX = rachet && (String(rachet.id) === "205" || rachet.integrujeBit === true);
        if (bit && !jestSpecjalnyRatchetCX) {
            suma.DASH += getStat(bit, 'DASH'); suma.B_RES += getStat(bit, 'BURST_RES'); suma.WAGA += getStat(bit, 'waga');
        }
    }

    for (const key in suma) {
        if (typeof suma[key] === 'number') suma[key] = parseFloat(suma[key].toFixed(1));
    }
    return suma;
}

// =================================
// Generator Losowych Zestawów
// =================================
function generujHTMLDlaKartyZestawu(zestaw, indexZestawu) {
    const { seria, czesci, statystyki, idZestawu } = zestaw;
    const getPartAndHTML = (partObj, partTypeDefaultName) => {
        const imgHTML = partObj?.img ? `<img src="${partObj.img}" alt="${partObj.nazwa || partTypeDefaultName}" class="deck-part-img">` : `<div class="deck-part-placeholder">${partTypeDefaultName.substring(0,3).toUpperCase()}</div>`; 
        const nameText = partObj ? (partObj.nazwa || `<i>${partTypeDefaultName} N/A</i>`) : `<i>Brak ${partTypeDefaultName}</i>`;
        return { html: imgHTML, name: nameText };
    };

    let setImagesHTML = ''; let setNameParts = [];
    const ratchetWylosowany = czesci.rachet;
    const czySpecjalnyRatchetZostalWylosowany = ratchetWylosowany && (String(ratchetWylosowany.id) === "205" || ratchetWylosowany.integrujeBit === true);

    if (seria === 'bx_ux') {
        const bladeInfo = getPartAndHTML(czesci.blade, 'Blade');
        const ratchetInfo = getPartAndHTML(ratchetWylosowany, 'Ratchet');
        let bitInfo = czySpecjalnyRatchetZostalWylosowany ? { html: `<div class="deck-part-placeholder" style="font-size:0.5em; line-height:1.2; padding:5px;" title="Bit zintegrowany w ${ratchetWylosowany.nazwa}">BIT<br>INTEG.</div>`, name: `<em>(Bit zint. w ${ratchetWylosowany.nazwa})</em>` } : getPartAndHTML(czesci.bit, 'Bit');
        setImagesHTML = `<div class="wynik-zestaw-obrazki">${bladeInfo.html} ${ratchetInfo.html} ${bitInfo.html}</div>`;
        setNameParts = [`<strong>Blade:</strong> ${bladeInfo.name}`, `<strong>Ratchet:</strong> ${ratchetInfo.name}`, `<strong>Bit:</strong> ${bitInfo.name}`];
    } else if (seria === 'cx') {
        const lockChipInfo = getPartAndHTML(czesci.cx_lock_chip, 'LockChip');
        const mainBladeInfo = getPartAndHTML(czesci.cx_main_blade, 'MainBlade');
        const assistBladeInfo = getPartAndHTML(czesci.cx_assist_blade, 'AssistBlade');
        const ratchetInfo = getPartAndHTML(ratchetWylosowany, 'Ratchet');
        let bitInfo = czySpecjalnyRatchetZostalWylosowany ? { html: `<div class="deck-part-placeholder" style="font-size:0.5em; line-height:1.2; padding:5px;" title="Bit zintegrowany w ${ratchetWylosowany.nazwa}">BIT<br>INTEG.</div>`, name: `<em>(Bit zint. w ${ratchetWylosowany.nazwa})</em>` } : getPartAndHTML(czesci.bit, 'Bit');
        setImagesHTML = `<div class="cx-images-container"><div class="cx-blade-row wynik-zestaw-obrazki">${lockChipInfo.html} ${mainBladeInfo.html} ${assistBladeInfo.html}</div><div class="cx-drive-row wynik-zestaw-obrazki" style="margin-top: 5px;">${ratchetInfo.html} ${bitInfo.html}</div></div>`;
        setNameParts = [`<strong>LockChip:</strong> ${lockChipInfo.name}`, `<strong>Main Blade:</strong> ${mainBladeInfo.name}`, `<strong>Assist Blade:</strong> ${assistBladeInfo.name}`, `<strong>Ratchet:</strong> ${ratchetInfo.name}`, `<strong>Bit:</strong> ${bitInfo.name}`];
    }
    
    let setNameHTML = setNameParts.join('<br>');
    let statySumaryczneHTML = '<div class="stat-grid">'; 
    statySumaryczneHTML += `<span>ATK: ${(statystyki.ATK || 0).toFixed(1)}</span>`;
    statySumaryczneHTML += `<span>DEF: ${(statystyki.DEF || 0).toFixed(1)}</span>`;
    statySumaryczneHTML += `<span>STM: ${(statystyki.STM || 0).toFixed(1)}</span>`;
    statySumaryczneHTML += `<span>Waga: ${(statystyki.WAGA || 0).toFixed(1)}g</span>`;
    if ((statystyki.DASH || 0) !== 0) statySumaryczneHTML += `<span>DASH: ${(statystyki.DASH || 0).toFixed(1)}</span>`;
    if ((statystyki.B_RES || 0) !== 0) statySumaryczneHTML += `<span>B-RES: ${(statystyki.B_RES || 0).toFixed(1)}</span>`;
    if (seria === 'cx' && (statystyki.CX_LC_WYTRZ || 0) !== 0) statySumaryczneHTML += `<span>LC-W: ${parseInt((statystyki.CX_LC_WYTRZ || 0).toFixed(0))}</span>`;
    statySumaryczneHTML += `</div>`;

    let zmienneStatyRatchetHTML = '';
    // ... (reszta logiki zmiennych statystyk Ratcheta, jeśli jest) ...

    return `
        <div class="card saved-deck-card generated-set-card ${seria === 'cx' ? 'wylosowany-zestaw-cx' : ''}" data-zestaw-id="${idZestawu}">
            <h4 style="text-align:center; color:#d1b3ff; margin-bottom: 10px;">Wylosowany Zestaw ${seria.toUpperCase().replace('_','/')} #${indexZestawu + 1}</h4>
            ${setImagesHTML}
            <div style="font-size:0.85em; color:#ddd; margin-top: 8px; margin-bottom:12px; word-break: break-word; text-align:center; line-height: 1.4;">${setNameHTML}</div>
            <div style="margin-top:10px; padding-top:10px; border-top: 1px solid rgba(255,255,255,0.1);"><strong style="display:block; text-align:center; font-size:0.9em; margin-bottom:5px; color:#c080ff;">SUMA STATYSTYK:</strong>${statySumaryczneHTML}</div>
            ${zmienneStatyRatchetHTML}
        </div>`;
}

function wyczyscLosowanie() {
    if (wynikiDivGenerator) wynikiDivGenerator.innerHTML = ''; 
    if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block'; 
    ostatnioWylosowaneZestawyGlobalnie = [];
    const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
    if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'none';
    const nazwaDeckuInput = document.getElementById('nazwa-glownego-decku');
    if(nazwaDeckuInput) nazwaDeckuInput.value = ""; // Czyścimy też pole nazwy
    showNotification('Wyniki losowania wyczyszczone.', 2000, 'info');
}

function LOSUJ() {
    if (!wynikiDivGenerator) { showNotification("Błąd: Element wyników generatora nie istnieje.", 3000, 'error'); return; }
    if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'none';
    wynikiDivGenerator.innerHTML = '';
    ostatnioWylosowaneZestawyGlobalnie = [];

    const iloscZestawowDoWylosowania = parseInt(document.getElementById('ilosc')?.value) || 1;
    const wybranaSeria = document.getElementById('seriaLosowania')?.value;

    if (!wybranaSeria) {
        showNotification("Błąd: Nie wybrano serii.", 3000, 'warning');
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        return;
    }

    const magazyn = getMagazyn();
    if (!magazyn || magazyn.length === 0) {
        wynikiDivGenerator.innerHTML = '<div class="card"><p>Magazyn jest pusty! Dodaj części w zakładce "Magazyn".</p></div>';
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        return;
    }

    const dostepneCzesciDoLosowania = { blade: [], rachet: [], bit: [], 'cx-lock-chip': [], 'cx-main-blade': [], 'cx-assist-blade': [] };
    magazyn.forEach(czesc => {
        const ilosc = parseInt(czesc.ilosc) || 0;
        if (ilosc > 0 && dostepneCzesciDoLosowania.hasOwnProperty(czesc.typ)) {
            for (let j = 0; j < ilosc; j++) {
                dostepneCzesciDoLosowania[czesc.typ].push({ ...czesc, _uniqueDragId: `${czesc.id}_instance_${j}_${Date.now()}_${Math.random()}` });
            }
        }
    });

    let czyWystarczajacoCzesci = true;
    let komunikatBrakuCzesci = "Niewystarczająca ilość części w magazynie do wylosowania ";
    if (wybranaSeria === 'bx_ux') {
        komunikatBrakuCzesci += `${iloscZestawowDoWylosowania} zestawu/ów BX/UX:`;
        if (dostepneCzesciDoLosowania.blade.length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało Blade,"; }
        if (dostepneCzesciDoLosowania.rachet.length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało Ratchet,"; }
        let potrzebneBity = 0;
        let dostepneZwykleRatchety = dostepneCzesciDoLosowania.rachet.filter(r => !(r.integrujeBit === true || String(r.id) === "205")).length;
        if (iloscZestawowDoWylosowania > dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchety) {
            potrzebneBity = Math.min(iloscZestawowDoWylosowania - (dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchety), dostepneZwykleRatchety)
        }
        if (dostepneCzesciDoLosowania.bit.length < potrzebneBity) {}
    } else if (wybranaSeria === 'cx') {
        komunikatBrakuCzesci += `${iloscZestawowDoWylosowania} zestawu/ów CX:`;
        if (dostepneCzesciDoLosowania['cx-lock-chip'].length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało LockChip,"; }
        if (dostepneCzesciDoLosowania['cx-main-blade'].length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało MainBlade,"; }
        if (dostepneCzesciDoLosowania['cx-assist-blade'].length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało AssistBlade,"; }
        if (dostepneCzesciDoLosowania.rachet.length < iloscZestawowDoWylosowania) { czyWystarczajacoCzesci = false; komunikatBrakuCzesci += " za mało Ratchet,"; }
        let potrzebneBityCX = 0;
        let dostepneZwykleRatchetyCX = dostepneCzesciDoLosowania.rachet.filter(r => !(r.integrujeBit === true || String(r.id) === "205")).length;
         if (iloscZestawowDoWylosowania > dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchetyCX) {
            potrzebneBityCX = Math.min(iloscZestawowDoWylosowania - (dostepneCzesciDoLosowania.rachet.length - dostepneZwykleRatchetyCX), dostepneZwykleRatchetyCX)
        }
        if (dostepneCzesciDoLosowania.bit.length < potrzebneBityCX) {}
    }
    if (!czyWystarczajacoCzesci) {
        showNotification(komunikatBrakuCzesci.slice(0, -1) + ".", 4000, 'warning');
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        return;
    }

    const wylosowaneZestawyFragment = document.createDocumentFragment();
    for (let i = 0; i < iloscZestawowDoWylosowania; i++) {
        let wylosowanyZestawCzesci = {};
        let czyZestawKompletny = true;
        let wylosowanoSpecjalnyRatchet = false;
		
		// --- POCZĄTEK NOWEJ LOGIKI ---
        const losujCzescZPulli = (typCzesci, filtrKompatybilnosci = null) => {
            let pulaFiltrwana = [...dostepneCzesciDoLosowania[typCzesci]];
            if (filtrKompatybilnosci) {
                pulaFiltrwana = pulaFiltrwana.filter(filtrKompatybilnosci);
            }

            if (pulaFiltrwana && pulaFiltrwana.length > 0) {
                const randomIndex = Math.floor(Math.random() * pulaFiltrwana.length);
                const wylosowanaCzescZKopii = pulaFiltrwana[randomIndex];

                const indexWOryginalnejPuli = dostepneCzesciDoLosowania[typCzesci].findIndex(c => c._uniqueDragId === wylosowanaCzescZKopii._uniqueDragId);
                if (indexWOryginalnejPuli > -1) {
                    const finalnieWylosowanaCzesc = dostepneCzesciDoLosowania[typCzesci].splice(indexWOryginalnejPuli, 1)[0];
					
					// NOWY KROK: Obsługa trybów
					if (finalnieWylosowanaCzesc.maTryby && Array.isArray(finalnieWylosowanaCzesc.tryby) && finalnieWylosowanaCzesc.tryby.length > 0) {
						const wylosowanyTrybIndex = Math.floor(Math.random() * finalnieWylosowanaCzesc.tryby.length);
						const wylosowanyTryb = finalnieWylosowanaCzesc.tryby[wylosowanyTrybIndex];
						
						// Tworzymy nowy obiekt części, który jest "spłaszczony" - zawiera dane z wylosowanego trybu
						const czescZTrybem = { ...finalnieWylosowanaCzesc };
						delete czescZTrybem.tryby; // Usuwamy tablicę trybów, bo już wybraliśmy jeden
						
						// Nadpisujemy właściwości części bazowej właściwościami z trybu
						Object.assign(czescZTrybem, wylosowanyTryb);
						
						// Zapisujemy, który tryb został wylosowany (przydatne przy zapisie)
						czescZTrybem.aktywnyTrybIndex = wylosowanyTrybIndex;
						czescZTrybem.nazwa = `${finalnieWylosowanaCzesc.nazwa} (${wylosowanyTryb.nazwaTrybu})`;

						return czescZTrybem;
					}
                    return finalnieWylosowanaCzesc; // Zwróć część bez trybów
                } else {
                    return null;
                }
            }
            return null;
        };
		// --- KONIEC NOWEJ LOGIKI ---

        if (wybranaSeria === 'bx_ux') {
            wylosowanyZestawCzesci.blade = losujCzescZPulli('blade');

            if (wylosowanyZestawCzesci.blade && String(wylosowanyZestawCzesci.blade.id) === ID_CLOCK_MIRAGE) {
                wylosowanyZestawCzesci.rachet = losujCzescZPulli('rachet', czesc => typeof czesc.nazwa === 'string' && (czesc.nazwa.match(/-\d*5$/) || czesc.nazwa.match(/^M-\d*5$/)));
                if (!wylosowanyZestawCzesci.rchet) { czyZestawKompletny = false; }
            } else if (wylosowanyZestawCzesci.blade) {
                wylosowanyZestawCzesci.rachet = losujCzescZPulli('rachet');
            } else { czyZestawKompletny = false; }

            if (wylosowanyZestawCzesci.rachet) {
                if (String(wylosowanyZestawCzesci.rachet.id) === "205" || wylosowanyZestawCzesci.rachet.integrujeBit === true) {
                    wylosowanoSpecjalnyRatchet = true; wylosowanyZestawCzesci.bit = null;
                } else { wylosowanyZestawCzesci.bit = losujCzescZPulli('bit'); }
            } else if (czyZestawKompletny) { czyZestawKompletny = false; wylosowanyZestawCzesci.bit = null; }

            if (!wylosowanyZestawCzesci.blade || !wylosowanyZestawCzesci.rachet || (!wylosowanoSpecjalnyRatchet && !wylosowanyZestawCzesci.bit && wylosowanyZestawCzesci.rachet)) {
                czyZestawKompletny = false;
            }
        } else if (wybranaSeria === 'cx') {
            wylosowanyZestawCzesci.cx_lock_chip = losujCzescZPulli('cx-lock-chip');
            wylosowanyZestawCzesci.cx_main_blade = losujCzescZPulli('cx-main-blade');
            wylosowanyZestawCzesci.cx_assist_blade = losujCzescZPulli('cx-assist-blade');
            wylosowanyZestawCzesci.rachet = losujCzescZPulli('rachet');
            if (wylosowanyZestawCzesci.rachet) {
                if (String(wylosowanyZestawCzesci.rachet.id) === "205" || wylosowanyZestawCzesci.rachet.integrujeBit === true) {
                    wylosowanoSpecjalnyRatchet = true; wylosowanyZestawCzesci.bit = null;
                } else { wylosowanyZestawCzesci.bit = losujCzescZPulli('bit'); }
            } else { wylosowanyZestawCzesci.bit = null; czyZestawKompletny = false; }
            if (!wylosowanyZestawCzesci.cx_lock_chip || !wylosowanyZestawCzesci.cx_main_blade || !wylosowanyZestawCzesci.cx_assist_blade || !wylosowanyZestawCzesci.rachet || (!wylosowanoSpecjalnyRatchet && !wylosowanyZestawCzesci.bit && wylosowanyZestawCzesci.rachet)) {
                czyZestawKompletny = false;
            }
        }

        if (czyZestawKompletny) {
            const czesciDoStatystyk = {};
            for (const key in wylosowanyZestawCzesci) {
                if (wylosowanyZestawCzesci[key]) {
                    const { _uniqueDragId, ...resztaCzesci } = wylosowanyZestawCzesci[key];
                    czesciDoStatystyk[key] = resztaCzesci;
                } else { czesciDoStatystyk[key] = null; }
            }

            const statystykiZestawu = obliczSumeStatystykZestawu(czesciDoStatystyk, wybranaSeria);
            const idUnikalnyZestawu = `wylosowany-${Date.now()}-${i}-${Math.random().toString(16).slice(2)}`;
            const pelnyZestaw = { idZestawu: idUnikalnyZestawu, seria: wybranaSeria, czesci: czesciDoStatystyk, statystyki: statystykiZestawu };
            ostatnioWylosowaneZestawyGlobalnie.push(pelnyZestaw);
            const kartaHTML = generujHTMLDlaKartyZestawu(pelnyZestaw, i);
            const tempDiv = document.createElement('div'); tempDiv.innerHTML = kartaHTML.trim();
            wylosowaneZestawyFragment.appendChild(tempDiv.firstChild);
        } else {
            showNotification(`Nie udało się wylosować kompletu dla zestawu #${i + 1}.`, 3500, 'warning');
        }
    }

    if (wylosowaneZestawyFragment.childNodes.length > 0) {
        wynikiDivGenerator.appendChild(wylosowaneZestawyFragment);
        showNotification(`Wylosowano ${ostatnioWylosowaneZestawyGlobalnie.length} zestaw(ów)!`, 2500, 'success');
        const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
        if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'block';
    } else if (iloscZestawowDoWylosowania > 0) {
        wynikiDivGenerator.innerHTML = '<div class="card"><p>Nie udało się wylosować żadnego kompletnego zestawu.</p></div>';
        if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
        if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'none';
    }
}

// =================================
// Zapisywanie Wylosowanych Zestawów
// =================================
function saveCurrentGeneratedDeck() {
    if (!ostatnioWylosowaneZestawyGlobalnie || ostatnioWylosowaneZestawyGlobalnie.length === 0) {
        showNotification("Brak wylosowanych zestawów do zapisania jako deck.", 3000, 'warning'); return;
    }
    // Domyślnie zapisujemy pierwszy wylosowany zestaw jako deck jednosetowy
    const zestawDoZapisu = ostatnioWylosowaneZestawyGlobalnie[0]; 
    if (!zestawDoZapisu || !zestawDoZapisu.czesci || !zestawDoZapisu.seria) {
        showNotification("Błąd: Dane wylosowanego zestawu są niekompletne.", 3000, 'error'); return;
    }

    const nazwaInput = document.getElementById('nazwa-glownego-decku');
    let nazwaDecku = `Wylosowany ${zestawDoZapisu.seria.toUpperCase().replace('_','/')} ${new Date().toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' })}`;
    if (nazwaInput && nazwaInput.value.trim() !== '') nazwaDecku = nazwaInput.value.trim();

    const pojedynczyZestawKonfiguracja = { 
        seria: zestawDoZapisu.seria,
        statystykiObliczone: zestawDoZapisu.statystyki 
    };

    if (zestawDoZapisu.seria === 'bx_ux') {
        pojedynczyZestawKonfiguracja.bladeId = zestawDoZapisu.czesci.blade?.id || null;
        pojedynczyZestawKonfiguracja.ratchetId = zestawDoZapisu.czesci.rachet?.id || null;
        pojedynczyZestawKonfiguracja.bitId = zestawDoZapisu.czesci.bit?.id || null;
    } else if (zestawDoZapisu.seria === 'cx') {
        pojedynczyZestawKonfiguracja.cx_lock_chipId = zestawDoZapisu.czesci.cx_lock_chip?.id || null;
        pojedynczyZestawKonfiguracja.cx_main_bladeId = zestawDoZapisu.czesci.cx_main_blade?.id || null;
        pojedynczyZestawKonfiguracja.cx_assist_bladeId = zestawDoZapisu.czesci.cx_assist_blade?.id || null;
        pojedynczyZestawKonfiguracja.ratchetId = zestawDoZapisu.czesci.rachet?.id || null; // Rachet i Bit są też w CX
        pojedynczyZestawKonfiguracja.bitId = zestawDoZapisu.czesci.bit?.id || null;
    } else { showNotification("Błąd: Nieznana seria wylosowanego zestawu.", 3000, 'error'); return; }

    const nowyDeck = {
        id: `deck_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,
        name: nazwaDecku, 
        timestamp: Date.now(), 
        lastModified: Date.now(),
        sets: [pojedynczyZestawKonfiguracja] // Deck składa się z jednego, wylosowanego zestawu
    };

    const zapisaneDecki = getSavedDecks();
    zapisaneDecki.push(nowyDeck);
    setSavedDecks(zapisaneDecki);
    showNotification(`Deck "${nowyDeck.name}" (z jednego zestawu) zapisany!`, 3000, 'success');
    if (nazwaInput) nazwaInput.value = ''; // Czyścimy pole nazwy po zapisie
    
    // Opcjonalnie: Zaktualizuj przycisk zapisu, aby pokazać, że zapisano
    const zapiszGlownyButton = document.querySelector('#zapisz-glowny-zestaw-controls button');
    if(zapiszGlownyButton) {
        zapiszGlownyButton.textContent = 'Zapisano!'; 
        zapiszGlownyButton.disabled = true;
        setTimeout(() => { 
            zapiszGlownyButton.textContent = 'Zapisz Ten Wylosowany Zestaw'; 
            zapiszGlownyButton.disabled = false; 
        }, 2500);
    }
}

// =================================
// Drag and Drop Deck Builder - Funkcje Renderujące
// =================================

    function renderDeckBuilderAndParts() {
        console.log("renderDeckBuilderAndParts (tabs) wywołane. Aktywny zestaw index:", currentlyActiveSetIndexInBuilder, "Dane:", JSON.parse(JSON.stringify(currentDeckBeingBuilt)));
        renderAvailablePartsList();
        renderDeckSetTabs(); // Nowa funkcja do renderowania zakładek
        renderActiveDeckSetSlots(); // Nowa funkcja do renderowania slotów tylko aktywnego zestawu
        
        // Statystyki są teraz aktualizowane w renderActiveDeckSetSlots dla aktywnego zestawu
    }
    
	function renderDeckSetTabs() {
        const tabsContainer = document.getElementById('deck-set-tabs-container');
        if (!tabsContainer) {
            console.error("Kontener zakładek #deck-set-tabs-container nie znaleziony");
            return;
        }
        tabsContainer.innerHTML = ''; // Wyczyść stare zakładki

        for (let i = 0; i < 4; i++) {
            const tabButton = document.createElement('button');
            tabButton.className = 'tab-button';
            tabButton.textContent = `Zestaw ${i + 1}`;
            tabButton.dataset.setIndex = i; // Przechowujemy indeks 0-3

            if (i === currentlyActiveSetIndexInBuilder) {
                tabButton.classList.add('active');
            }

            tabButton.addEventListener('click', (event) => {
                const newActiveIndex = parseInt(event.currentTarget.dataset.setIndex);
                if (newActiveIndex !== currentlyActiveSetIndexInBuilder) {
                    currentlyActiveSetIndexInBuilder = newActiveIndex;
                    renderDeckBuilderAndParts(); // Prerenderuj wszystko, aby odświeżyć zakładki i sloty
                }
            });
            tabsContainer.appendChild(tabButton);
        }
    }
    
function renderActiveDeckSetSlots() {
    const activeSlotsContainer = document.getElementById('deck-builder-active-set-slots');
    if (!activeSlotsContainer) {
        console.error("Kontener slotów aktywnego zestawu #deck-builder-active-set-slots nie znaleziony");
        return;
    }
    activeSlotsContainer.innerHTML = '';

    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets || !currentDeckBeingBuilt.sets[currentlyActiveSetIndexInBuilder]) {
        console.warn("currentDeckBeingBuilt lub aktywny zestaw nie jest poprawnie zainicjalizowany.");
        initializeOrResetCurrentDeck();
        if (!currentDeckBeingBuilt.sets[currentlyActiveSetIndexInBuilder]) {
            currentDeckBeingBuilt.sets[currentlyActiveSetIndexInBuilder] = { seria: 'bx_ux', bladeId: null, ratchetId: null, bitId: null, cx_lock_chipId: null, cx_main_bladeId: null, cx_assist_bladeId: null, statystykiObliczone: {} };
        }
        renderDeckSetTabs();
    }

    const setIndex = currentlyActiveSetIndexInBuilder;
    const displaySetNumber = setIndex + 1;
    const setConfig = currentDeckBeingBuilt.sets[setIndex];

    const deckSetCard = document.createElement("div");
    deckSetCard.className = "deck-set card";
    deckSetCard.style.marginBottom = "20px";
    deckSetCard.style.padding = "15px";

    const seriaSelectDiv = document.createElement('div');
    seriaSelectDiv.style.marginBottom = "10px";
    const seriaLabel = document.createElement('label');
    seriaLabel.htmlFor = `deck-seria-${displaySetNumber}`;
    seriaLabel.textContent = `Seria dla Zestawu ${displaySetNumber}: `;
    seriaLabel.style.marginRight = "5px";
    const seriaSelect = document.createElement('select');
    seriaSelect.id = `deck-seria-${displaySetNumber}`;
    seriaSelect.innerHTML = `
        <option value="bx_ux" ${setConfig.seria === 'bx_ux' ? 'selected' : ''}>BX / UX</option>
        <option value="cx" ${setConfig.seria === 'cx' ? 'selected' : ''}>CX</option>
    `;
    seriaSelect.dataset.setIndex = setIndex;
    seriaSelect.addEventListener('change', handleSeriaChangeForSet);
    seriaSelectDiv.appendChild(seriaLabel);
    seriaSelectDiv.appendChild(seriaSelect);
    deckSetCard.appendChild(seriaSelectDiv);

    const partTypes = getPartTypesForSeria(setConfig.seria);
    const magazyn = getMagazyn();

    let jestTurboRatchetWAktywnymZestawie = false;
    if (setConfig.ratchetId) {
        const aktywnyRatchet = magazyn.find(p => p.id === setConfig.ratchetId && p.typ === 'rachet');
        if (aktywnyRatchet && (String(aktywnyRatchet.id) === "205" || aktywnyRatchet.integrujeBit === true)) {
            jestTurboRatchetWAktywnymZestawie = true;
        }
    }

    if (jestTurboRatchetWAktywnymZestawie && setConfig.bitId !== null) {
        setConfig.bitId = null;
    }

    partTypes.forEach(partTypeInfo => {
        const slotDiv = document.createElement('div');
        slotDiv.className = 'deck-part-slot';
        slotDiv.dataset.setIndex = setIndex;
        slotDiv.dataset.slotType = partTypeInfo.type;

        const partIdKey = getPartIdKeyForSlot(partTypeInfo.type, setConfig.seria);
        const partId = partIdKey ? setConfig[partIdKey] : null;

        if (partTypeInfo.type === 'bit' && jestTurboRatchetWAktywnymZestawie) {
            slotDiv.classList.add('slot-disabled-integrated');
            slotDiv.innerHTML = `<span style="font-style: italic; color: #888;">Bit zintegrowany</span>`;
        } else {
            if (partId) {
                const partDetails = magazyn.find(p => p.id === partId);
                if (partDetails) {
                    const trybIndexKey = partIdKey.replace('Id', 'AktywnyTrybIndex');
                    const aktywnyTrybIndex = setConfig[trybIndexKey] || 0;
                    const trybAktywny = (partDetails.maTryby && partDetails.tryby) ? partDetails.tryby[aktywnyTrybIndex] : null;
                    
                    // --- POCZĄTEK POPRAWKI OBRAZKA ---
                    const obrazek = trybAktywny?.img || partDetails.img;
                    let slotImageHTML = obrazek ? `<img src="${obrazek}" alt="${partDetails.nazwa}" style="width: 50px; height: 50px; object-fit: contain; border-radius: 4px;">` : `<div class="dnd-slot-placeholder">Brak<br>Obr.</div>`;
                    // --- KONIEC POPRAWKI OBRAZKA ---

                    let modeSwitcherHTML = '';
                    if (partDetails.maTryby && Array.isArray(partDetails.tryby) && partDetails.tryby.length > 1) {
                        const nazwaAktywnegoTrybu = trybAktywny?.nazwaTrybu || 'Tryb 1';
                        modeSwitcherHTML = `
                            <button class="mode-switch-btn" onclick="przelaczTrybCzesci(${setIndex}, '${partTypeInfo.type}')" title="Zmień tryb: ${nazwaAktywnegoTrybu}">
                                ${nazwaAktywnegoTrybu} 🔄
                            </button>
                        `;
                    }

                    slotDiv.innerHTML = `
                        <div class="part-info-container">
                            ${slotImageHTML}
                            <span class="part-name">${partDetails.nazwa}</span>
                        </div>
                        <div class="part-controls">
                            ${modeSwitcherHTML}
                            <button class="remove-part-btn" title="Usuń część">&times;</button>
                        </div>
                    `;
                    slotDiv.classList.add('filled');
                    slotDiv.dataset.currentPartId = partId;
                    slotDiv.querySelector('.remove-part-btn').addEventListener('click', () => removePartFromSlot(setIndex, partTypeInfo.type));
                } else {
                    slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj (ID: ${partId} nie znalezione)</span>`;
                    if (partIdKey) setConfig[partIdKey] = null;
                }
            } else {
                slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj</span>`;
            }

            slotDiv.addEventListener('dragover', handleDragOver);
            slotDiv.addEventListener('dragenter', handleDragEnter);
            slotDiv.addEventListener('dragleave', handleDragLeave);
            slotDiv.addEventListener('drop', handleDrop);
        }
        deckSetCard.appendChild(slotDiv);
    });

    const statsDiv = document.createElement('div');
    statsDiv.id = `deck-stats-${displaySetNumber}`;
    statsDiv.className = "deck-stats";
    statsDiv.style.cssText = "margin-top: 15px; font-weight: normal; font-size: 0.9em; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 6px; text-align: left; line-height: 1.5;";
    deckSetCard.appendChild(statsDiv);

    activeSlotsContainer.appendChild(deckSetCard);
    updateDeckStatsForSetInBuilder(displaySetNumber);
}

function przelaczTrybCzesci(setIndex, partType) {
    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets[setIndex]) return;
    const set = currentDeckBeingBuilt.sets[setIndex];

    const partId = set[`${partType}Id`];
    if (!partId) return;

    // Pobierz dane części z magazynu
    const magazyn = getMagazyn();
    const part = magazyn.find(c => c.id === partId);
    if (!part || !part.maTryby) return;

    // Ustal nazwę klucza w decku (np. bladeAktywnyTrybIndex)
    const keyIndex = `${partType}AktywnyTrybIndex`;

    // Zmień tryb w decku
    set[keyIndex] = ((set[keyIndex] || 0) + 1) % part.tryby.length;

    // Zmień też w magazynie, żeby było spójnie
    const idxMagazyn = magazyn.findIndex(c => c.id === partId);
    if (idxMagazyn !== -1) {
        magazyn[idxMagazyn].aktywnyTrybIndex = set[keyIndex];
        setMagazyn(magazyn);
    }

    renderDeckBuilderAndParts(); // odśwież widok slotów
}

function przelaczTrybMagazynu(idCzesci) {
    const magazyn = getMagazyn();
    const idx = magazyn.findIndex(c => c.id === idCzesci);
    if (idx === -1) return;

    const czesc = magazyn[idx];
    if (!czesc.maTryby || !czesc.tryby || czesc.tryby.length < 2) return;

    czesc.aktywnyTrybIndex = ((czesc.aktywnyTrybIndex || 0) + 1) % czesc.tryby.length;
    setMagazyn(magazyn);
    wyswietlMagazyn(); // odśwież UI
}
    
	
function renderAvailablePartsList() {
    const partsListContainer = document.getElementById('parts-list-for-dnd');
    if (!partsListContainer) { return; }
    partsListContainer.innerHTML = '';
    const magazyn = getMagazyn();
    const filterValue = document.getElementById('dndPartTypeFilter')?.value;

    if (!filterValue) {
        partsListContainer.innerHTML = '<p style="font-size:0.9em; color:#999; text-align:center;">Wybierz typ części.</p>';
        return;
    }

    const czesciDoWyswietlenia = magazyn
        .filter(czesc => czesc.ilosc > 0 && czesc.typ === filterValue)
        .sort((a, b) => a.nazwa.localeCompare(b.nazwa));

    if (czesciDoWyswietlenia.length === 0) {
        partsListContainer.innerHTML = `<p style="font-size:0.9em; color:#999; text-align:center;">Brak części tego typu.</p>`;
        return;
    }

    czesciDoWyswietlenia.forEach(czesc => {
        const aktywnyIndex = czesc.aktywnyTrybIndex || 0;
        const trybAktywny = (czesc.maTryby && czesc.tryby) ? czesc.tryby[aktywnyIndex] : null;

        const obrazek = trybAktywny?.img || czesc.img;
        const nazwa = trybAktywny ? `${czesc.nazwa} (${trybAktywny.nazwaTrybu})` : czesc.nazwa;

        const partItem = document.createElement('div');
        partItem.className = 'available-part-item';
        partItem.draggable = true;
        // Ważne: Przekazujemy dane aktywnego trybu, jeśli istnieje
        partItem.dataset.partData = JSON.stringify({
            id: czesc.id,
            typ: czesc.typ,
            nazwa: nazwa,
            img: obrazek,
            aktywnyTrybIndex: aktywnyIndex // Przekazujemy indeks trybu
        });

        let modeSwitcherHTML = '';
        if (czesc.maTryby && czesc.tryby.length > 1) {
            modeSwitcherHTML = `
                <button
                    class="mode-switch-btn"
                    style="margin-left: auto; flex-shrink: 0;"
                    onclick="event.stopPropagation(); przelaczTrybNaLiscie('${czesc.id}', event)">
                    Zmień Tryb 🔄
                </button>
            `;
        }

        partItem.innerHTML = `
            <img src="${obrazek}" alt="${nazwa}" style="width: 40px; height: 40px; object-fit: contain; border-radius: 4px; flex-shrink: 0;">
            <span style="flex-grow: 1; text-align: left;">${nazwa} (x${czesc.ilosc})</span>
            ${modeSwitcherHTML}
        `;

        partItem.addEventListener('dragstart', handleDragStart);
        partItem.addEventListener('dragend', handleDragEnd);
        partsListContainer.appendChild(partItem);
    });
}

function przelaczTrybNaLiscie(idCzesci, event) {
    // Zatrzymuje "bąbelkowanie" eventu, aby kliknięcie nie aktywowało przeciągania
    event.stopPropagation();

    const magazyn = getMagazyn();
    const idx = magazyn.findIndex(c => c.id === idCzesci);
    if (idx === -1) return;

    const czesc = magazyn[idx];
    if (!czesc.maTryby || !czesc.tryby || czesc.tryby.length < 2) return;

    // Zmień indeks trybu
    czesc.aktywnyTrybIndex = ((czesc.aktywnyTrybIndex || 0) + 1) % czesc.tryby.length;
    setMagazyn(magazyn);

    // Prerenderuj listę części, aby pokazać zmianę
    renderAvailablePartsList();
}


function renderDeckSlots() {
    const slotsContainer = document.getElementById('deck-builder-slots');
    if (!slotsContainer) { console.error("Kontener #deck-builder-slots nie znaleziony"); return; }
    slotsContainer.innerHTML = ''; // Czyścimy przed renderowaniem

    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets || currentDeckBeingBuilt.sets.length === 0) {
        console.warn("currentDeckBeingBuilt nie jest poprawnie zainicjalizowany do renderowania slotów.");
        initializeOrResetCurrentDeck(); // Spróbuj zainicjalizować
    }


    for (let i = 0; i < 4; i++) {
        const setIndex = i; // Index w tablicy (0-3)
        const displaySetNumber = i + 1; // Numer wyświetlany użytkownikowi (1-4)
        const setConfig = currentDeckBeingBuilt.sets[setIndex]; // Pobieramy konfigurację zestawu

        if (!setConfig) {
            console.error(`Brak konfiguracji dla zestawu o indeksie ${setIndex} w currentDeckBeingBuilt.`);
            continue; 
        }

        const deckSetCard = document.createElement("div");
        deckSetCard.className = "deck-set card"; // Używamy klasy .card dla spójności
        deckSetCard.style.marginBottom = "20px";
        deckSetCard.style.padding = "15px";

        const heading = document.createElement('h3');
        heading.textContent = `Zestaw ${displaySetNumber}`;
        deckSetCard.appendChild(heading);

        const seriaSelectDiv = document.createElement('div');
        seriaSelectDiv.style.marginBottom = "10px";
        const seriaLabel = document.createElement('label');
        seriaLabel.htmlFor = `deck-seria-${displaySetNumber}`;
        seriaLabel.textContent = `Seria: `;
        seriaLabel.style.marginRight = "5px";
        const seriaSelect = document.createElement('select');
        seriaSelect.id = `deck-seria-${displaySetNumber}`;
        seriaSelect.innerHTML = `
            <option value="bx_ux" ${setConfig.seria === 'bx_ux' ? 'selected' : ''}>BX / UX</option>
            <option value="cx" ${setConfig.seria === 'cx' ? 'selected' : ''}>CX</option>
        `;
        seriaSelect.dataset.setIndex = setIndex; // Przechowujemy index tablicy
        seriaSelect.addEventListener('change', handleSeriaChangeForSet);
        
        seriaSelectDiv.appendChild(seriaLabel);
        seriaSelectDiv.appendChild(seriaSelect);
        deckSetCard.appendChild(seriaSelectDiv);

        const partTypes = getPartTypesForSeria(setConfig.seria);
        partTypes.forEach(partType => {
            const slotDiv = document.createElement('div');
            slotDiv.className = 'deck-part-slot';
            slotDiv.dataset.setIndex = setIndex; // Index tablicy 0-3
            slotDiv.dataset.slotType = partType.type; // np. 'blade', 'cx-main-blade'
            // Placeholder tekstowy
            slotDiv.innerHTML = `<span>Upuść ${partType.label} tutaj</span>`;
            
            slotDiv.addEventListener('dragover', handleDragOver);
            slotDiv.addEventListener('dragenter', handleDragEnter);
            slotDiv.addEventListener('dragleave', handleDragLeave);
            slotDiv.addEventListener('drop', handleDrop);
            deckSetCard.appendChild(slotDiv);
        });
        
        const statsDiv = document.createElement('div');
        statsDiv.id = `deck-stats-${displaySetNumber}`; // ID dla aktualizacji statystyk
        statsDiv.className = "deck-stats"; // Możesz dodać style dla .deck-stats
        statsDiv.style.cssText = "margin-top: 15px; font-weight: normal; font-size: 0.9em; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 6px; text-align: left; line-height: 1.5;";
        deckSetCard.appendChild(statsDiv);
        
        slotsContainer.appendChild(deckSetCard);
    }
}

function getPartTypesForSeria(seria) {
    if (seria === 'cx') {
        return [
            { type: 'cx_lock_chip', label: 'Lock Chip' },
            { type: 'cx_main_blade', label: 'Main Blade' },
            { type: 'cx_assist_blade', label: 'Assist Blade' },
            { type: 'rachet', label: 'Ratchet (CX)' },
            { type: 'bit', label: 'Bit (CX)' }
        ];
    }
    // Domyślnie BX/UX
    return [
        { type: 'blade', label: 'Blade' },
        { type: 'rachet', label: 'Ratchet (BX/UX)' },
        { type: 'bit', label: 'Bit (BX/UX)' }
    ];
}

function handleSeriaChangeForSet(event) {
        const setIndex = parseInt(event.target.dataset.setIndex); // To jest indeks 0-3
        const nowaSeria = event.target.value;
        
        if (isNaN(setIndex) || !currentDeckBeingBuilt.sets[setIndex]) return;

        currentDeckBeingBuilt.sets[setIndex].seria = nowaSeria;

        // Wyczyść ID części poprzedniej serii (lub wszystkie dla bezpieczeństwa)
        if (nowaSeria === 'bx_ux') {
            currentDeckBeingBuilt.sets[setIndex].cx_lock_chipId = null;
            currentDeckBeingBuilt.sets[setIndex].cx_main_bladeId = null;
            currentDeckBeingBuilt.sets[setIndex].cx_assist_bladeId = null;
        } else if (nowaSeria === 'cx') {
            currentDeckBeingBuilt.sets[setIndex].bladeId = null;
        }
        // Można rozważyć czyszczenie ratchetId i bitId, jeśli chcesz wymusić ponowny wybór
        // currentDeckBeingBuilt.sets[setIndex].ratchetId = null;
        // currentDeckBeingBuilt.sets[setIndex].bitId = null;

        // Prerenderuj tylko sloty aktywnego zestawu i zaktualizuj jego statystyki
        renderActiveDeckSetSlots(); 
        // updateDeckStatsForSetInBuilder jest już wywoływane w renderActiveDeckSetSlots
        console.log(`Zmieniono serię dla zestawu ${setIndex + 1} na ${nowaSeria}.`);
    }
    

function fillDeckSlotsFromCurrentBuild() {
    const magazyn = getMagazyn();
    if (!currentDeckBeingBuilt || !currentDeckBeingBuilt.sets) {
        console.warn("Próba wypełnienia slotów, ale currentDeckBeingBuilt nie jest gotowy.");
        return;
    }

    currentDeckBeingBuilt.sets.forEach((set, setIndex) => {
        if (!set) { // Jeśli zestaw jest null (co nie powinno się zdarzyć przy dobrej inicjalizacji)
            console.warn(`Zestaw o indeksie ${setIndex} jest null w fillDeckSlotsFromCurrentBuild.`);
            // Można by tu spróbować zainicjalizować ten konkretny zestaw, jeśli to konieczne
            // currentDeckBeingBuilt.sets[setIndex] = initializeOrResetCurrentDeck().sets[0]; // Przykładowo
            return;
        }

        const partTypes = getPartTypesForSeria(set.seria);
        partTypes.forEach(partTypeInfo => {
            const slotSelector = `.deck-part-slot[data-set-index="${setIndex}"][data-slot-type="${partTypeInfo.type}"]`;
            const slotDiv = document.querySelector(slotSelector);
            if (!slotDiv) {
                console.warn(`Nie znaleziono slotu w DOM: ${slotSelector}`);
                return;
            }

            let partId = null;
            const partIdKey = getPartIdKeyForSlot(partTypeInfo.type, set.seria);
            if (partIdKey && set.hasOwnProperty(partIdKey)) {
                partId = set[partIdKey];
            }
            
            if (partId) {
                const partDetails = magazyn.find(p => p.id === partId);
                if (partDetails) {
                    let slotImageHTML;
                    if (partDetails.img && partDetails.img.trim() !== "") {
                        slotImageHTML = `<img src="${partDetails.img}" alt="${partDetails.nazwa}" style="width: 50px; height: 50px; object-fit: contain; border-radius: 4px;">`;
                    } else {
                        slotImageHTML = `<div class="dnd-slot-placeholder">Brak<br>Obr.</div>`;
                    }

                    slotDiv.innerHTML = `
                        <div class="part-info-container">
                            ${slotImageHTML}
                            <span class="part-name">${partDetails.nazwa}</span>
                        </div>
                        <button class="remove-part-btn" title="Usuń część">&times;</button>
                    `;
                    slotDiv.classList.add('filled');
                    slotDiv.dataset.currentPartId = partId;
                    slotDiv.querySelector('.remove-part-btn').addEventListener('click', () => removePartFromSlot(setIndex, partTypeInfo.type));
                } else {
                    slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj (ID: ${partId} nie znalezione)</span>`;
                    slotDiv.classList.remove('filled');
                    delete slotDiv.dataset.currentPartId;
                    // Opcjonalnie: wyczyść ID w modelu, jeśli część nie istnieje w magazynie
                    // if (partIdKey) currentDeckBeingBuilt.sets[setIndex][partIdKey] = null;
                }
            } else {
                slotDiv.innerHTML = `<span>Upuść ${partTypeInfo.label} tutaj</span>`;
                slotDiv.classList.remove('filled');
                delete slotDiv.dataset.currentPartId;
            }
        });
    });
}


// =================================
// Drag and Drop - Event Handlers
// =================================
let draggedItemData = null; // Przechowuje dane przeciąganego elementu

function handleDragStart(event) {
    try {
        draggedItemData = JSON.parse(event.target.dataset.partData);
        event.dataTransfer.setData("text/plain", draggedItemData.id); // Potrzebne dla Firefoxa
        event.dataTransfer.effectAllowed = "move";
        event.target.classList.add('dragging');
        console.log("DragStart:", draggedItemData);
    } catch (e) {
        console.error("Błąd w handleDragStart podczas parsowania JSON:", e, "Dane:", event.target.dataset.partData);
        draggedItemData = null;
        event.preventDefault(); // Anuluj przeciąganie, jeśli dane są złe
    }
}

function handleDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    event.currentTarget.classList.add('drag-over-target');
}

function handleDragEnter(event) {
    event.preventDefault();
    event.currentTarget.classList.add('drag-over-target');
}

function handleDragLeave(event) {
    event.currentTarget.classList.remove('drag-over-target');
}
function handleDrop(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over-target');

    if (!draggedItemData) { return; }

    const dropZone = event.currentTarget;
    const setArrayIndex = parseInt(dropZone.dataset.setIndex);
    const slotType = dropZone.dataset.slotType; // np. 'cx_main_blade' (z podkreślnikiem)
    
    if (isNaN(setArrayIndex) || !currentDeckBeingBuilt.sets[setArrayIndex]) {
        draggedItemData = null;
        return;
    }

    const targetSet = currentDeckBeingBuilt.sets[setArrayIndex];
    const partActualType = draggedItemData.typ; // np. 'cx-main-blade' (z myślnikiem)

    // "Tłumacz", który ujednolica zapis z `_` i `-`
    const normalizedSlotType = slotType.replace(/_/g, '-');

    // 1. Walidacja typu:
    if (normalizedSlotType !== partActualType) {
        showNotification(`Nie można umieścić części typu "${partActualType}" w slocie na "${slotType}".`, 4000, 'warning');
        draggedItemData = null;
        return;
    }

    // --- POCZĄTEK OSTATECZNEJ POPRAWKI ---
    // Używamy ZNORMALIZOWANEGO slotType (z myślnikiem), aby poprawnie odwołać się do funkcji.
    const partIdKey = getPartIdKeyForSlot(normalizedSlotType, targetSet.seria);
    // --- KONIEC OSTATECZNEJ POPRAWKI ---

    if (!partIdKey) {
        console.error(`Błąd krytyczny: Nie znaleziono klucza ID dla znormalizowanego slotu "${normalizedSlotType}"`);
        draggedItemData = null;
        return;
    }

    // 2. Walidacja duplikatów
    const newPartId = draggedItemData.id;
    let isAlreadyInDeck = false;
    currentDeckBeingBuilt.sets.forEach((set, idx) => {
        Object.keys(set).forEach(key => {
            if (key.endsWith('Id') && set[key] === newPartId) {
                if (!(idx === setArrayIndex && key === partIdKey)) {
                    isAlreadyInDeck = true;
                }
            }
        });
    });

    if (isAlreadyInDeck) {
        showNotification(`Część "${draggedItemData.nazwa}" jest już użyta w tym decku.`, 3500, 'warning');
        draggedItemData = null;
        return;
    }
    
    // 3. ZAPIS DANYCH
    targetSet[partIdKey] = draggedItemData.id;
    const trybIndexKey = partIdKey.replace('Id', 'AktywnyTrybIndex');
    if (targetSet.hasOwnProperty(trybIndexKey)) {
        targetSet[trybIndexKey] = draggedItemData.aktywnyTrybIndex || 0;
    }

    console.log(`Zaktualizowano zestaw ${setArrayIndex + 1} po dropie:`, JSON.parse(JSON.stringify(targetSet)));

    // 4. Odświeżenie widoku
    renderActiveDeckSetSlots();
    
    draggedItemData = null;
}


function handleDragEnd(event) {
    event.target.classList.remove('dragging');
    draggedItemData = null; // Zawsze resetuj na końcu przeciągania
}

function getPartIdKeyForSlot(slotType, seria) {
    // Usunięto wszystkie `if`, zastąpione prostą mapą, która jest niezawodna.
    const keyMap = {
        'blade': 'bladeId',
        'rachet': 'ratchetId',
        'bit': 'bitId',
        'cx-lock-chip': 'cx_lock_chipId',
        'cx-main-blade': 'cx_main_bladeId',
        'cx-assist-blade': 'cx_assist_bladeId'
    };

    // Normalizujemy wejściowy slotType, aby upewnić się, że nie ma w nim podkreślników.
    const normalizedSlotType = String(slotType).replace(/_/g, '-');
    
    // Zwracamy klucz z mapy. Jeśli nie zostanie znaleziony, zwróci `undefined`, co jest ok.
    return keyMap[normalizedSlotType] || null;
}


function removePartFromSlot(setArrayIndex, slotType) {
    if (isNaN(setArrayIndex) || !currentDeckBeingBuilt || !currentDeckBeingBuilt.sets[setArrayIndex]) {
        console.error("Błąd w removePartFromSlot: Nieprawidłowy indeks zestawu lub brak danych.");
        return;
    }
    
    const targetSet = currentDeckBeingBuilt.sets[setArrayIndex];
    const partIdKey = getPartIdKeyForSlot(slotType, targetSet.seria);

    if (partIdKey && targetSet.hasOwnProperty(partIdKey) && targetSet[partIdKey] !== null) {
        console.log(`Usuwanie części (ID: ${targetSet[partIdKey]}) ze slotu ${slotType} w zestawie ${setArrayIndex + 1}`);
        targetSet[partIdKey] = null; // Usuń ID części z modelu

        // Po usunięciu części (zwłaszcza jeśli to był Ratchet, który mógł wpływać na stan slotu Bit),
        // odśwież całe sloty aktywnego zestawu.
        // renderActiveDeckSetSlots zajmie się aktualizacją UI i statystyk.
        renderActiveDeckSetSlots(); 
        
        // Nie ma potrzeby wywoływać tu updateDeckStatsForSetInBuilder,
        // ponieważ renderActiveDeckSetSlots już to robi.
    } else {
        console.warn(`Próba usunięcia części ze slotu ${slotType} w zestawie ${setArrayIndex + 1}, ale slot był już pusty lub klucz nieprawidłowy.`);
    }
}

// =================================
// Deck Builder - Statystyki i Zapis
// =================================
function updateDeckStatsForSetInBuilder(displaySetNumber) {
    const setArrayIndex = displaySetNumber - 1;
    if (!currentDeckBeingBuilt.sets[setArrayIndex]) return;

    const setConfig = currentDeckBeingBuilt.sets[setArrayIndex];
    const magazyn = getMagazyn();

    const getPartDetailsWithMode = (partId, activeModeIndexKey) => {
        if (!partId) return null;
        const part = magazyn.find(p => p.id === partId);
        if (!part) return null;

        const activeModeIndex = setConfig[activeModeIndexKey] || 0;

        if (part.maTryby && Array.isArray(part.tryby) && part.tryby[activeModeIndex]) {
            const basePart = { ...part };
            delete basePart.tryby;
            const activeModeData = part.tryby[activeModeIndex];
            return { ...basePart, ...activeModeData };
        }
        return part;
    };

    let czesciDoObliczen = {};
    if (setConfig.seria === 'bx_ux') {
        czesciDoObliczen.blade = getPartDetailsWithMode(setConfig.bladeId, 'bladeAktywnyTrybIndex');
        czesciDoObliczen.rachet = getPartDetailsWithMode(setConfig.ratchetId, 'ratchetAktywnyTrybIndex');
        czesciDoObliczen.bit = getPartDetailsWithMode(setConfig.bitId, 'bitAktywnyTrybIndex');
    } else if (setConfig.seria === 'cx') {
        czesciDoObliczen.cx_lock_chip = getPartDetailsWithMode(setConfig.cx_lock_chipId, 'cx_lock_chipAktywnyTrybIndex');
        czesciDoObliczen.cx_main_blade = getPartDetailsWithMode(setConfig.cx_main_bladeId, 'cx_main_bladeAktywnyTrybIndex');
        czesciDoObliczen.cx_assist_blade = getPartDetailsWithMode(setConfig.cx_assist_bladeId, 'cx_assist_bladeAktywnyTrybIndex');
        czesciDoObliczen.rachet = getPartDetailsWithMode(setConfig.ratchetId, 'ratchetAktywnyTrybIndex');
        czesciDoObliczen.bit = getPartDetailsWithMode(setConfig.bitId, 'bitAktywnyTrybIndex');
    }

    const obliczoneStatystyki = obliczSumeStatystykZestawu(czesciDoObliczen, setConfig.seria);
    currentDeckBeingBuilt.sets[setArrayIndex].statystykiObliczone = obliczoneStatystyki;

    const statsDiv = document.getElementById(`deck-stats-${displaySetNumber}`);
    if (statsDiv) {
        let statsTextHTML = ``;
        statsTextHTML += `<b>SUMA (${setConfig.seria.toUpperCase().replace('_','/')}):</b> `;
        statsTextHTML += `ATK: ${obliczoneStatystyki.ATK}, DEF: ${obliczoneStatystyki.DEF}, STM: ${obliczoneStatystyki.STM}, Waga: ${obliczoneStatystyki.WAGA}g`;
        const jestSpecjalnyRatchet = czesciDoObliczen.rachet && (String(czesciDoObliczen.rachet.id) === "205" || czesciDoObliczen.rachet.integrujeBit === true);
        if ((setConfig.seria === 'bx_ux' && !jestSpecjalnyRatchet && czesciDoObliczen.bit) || (setConfig.seria === 'cx' && !jestSpecjalnyRatchet && czesciDoObliczen.bit) || jestSpecjalnyRatchet) {
            if (obliczoneStatystyki.DASH !== 0) statsTextHTML += `, DASH: ${obliczoneStatystyki.DASH}`;
            if (obliczoneStatystyki.B_RES !== 0) statsTextHTML += `, B-RES: ${obliczoneStatystyki.B_RES}`;
        }
        if (setConfig.seria === 'cx' && obliczoneStatystyki.CX_LC_WYTRZ !== 0) {
            statsTextHTML += `, LC-W: ${obliczoneStatystyki.CX_LC_WYTRZ}`;
        }
        statsDiv.innerHTML = statsTextHTML;
    }
    return obliczoneStatystyki;
}

function saveCurrentDeck() {
    const deckNameInput = document.getElementById('deckName');
    const deckName = deckNameInput ? deckNameInput.value.trim() : (currentDeckBeingBuilt.name || '');

    if (!deckName && !currentEditingDeckId) {
        showNotification("Wpisz nazwę dla nowego decku.", 3000, 'warning');
        deckNameInput?.focus();
        return;
    }

    const nonEmptySets = currentDeckBeingBuilt.sets.filter(set => {
        if (!set) return false;
        return set.bladeId || set.ratchetId || set.bitId || set.cx_lock_chipId || set.cx_main_bladeId || set.cx_assist_bladeId;
    });

    if (nonEmptySets.length === 0 && !currentEditingDeckId) {
        showNotification("Nie skonfigurowano żadnych części w żadnym zestawie.", 3000, 'warning');
        return;
    }

    // Walidacja duplikatów i Clock Mirage (pozostaje bez zmian, bo jest poprawna)
    const magazyn = getMagazyn();
    const allPartIdsInDeck = new Set();
    let duplicateFound = false;

    for (const set of nonEmptySets) {
        if (set.seria === 'bx_ux' && set.bladeId === ID_CLOCK_MIRAGE && set.ratchetId) {
            const ratchetDetails = magazyn.find(p => p.id === set.ratchetId);
            if (ratchetDetails && !(ratchetDetails.nazwa.match(/-\d*5$/) || ratchetDetails.nazwa.match(/^M-\d*5$/))) {
                showNotification(`Błąd w zestawie: Clock Mirage jest połączony z niekompatybilnym Ratchetem.`, 6000, 'error');
                return;
            }
        }
        const partIdsInSet = [set.bladeId, set.ratchetId, set.bitId, set.cx_lock_chipId, set.cx_main_bladeId, set.cx_assist_bladeId].filter(Boolean);
        for (const partId of partIdsInSet) {
            if (allPartIdsInDeck.has(partId)) {
                duplicateFound = true;
                break;
            }
            allPartIdsInDeck.add(partId);
        }
        if (duplicateFound) break;
    }
    if (duplicateFound) {
        showNotification(`Jedna z części jest użyta więcej niż raz w tym decku. Popraw konfigurację.`, 4000, 'error');
        return;
    }
    
    // --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
    
    // Tworzymy nową, czystą wersję decku do zapisu.
    // Używamy `map`, aby przetworzyć każdy zestaw.
    const setsToSave = nonEmptySets.map(set => {
        // Kopiujemy wszystkie właściwości zestawu, w tym ID części ORAZ `aktywnyTrybIndex`.
        const cleanSet = { ...set };
        
        // Obliczamy i nadpisujemy statystyki, aby były aktualne w momencie zapisu.
        // Znajdujemy indeks tego zestawu w oryginalnym obiekcie `currentDeckBeingBuilt`
        const originalIndex = currentDeckBeingBuilt.sets.findIndex(s => s === set);
        if (originalIndex !== -1) {
            cleanSet.statystykiObliczone = updateDeckStatsForSetInBuilder(originalIndex + 1);
        }
        
        return cleanSet;
    });
    // --- KONIEC KLUCZOWEJ POPRAWKI ---

    let savedDecks = getSavedDecks();
    const finalDeckName = deckName || (currentEditingDeckId ? savedDecks.find(d => d.id === currentEditingDeckId)?.name : `Deck ${new Date().toLocaleTimeString('pl-PL')}`);

    const deckToSave = {
        id: currentEditingDeckId || currentDeckBeingBuilt.id,
        name: finalDeckName,
        sets: setsToSave, // Zapisujemy nową, czystą tablicę zestawów
        timestamp: currentEditingDeckId ? (savedDecks.find(d => d.id === currentEditingDeckId)?.timestamp || Date.now()) : Date.now(),
        lastModified: Date.now()
    };
    
    // Logika aktualizacji lub dodawania nowego decku (bez zmian)
    if (currentEditingDeckId) {
        const deckIndex = savedDecks.findIndex(d => d.id === currentEditingDeckId);
        if (deckIndex > -1) {
            savedDecks[deckIndex] = deckToSave;
            showNotification(`Deck "${finalDeckName}" zaktualizowany!`, 3000, 'success');
        } else {
            savedDecks.push(deckToSave);
            showNotification(`Deck "${finalDeckName}" zapisany (jako nowy)!`, 3000, 'success');
        }
    } else {
        savedDecks.push(deckToSave);
        showNotification(`Deck "${finalDeckName}" zapisany!`, 3000, 'success');
    }

    setSavedDecks(savedDecks);
    clearCurrentDeckForBuilder();
}


// =================================
// Wyświetlanie, Edycja, Usuwanie Zapisanych Decków
// =================================
function displaySavedDecks() {
    const container = document.getElementById('savedDecksContainer');
    if (!container) { console.error("Błąd: #savedDecksContainer nie istnieje."); return; }
    container.innerHTML = '';
    const savedDecks = getSavedDecks();
    if (!savedDecks || savedDecks.length === 0) {
        container.innerHTML = '<div class="card" style="grid-column: 1 / -1; text-align: center;"><p>Nie masz zapisanych decków.</p></div>';
        return;
    }
    savedDecks.sort((a, b) => (b.lastModified || b.timestamp || 0) - (a.lastModified || a.timestamp || 0));
    const magazynCzesci = getMagazyn();

    savedDecks.forEach(deck => {
        if (!deck || !deck.id || !Array.isArray(deck.sets)) { return; }
        const deckCard = document.createElement('div');
        deckCard.className = 'card saved-deck-card';
        deckCard.dataset.deckId = deck.id;
        let setsHTML = '';

        deck.sets.forEach((set, index) => {
            if (!set) { setsHTML += `<div class="deck-card-set-preview"><p style="color:red;">Błąd danych zestawu ${index + 1}</p></div>`; return; }
            const seriaZestawu = set.seria || 'bx_ux';
            let setImagesHTML = '';
            let setNameParts = [];
            let currentSetStats = set.statystykiObliczone;

            // --- CZYSTA WERSJA FUNKCJI POMOCNICZEJ (BEZ ALERTÓW) ---
            const getPartDetailsAndHTML = (partId, partType, partTypeDefaultName) => {
                const part = partId ? magazynCzesci.find(p => String(p.id) == String(partId)) : null;

                let obrazekDoWyswietlenia = part?.img;
                let nazwaDoWyswietlenia = part?.nazwa;

                if (part && part.maTryby && Array.isArray(part.tryby)) {
                    const partIdKey = getPartIdKeyForSlot(partType, seriaZestawu);
                    const trybIndexKey = partIdKey ? partIdKey.replace('Id', 'AktywnyTrybIndex') : null;
                    const zapisanyIndex = (trybIndexKey && set[trybIndexKey] !== undefined) ? set[trybIndexKey] : 0;
                    const aktywnyTryb = part.tryby[zapisanyIndex];

                    if (aktywnyTryb) {
                        obrazekDoWyswietlenia = aktywnyTryb.img || part.img;
                        nazwaDoWyswietlenia = `${part.nazwa} (${aktywnyTryb.nazwaTrybu})`;
                    }
                }

                const imgHTML = obrazekDoWyswietlenia ?
                    `<img src="${obrazekDoWyswietlenia}" alt="${part?.nazwa || partTypeDefaultName}" class="deck-part-img">` :
                    `<div class="deck-part-placeholder">${partTypeDefaultName.substring(0,3).toUpperCase()}</div>`;
                const nameText = part ? (nazwaDoWyswietlenia || `<i>${partTypeDefaultName} N/A</i>`) : `<i>Brak ${partTypeDefaultName}</i>`;

                return { html: imgHTML, name: nameText, partObj: part };
            };
            // --- KONIEC CZYSTEJ WERSJI ---

            const ratchetWDecku = set.ratchetId ? magazynCzesci.find(p => String(p.id) == String(set.ratchetId)) : null;
            const czySpecjalnyRatchetWDecku = ratchetWDecku && (String(ratchetWDecku.id) === "205" || ratchetWDecku.integrujeBit === true);

            if (seriaZestawu === 'bx_ux') {
                const bladeInfo = getPartDetailsAndHTML(set.bladeId, 'blade', 'Blade');
                const ratchetInfo = getPartDetailsAndHTML(set.ratchetId, 'rachet', 'Ratchet');
                let bitInfo = czySpecjalnyRatchetWDecku && ratchetInfo.partObj ?
                    { html: `<div class="deck-part-placeholder" style="font-size:0.5em; line-height:1.2; padding:5px;" title="Bit zintegrowany w ${ratchetInfo.partObj.nazwa}">BIT<br>INTEG.</div>`, name: `<em>(Bit zint.)</em>` } :
                    getPartDetailsAndHTML(set.bitId, 'bit', 'Bit');
                setImagesHTML = `<div class="wynik-zestaw-obrazki">${bladeInfo.html} ${ratchetInfo.html} ${bitInfo.html}</div>`;
                setNameParts = [bladeInfo.name, ratchetInfo.name, bitInfo.name];
            } else if (seriaZestawu === 'cx') {
                const lockChipInfo = getPartDetailsAndHTML(set.cx_lock_chipId, 'cx-lock-chip', 'LockChip');
                const mainBladeInfo = getPartDetailsAndHTML(set.cx_main_bladeId, 'cx-main-blade', 'MainBlade');
                const assistBladeInfo = getPartDetailsAndHTML(set.cx_assist_bladeId, 'cx-assist-blade', 'AssistBlade');
                const ratchetInfo = getPartDetailsAndHTML(set.ratchetId, 'rachet', 'Ratchet');
                let bitInfo = czySpecjalnyRatchetWDecku && ratchetInfo.partObj ?
                    { html: `<div class="deck-part-placeholder" style="font-size:0.5em; line-height:1.2; padding:5px;" title="Bit zintegrowany w ${ratchetInfo.partObj.nazwa}">BIT<br>INTEG.</div>`, name: `<em>(Bit zint.)</em>` } :
                    getPartDetailsAndHTML(set.bitId, 'bit', 'Bit');
                setImagesHTML = `<div class="cx-images-container"><div class="cx-blade-row wynik-zestaw-obrazki">${lockChipInfo.html} ${mainBladeInfo.html} ${assistBladeInfo.html}</div><div class="cx-drive-row wynik-zestaw-obrazki" style="margin-top: 5px;">${ratchetInfo.html} ${bitInfo.html}</div></div>`;
                setNameParts = [lockChipInfo.name, mainBladeInfo.name, assistBladeInfo.name, ratchetInfo.name, bitInfo.name];
            }

            let setNameHTML = setNameParts.map(name => (name || "").replace(/<\/?i>/g, '').replace(/\s\([^)]+\)/, '')).filter(name => name && !name.startsWith('(Bit zint.)')).join(' | ');
            let setStatsSummaryHTML = '<div class="stat-grid">';
            if (currentSetStats) {
                setStatsSummaryHTML += `<span>ATK: ${currentSetStats.ATK || 0}</span>`;
                setStatsSummaryHTML += `<span>DEF: ${currentSetStats.DEF || 0}</span>`;
                setStatsSummaryHTML += `<span>STM: ${currentSetStats.STM || 0}</span>`;
                setStatsSummaryHTML += `<span>Waga: ${(currentSetStats.WAGA || 0)}g</span>`;
                if ((currentSetStats.DASH || 0) !== 0) setStatsSummaryHTML += `<span>DASH: ${currentSetStats.DASH || 0}</span>`;
                if ((currentSetStats.B_RES || 0) !== 0) setStatsSummaryHTML += `<span>B-RES: ${currentSetStats.B_RES || 0}</span>`;
                if (seriaZestawu === 'cx' && (currentSetStats.CX_LC_WYTRZ || 0) !== 0) {
                    setStatsSummaryHTML += `<span>LC-W: ${currentSetStats.CX_LC_WYTRZ || 0}</span>`;
                }
            } else {
                setStatsSummaryHTML += '<span>Brak danych statystyk</span>';
            }
            setStatsSummaryHTML += `</div>`;
            setsHTML += `<div class="deck-card-set-preview"><strong style="text-transform: capitalize; display: block; text-align: center; margin-bottom: 8px;">Zestaw ${index + 1} (${seriaZestawu.toUpperCase().replace('_', '/')})</strong>${setImagesHTML}<div style="font-size:0.8em; color:#ddd; margin-top: 8px; margin-bottom:10px; word-break: break-word; text-align:center; line-height: 1.3;">${setNameHTML}</div>${setStatsSummaryHTML}</div>`;
        });
        const actionsHTML = `<div class="item-actions" style="margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.08); padding-top: 15px;"><button class="button-auto-width" onclick="edytujDeck('${deck.id}')" title="Edytuj '${deck.name || ''}'">Edytuj</button><button class="button-auto-width cancel-btn" onclick="usunZapisanyDeck('${deck.id}')" title="Usuń '${deck.name || ''}'">Usuń</button></div>`;
        deckCard.innerHTML = `<h4 style="text-align:center; color:#e0e0e0; margin-bottom: 5px;">${deck.name || 'Deck bez nazwy'}</h4><p style="font-size: 0.75em; color: #aaa; margin-top: 0; margin-bottom:15px; text-align:center;">${deck.lastModified ? `Modyfikacja: ${new Date(deck.lastModified).toLocaleDateString('pl-PL')} ${new Date(deck.lastModified).toLocaleTimeString('pl-PL', {hour:'2-digit', minute:'2-digit'})}` : `Zapisano: ${new Date(deck.timestamp || Date.now()).toLocaleDateString('pl-PL')} ${new Date(deck.timestamp || Date.now()).toLocaleTimeString('pl-PL', {hour:'2-digit', minute:'2-digit'})}`}</p>${setsHTML}${actionsHTML}`;
        container.appendChild(deckCard);
    });
}


function edytujDeck(deckId) {
    const savedDecks = getSavedDecks(); // Pobierz najświeższą listę decków
    const deckToEdit = savedDecks.find(d => d.id === deckId);

    if (!deckToEdit) { 
        showNotification("Nie znaleziono decku do edycji.", 3000, 'error'); 
        return; 
    }
    
    // Ustaw currentEditingDeckId PRZED nawigacją, aby navigateTo wiedziało, że edytujemy
    currentEditingDeckId = deckId;
    
    // Inicjalizuj currentDeckBeingBuilt z danymi decku do edycji
    // Ta funkcja powinna głęboko skopiować deckToEdit i upewnić się, że struktura jest kompletna (np. 4 sety)
    initializeOrResetCurrentDeck(deckToEdit); 

    // Zawsze zaczynaj edycję od wyświetlenia pierwszej zakładki/zestawu
    currentlyActiveSetIndexInBuilder = 0; 

    // Ustaw nazwę decku w polu input
    const deckNameInput = document.getElementById('deckName');
    if (deckNameInput) {
        deckNameInput.value = deckToEdit.name || '';
    }
    
    // Nawiguj do strony Deck Buildera
    const linkDoDeckBuildera = document.querySelector('.sidebar a[onclick*="navigateTo(\'deck"]');
    if(linkDoDeckBuildera) {
        // navigateTo('deck', linkDoDeckBuildera) samo wywoła renderDeckBuilderAndParts,
        // które z kolei użyje currentlyActiveSetIndexInBuilder do wyrenderowania odpowiedniej zakładki i slotów.
        navigateTo('deck', linkDoDeckBuildera); 
    } else { 
        showNotification("Błąd krytyczny: Brak linku nawigacyjnego do Deck Generatora.", 3000, 'error'); 
        currentEditingDeckId = null; // Zresetuj tryb edycji, bo nawigacja nieudana
        initializeOrResetCurrentDeck(); // Wyczyść builder
        return; 
    }
    
    // Po nawigacji i renderowaniu (które dzieje się asynchronicznie w navigateTo),
    // zaktualizuj tekst przycisku zapisu i pokaż powiadomienie.
    // Używamy setTimeout, aby dać DOM czas na aktualizację po wywołaniu navigateTo.
    setTimeout(() => { 
        const saveButton = document.getElementById('saveDeckButton');
        if (saveButton) {
            saveButton.textContent = 'Zapisz Zmiany w Decku';
        }
        showNotification(`Edytujesz deck: "${deckToEdit.name || 'Bez nazwy'}". Wyświetlono Zestaw 1.`, 3500, 'info');
        
        // Opcjonalnie: przewiń do góry strony deck buildera lub do nazwy decku
        const deckBuilderSection = document.getElementById('deck');
        if (deckBuilderSection) {
            deckBuilderSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } else if (deckNameInput) {
            deckNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 150); // Małe opóźnienie, można dostosować w razie potrzeby
}

    function usunZapisanyDeck(deckId) {
        if (!deckId) { showNotification("Błąd: Brak ID decku.", 3000, 'info'); return; }
        const savedDecks = getSavedDecks();
        const deckToDelete = savedDecks.find(deck => deck.id === deckId);
        
        if (!deckToDelete) { 
            showNotification("Nie znaleziono decku do usunięcia.", 3000, 'info'); 
            // displaySavedDecks(); // Można odświeżyć, jeśli podejrzewamy niespójność stanu
            return; 
        }
        
        // Logika usuwania wykonywana jest teraz bezpośrednio:
        const updatedDecks = savedDecks.filter(deck => deck.id !== deckId);
        setSavedDecks(updatedDecks);
        showNotification(`Deck "${deckToDelete.name || 'Bez nazwy'}" usunięty.`, 3000, 'info');
        
        // Odśwież listę, jeśli jesteśmy na stronie galerii
        if (document.getElementById('galeriaDeckow')?.classList.contains('active')) {
            displaySavedDecks();
        }
        
        // Jeśli edytowany deck został usunięty, wyczyść builder
        if (currentEditingDeckId === deckId) { 
            clearCurrentDeckForBuilder();
        }
    }
    

// =================================
// Import/Eksport Magazynu
// =================================
function eksportujDaneDoPolaTekstowego() {
    const magazyn = getMagazyn();
    const poleTekstowe = document.getElementById('poleDanychJsonMagazyn');
    if (poleTekstowe) {
        if (magazyn && magazyn.length > 0) {
            try {
                poleTekstowe.value = JSON.stringify(magazyn, null, 2); 
                showNotification('Dane magazynu skopiowane do pola.', 3000, 'success'); 
                poleTekstowe.focus(); poleTekstowe.select();
            } catch (e) { showNotification('Błąd konwersji magazynu do JSON.', 3000, 'error'); poleTekstowe.value = 'Błąd JSON.';}
        } else { poleTekstowe.value = ''; showNotification('Magazyn jest pusty.', 3000, 'info'); }
    } else showNotification('Błąd: Pole tekstowe magazynu nie znalezione.', 3000, 'error');
}

function importujDaneZPolaTekstowego() {
    const poleTekstowe = document.getElementById('poleDanychJsonMagazyn');
    if (!poleTekstowe || !poleTekstowe.value.trim()) {
        showNotification('Pole danych magazynu jest puste.', 3000, 'warning'); return;
    }
    let daneDoImportu;
    try { daneDoImportu = JSON.parse(poleTekstowe.value); } 
    catch (e) { showNotification('Błąd importu: Nieprawidłowy JSON w danych magazynu.', 3000, 'error'); console.error("Błąd parsowania JSON (magazyn):", e); return; }
    przetworzIDopiszDaneMagazynu(daneDoImportu, 'Pole Tekstowe JSON', false); // false = nie zeruj ilości
}

// Zmodyfikuj sygnaturę funkcji:
function przetworzIDopiszDaneMagazynu(daneDoImportu, zrodloDanychOpis, ustawDomyslnaIloscDlaNowychNaZero = false, trybCichy = false) {
    if (!Array.isArray(daneDoImportu)) {
        if (!trybCichy) showNotification(`Błąd importu z '${zrodloDanychOpis}': Nieprawidłowy format (oczekiwano tablicy).`, 3000, 'error');
        console.error(`[IMPORT ERROR] Dane wejściowe z '${zrodloDanychOpis}' nie są tablicą:`, daneDoImportu);
        return false;
    }

    // Prosta funkcja do tworzenia czystego obiektu części z pliku JSON
    const stworzObiektCzesci = (item) => {
        if (!item || typeof item !== 'object' || !item.id) return null;
        
        const ilosc = ustawDomyslnaIloscDlaNowychNaZero ? 0 : (parseInt(item.ilosc, 10) || 0);
        
        // --- NOWA, UPROSZCZONA LOGIKA ---
        // Zawsze bierzemy wszystkie dane z pliku źródłowego, bez skomplikowanego wypełniania.
        const nowaCzesc = { ...item }; // Kopiujemy wszystkie właściwości
        nowaCzesc.ilosc = ilosc; // Ustawiamy tylko poprawną ilość
        // --- KONIEC NOWEJ LOGIKI ---

        return nowaCzesc;
    };

    const czesciImportowaneMap = new Map(
        daneDoImportu.map(item => stworzObiektCzesci(item)).filter(Boolean).map(czesc => [String(czesc.id), czesc])
    );

    let aktualnyMagazyn = getMagazyn();
    let dodanoNowychCzesci = 0;
    let zaktualizowanoDaneCzesci = 0;

    // Przejdź przez istniejący magazyn, zaktualizuj go danymi z importu
    aktualnyMagazyn.forEach(istniejacaCzesc => {
        const id = String(istniejacaCzesc.id);
        if (czesciImportowaneMap.has(id)) {
            const importowanaCzesc = czesciImportowaneMap.get(id);
            const iloscDoZachowania = ustawDomyslnaIloscDlaNowychNaZero ? istniejacaCzesc.ilosc : importowanaCzesc.ilosc;
            
            const finalnaCzesc = { ...importowanaCzesc, ilosc: iloscDoZachowania };

            // Sprawdzamy, czy dane (oprócz ilości) się zmieniły
            if (JSON.stringify({ ...istniejacaCzesc, ilosc: null }) !== JSON.stringify({ ...finalnaCzesc, ilosc: null })) {
                zaktualizowanoDaneCzesci++;
            }
            
            // Nadpisujemy starą część w magazynie
            const index = aktualnyMagazyn.findIndex(c => String(c.id) === id);
            if (index !== -1) {
                aktualnyMagazyn[index] = finalnaCzesc;
            }
            czesciImportowaneMap.delete(id); // Usuwamy, aby nie dodawać jej ponownie
        }
    });

    // Dodaj pozostałe (nowe) części z mapy importu do magazynu
    if (czesciImportowaneMap.size > 0) {
        dodanoNowychCzesci = czesciImportowaneMap.size;
        aktualnyMagazyn.push(...czesciImportowaneMap.values());
    }

    setMagazyn(aktualnyMagazyn);
    
    // Logika powiadomień (bez zmian)
    let msg = '';
    if (dodanoNowychCzesci > 0) msg += `Dodano ${dodanoNowychCzesci} nowych części. `;
    if (zaktualizowanoDaneCzesci > 0) msg += `Zaktualizowano dane dla ${zaktualizowanoDaneCzesci} istniejących części. `;

    if (!trybCichy) {
        if (msg) showNotification(`Import z '${zrodloDanychOpis}' zakończony! ${msg.trim()}`, 4500, 'success');
        else showNotification(`Magazyn jest aktualny.`, 3000, 'info');
    } else {
        if (msg) console.log(`[TRYB CICHY] Import z '${zrodloDanychOpis}': ${msg.trim()}`);
        else console.log(`[TRYB CICHY] Magazyn aktualny.`);
    }

    const aktywnaStronaId = document.querySelector('.page.active')?.id;
    if (aktywnaStronaId === 'magazyn') wyswietlMagazyn();
    if (aktywnaStronaId === 'deck') renderDeckBuilderAndParts();

    return (dodanoNowychCzesci > 0 || zaktualizowanoDaneCzesci > 0);
}

// Zmodyfikuj sygnaturę funkcji:
function importujMagazynZBazyDomyslnejHTML(trybCichy = false) {
    const nazwaZrodla = 'Domyślna Baza (z HTML)';
    try {
        const scriptTag = document.getElementById('domyslnaBazaDanychJson');
        if (!scriptTag) { 
            if (!trybCichy) showNotification("Błąd: Brak źródła danych domyślnych (#domyslnaBazaDanychJson).", 4000, 'error');
            return false; // Dodano zwracanie wartości
        }
        // ... (reszta kodu pobierania JSONa - bez zmian) ...
        const jsonString = scriptTag.textContent;
        if (!jsonString || jsonString.trim() === '') {
            if (!trybCichy) showNotification("Błąd: Domyślna baza danych w HTML jest pusta.", 4000, 'error');
            return false;
        }
        let daneDoImportu;
        try { daneDoImportu = JSON.parse(jsonString); } 
        catch (parseError) { 
            if (!trybCichy) showNotification("Błąd: Nieprawidłowy JSON w domyślnej bazie danych.", 5000, 'error');
            console.error("Błąd parsowania JSON (baza domyślna):", parseError); 
            return false; 
        }
        
        // true = ustaw ilość na 0 dla nowych części, nie nadpisuj ilości istniejących na te z bazy (bo tam jest 0)
        // przekazujemy trybCichy do przetworzIDopiszDaneMagazynu
        const wynikPrzetwarzania = przetworzIDopiszDaneMagazynu(daneDoImportu, nazwaZrodla, true, trybCichy); 
        return wynikPrzetwarzania; // Zwróć wynik z przetworzIDopiszDaneMagazynu

    } catch (error) { 
        if (!trybCichy) showNotification(`Krytyczny błąd importu z domyślnej bazy: ${error.message}`, 4000, 'error');
        console.error(error); 
        return false;
    }
}


// =================================
// Import/Eksport Decków
// =================================
function eksportujDeckiDoPolaTekstowego() {
    const savedDecks = getSavedDecks();
    const poleTekstoweDecki = document.getElementById('poleDanychJsonDecki');
    if (poleTekstoweDecki) {
        if (savedDecks && savedDecks.length > 0) {
            try {
                const jsonString = JSON.stringify(savedDecks, null, 2);
                poleTekstoweDecki.value = jsonString;
                showNotification('Zapisane decki skopiowane do pola.', 3000, 'success');
                poleTekstoweDecki.focus(); poleTekstoweDecki.select();
            } catch (e) { showNotification('Błąd konwersji decków do JSON.', 3000, 'error'); poleTekstoweDecki.value = 'Błąd JSON.'; }
        } else { poleTekstoweDecki.value = ''; showNotification('Brak decków do eksportu.', 3000, 'info'); }
    } else showNotification('Błąd: Pole tekstowe decków nie znalezione.', 3000, 'error');
}

function walidujIPrzygotujPojedynczyDeckDoDodania(deckObj, defaultNamePrefix = "Importowany Deck") {
    if (!deckObj || typeof deckObj !== 'object') {
        console.warn("[VALIDATE_DECK_WARN] Dane wejściowe nie są obiektem.", deckObj); return null;
    }
    if (typeof deckObj.id !== 'string' || !deckObj.id.trim() || 
        !(typeof deckObj.name === 'string' || deckObj.name === null || deckObj.name === undefined) || 
        !Array.isArray(deckObj.sets)) {
        console.warn("[VALIDATE_DECK_WARN] Nieprawidłowa struktura decku (ID, nazwa lub zestawy).", deckObj); return null;
    }

    const gotowyDeck = {
        id: deckObj.id.trim(),
        name: String(deckObj.name || `${defaultNamePrefix}_${Date.now() % 10000}`).trim(),
        timestamp: parseInt(deckObj.timestamp, 10) || Date.now(),
        lastModified: parseInt(deckObj.lastModified, 10) || (parseInt(deckObj.timestamp, 10) || Date.now()),
        sets: []
    };

    const parseFloatOrZero = (val) => { const num = parseFloat(val); return isNaN(num) ? 0 : num; };
    const parseIntOrZero = (val) => { const num = parseInt(val, 10); return isNaN(num) ? 0 : num; };

    deckObj.sets.forEach((set) => {
        if (!set || typeof set.seria !== 'string' || !['bx_ux', 'cx'].includes(set.seria)) { 
            console.warn(`[VALIDATE_DECK_WARN_SET] Nieprawidłowy lub brak serii w zestawie decku ID: ${gotowyDeck.id}. Pomijam zestaw.`); 
            return; 
        }
        
        const przygotowanyZestaw = { 
            seria: set.seria,
            bladeId: set.bladeId === undefined ? null : String(set.bladeId || '').trim() || null,
            ratchetId: set.ratchetId === undefined ? null : String(set.ratchetId || '').trim() || null,
            bitId: set.bitId === undefined ? null : String(set.bitId || '').trim() || null,
            cx_lock_chipId: set.cx_lock_chipId === undefined ? null : String(set.cx_lock_chipId || '').trim() || null,
            cx_main_bladeId: set.cx_main_bladeId === undefined ? null : String(set.cx_main_bladeId || '').trim() || null,
            cx_assist_bladeId: set.cx_assist_bladeId === undefined ? null : String(set.cx_assist_bladeId || '').trim() || null,
            statystykiObliczone: {}
        };
        
        if (set.seria === 'bx_ux') {
            przygotowanyZestaw.cx_lock_chipId = null;
            przygotowanyZestaw.cx_main_bladeId = null;
            przygotowanyZestaw.cx_assist_bladeId = null;
        } else if (set.seria === 'cx') {
            przygotowanyZestaw.bladeId = null; 
        }

        if (set.statystykiObliczone && typeof set.statystykiObliczone === 'object') {
            const stats = set.statystykiObliczone;
            przygotowanyZestaw.statystykiObliczone = { 
                ATK: parseFloatOrZero(stats.ATK), DEF: parseFloatOrZero(stats.DEF), STM: parseFloatOrZero(stats.STM), 
                WAGA: parseFloatOrZero(stats.WAGA || stats.waga), DASH: parseFloatOrZero(stats.DASH), 
                B_RES: parseFloatOrZero(stats.B_RES || stats.BURST_RES), CX_LC_WYTRZ: parseIntOrZero(stats.CX_LC_WYTRZ) 
            };
        }
        gotowyDeck.sets.push(przygotowanyZestaw);
    });

    if (deckObj.sets.length > 0 && gotowyDeck.sets.length === 0) { 
        console.warn(`[VALIDATE_DECK_WARN_NO_VALID_SETS] Deck ID: ${gotowyDeck.id} nie zawierał poprawnych zestawów. Odrzucam.`); 
        return null; 
    }
    
    console.log(`[VALIDATE_DECK_SUCCESS] Deck ID: ${gotowyDeck.id} zwalidowany z ${gotowyDeck.sets.length} zestawami.`);
    return gotowyDeck;
}

function importujDeckiZPolaTekstowego() {
    console.log("[IMPORT_DECK_FIELD_1] Rozpoczęto import decków z pola tekstowego.");
    const poleTekstoweDecki = document.getElementById('poleDanychJsonDecki');
    if (!poleTekstoweDecki || !poleTekstoweDecki.value.trim()) {
        showNotification('Pole danych decków jest puste.', 3000, 'warning'); return;
    }
    let daneSuroweZInputu;
    try { daneSuroweZInputu = JSON.parse(poleTekstoweDecki.value); } 
    catch (e) { showNotification('Błąd importu: Nieprawidłowy JSON w danych decków.', 3000, 'error'); console.error("Błąd parsowania JSON (decki z pola):", e); return; }

    let deckiDoSprawdzenia;
    if (daneSuroweZInputu && typeof daneSuroweZInputu === 'object' && !Array.isArray(daneSuroweZInputu)) {
        deckiDoSprawdzenia = [daneSuroweZInputu];
    } else if (Array.isArray(daneSuroweZInputu)) {
        deckiDoSprawdzenia = daneSuroweZInputu;
    } else {
        showNotification('Błąd importu: Dane muszą być listą decków lub pojedynczym obiektem decku.', 3000, 'error'); return;
    }
    
    const istniejaceDecki = getSavedDecks();
    let nowoDodaneDecki = []; let pominieteDuplikatyCount = 0; let bledneFormatyCount = 0;

    deckiDoSprawdzenia.forEach((potencjalnyDeck, index) => {
        const zwalidowanyDeck = walidujIPrzygotujPojedynczyDeckDoDodania(potencjalnyDeck, `Import z pola #${index + 1}`);
        if (zwalidowanyDeck) {
            const indexIstniejacego = istniejaceDecki.findIndex(d => d.id === zwalidowanyDeck.id);
            if (indexIstniejacego > -1) {
                pominieteDuplikatyCount++; 
                console.warn(`[IMPORT_DECK_FIELD_WARN_DUPLICATE] Deck ID '${zwalidowanyDeck.id}' ("${zwalidowanyDeck.name}") już istnieje. Pomijam.`);
            } else {
                istniejaceDecki.push(zwalidowanyDeck);
                nowoDodaneDecki.push(zwalidowanyDeck);
            }
        } else {
            bledneFormatyCount++;
        }
    });

    setSavedDecks(istniejaceDecki); 

    let komunikatKoncowy = "";
    if (nowoDodaneDecki.length > 0) komunikatKoncowy += `Dodano ${nowoDodaneDecki.length} nowych deck(ów). `;
    if (pominieteDuplikatyCount > 0) komunikatKoncowy += `${pominieteDuplikatyCount} deck(ów) pominięto (duplikaty ID). `;
    if (bledneFormatyCount > 0) komunikatKoncowy += `Pominięto ${bledneFormatyCount} nieprawidłowych decków. `;

    if (komunikatKoncowy.trim() === "" && deckiDoSprawdzenia.length > 0) {
        showNotification('Żadne nowe decki nie zostały dodane (mogą być duplikatami lub błędami formatu).', 3000, 'info');
    } else if (komunikatKoncowy.trim() === "" && deckiDoSprawdzenia.length === 0) {
        showNotification('Pole nie zawierało danych decków do importu.', 3000, 'info');
    } else {
        showNotification(`Import decków zakończony! ${komunikatKoncowy.trim()}`, 4500, 'success');
    }

    if (nowoDodaneDecki.length > 0 && poleTekstoweDecki) poleTekstoweDecki.value = ''; 
    
    if (document.getElementById('galeriaDeckow')?.classList.contains('active')) {
        displaySavedDecks();
    }
    console.log(`[IMPORT_DECK_FIELD_5] Zakończono import decków. Dodano: ${nowoDodaneDecki.length}, Duplikaty: ${pominieteDuplikatyCount}, Błędne: ${bledneFormatyCount}`);
}

// =================================
// Czyszczenie Danych i Inicjalizacja
// =================================
function wykonajWyczyszczenieDanych() {
    console.log("Rozpoczynanie pełnego czyszczenia danych aplikacji...");

    // Czyszczenie localStorage
    localStorage.removeItem(MAGAZYN_KEY);
    localStorage.removeItem(SAVED_DECKS_KEY);
    localStorage.removeItem(SCORES_KEY);
    localStorage.removeItem(DOMYSLNA_BAZA_ZALADOWANA_KEY); // Upewnij się, że ta flaga też jest usuwana

    console.log("Klucze localStorage usunięte.");

    // Resetowanie zmiennych globalnych przechowujących stan
    // Magazyn (jeśli jest jakaś zmienna globalna oprócz localStorage)
    // Jeśli np. masz globalną zmienną `let aktualnyMagazynGlobalny = []`, zresetuj ją:
    // aktualnyMagazynGlobalny = []; // Przykład

    // Zapisane Decki (jeśli jest zmienna globalna)
    // np. ostatnioWylosowaneZestawyGlobalnie już jest resetowane w wyczyscLosowanie

    // Wyniki licznika punktów
    scores = { player1: 0, player2: 0 };
    playerNames = { player1: "Gracz 1", player2: "Gracz 2" };
    // Wyczyść ewentualne timeouty związane z licznikiem (masz to już dla fullscreenOverlayHideTimeout)
    if (imageHideTimeouts.player1) clearTimeout(imageHideTimeouts.player1);
    if (imageHideTimeouts.player2) clearTimeout(imageHideTimeouts.player2);
    imageHideTimeouts = { player1: null, player2: null };
    if (fullscreenOverlayHideTimeout) {
        clearTimeout(fullscreenOverlayHideTimeout);
        fullscreenOverlayHideTimeout = null;
    }
    console.log("Zmienne globalne wyników zresetowane.");

    // Stan Deck Buildera
    initializeOrResetCurrentDeck(); // To powinno resetować currentDeckBeingBuilt do pustego stanu
    currentEditingDeckId = null;
    currentlyActiveSetIndexInBuilder = 0;
    const deckNameInput = document.getElementById('deckName');
    if (deckNameInput) deckNameInput.value = "";
    const saveBtn = document.getElementById('saveDeckButton');
    if (saveBtn) saveBtn.textContent = 'Zapisz Aktualny Deck';
    console.log("Stan Deck Buildera zresetowany.");


    // Stan Generatora Losowych Zestawów
    ostatnioWylosowaneZestawyGlobalnie = [];
    if (wynikiDivGenerator) wynikiDivGenerator.innerHTML = '';
    if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
    const zapiszGlownyControls = document.getElementById('zapisz-glowny-zestaw-controls');
    if (zapiszGlownyControls) zapiszGlownyControls.style.display = 'none';
    const nazwaDeckuInputGenerator = document.getElementById('nazwa-glownego-decku');
    if (nazwaDeckuInputGenerator) nazwaDeckuInputGenerator.value = "";
    console.log("Stan Generatora Losowych Zestawów zresetowany.");

    // Czyszczenie pól tekstowych na stronie Import/Eksport (jeśli jest aktywna)
    // Robimy to tutaj, bo odświeżenie widoku może nie nastąpić od razu,
    // a chcemy, żeby użytkownik widział, że pola są czyste.
    const poleJsonMagazyn = document.getElementById('poleDanychJsonMagazyn');
    const poleJsonDecki = document.getElementById('poleDanychJsonDecki');
    if (poleJsonMagazyn) poleJsonMagazyn.value = '';
    if (poleJsonDecki) poleJsonDecki.value = '';
    console.log("Pola tekstowe Import/Eksport wyczyszczone.");


    // Ukryj pełnoekranową nakładkę licznika, jeśli była widoczna
    const overlayElement = document.getElementById('fullscreenFinishOverlay');
    const imageElement = document.getElementById('fullscreenFinishImage');
    if (overlayElement && imageElement && overlayElement.classList.contains('visible')) {
        overlayElement.classList.remove('visible');
        // Opóźnione czyszczenie src, aby uniknąć mignięcia, jeśli przejście trwa
        setTimeout(() => {
            if (!overlayElement.classList.contains('visible')) { // Sprawdź ponownie na wszelki wypadek
                imageElement.src = '#';
            }
        }, 300); // Dopasuj do czasu przejścia opacity
        console.log("Nakładka licznika ukryta.");
    }


    console.log("Pełne czyszczenie danych aplikacji (zmiennych i UI powiązanych) zakończone.");
    // UWAGA: Ta funkcja NIE powinna odświeżać całych widoków (jak wyswietlMagazyn),
    // to zadanie dla funkcji nadrzędnej po załadowaniu nowej bazy.
    // Powinna jednak resetować stan UI, który jest bezpośrednio powiązany ze zmiennymi globalnymi,
    // np. wyświetlacze wyników, inputy.
}

function wykonajPelnyResetAplikacji() {
    console.log("Rozpoczynanie pełnego resetu aplikacji...");

    // Krok 1: Wykonaj czyszczenie wszystkich danych
    wykonajWyczyszczenieDanych(); // Upewnij się, że ta funkcja jest teraz kompletna

    console.log("Pełne czyszczenie danych aplikacji (localStorage i zmienne globalne) zakończone.");

    // Krok 2: Załaduj domyślną bazę danych
    console.log("Próba załadowania domyślnej bazy danych po resecie...");
    let czyBazaZaladowanaPoprawnieLubNieWymagalaZmian = false;
    try {
        // Wywołujemy z trybemCichy=false, aby użytkownik widział ewentualne komunikaty z importu.
        // `ustawDomyslnaIloscDlaNowychNaZero = true` jest przekazywane wewnątrz importujMagazynZBazyDomyslnejHTML
        // do przetworzIDopiszDaneMagazynu.
        const importWynik = importujMagazynZBazyDomyslnejHTML(false); // false = nie tryb cichy

        // importWynik to true, jeśli były zmiany; false, jeśli nie było zmian lub błąd w danych importu.
        // Dla resetu uznajemy za sukces, jeśli sama funkcja importu nie rzuciła krytycznego błędu.
        czyBazaZaladowanaPoprawnieLubNieWymagalaZmian = true; 

        if (importWynik) {
            console.log("Domyślna baza danych załadowana i dokonano zmian w magazynie.");
        } else {
            console.log("Próba załadowania domyślnej bazy danych nie wprowadziła nowych zmian (magazyn mógł być już zgodny lub pusty po czyszczeniu, lub dane bazy były niepoprawne i przetworz... zwróciło false).");
        }
        localStorage.setItem(DOMYSLNA_BAZA_ZALADOWANA_KEY, 'true'); // Ustaw flagę po udanej próbie
        showNotification("Aplikacja została zresetowana. Domyślna baza części załadowana (lub podjęto próbę).", 4000, 'success');

    } catch (error) { // Ten catch łapie błędy rzucone przez importujMagazynZBazyDomyslnejHTML (np. brak skryptu)
        console.error("Krytyczny błąd podczas próby ładowania domyślnej bazy danych po resecie:", error);
        showNotification("Dane zostały wyczyszczone, ale wystąpił KRYTYCZNY błąd podczas ładowania domyślnej bazy części. Sprawdź konsolę.", 6000, 'error');
        // Flaga DOMYSLNA_BAZA_ZALADOWANA_KEY nie jest ustawiana, co jest poprawne.
    }

    console.log("Proces ładowania domyślnej bazy zakończony.");

    // Krok 3: Odśwież widoki, które mogły być aktywne, aby odzwierciedliły nowy, czysty stan
    // oraz ewentualnie nowo załadowaną bazę.
    console.log("Odświeżanie aktywnych widoków po resecie...");
    const aktywnaStronaId = document.querySelector('.page.active')?.id;
    if (aktywnaStronaId) {
        console.log(`Aktywna strona to: ${aktywnaStronaId}. Odświeżam...`);
        if (aktywnaStronaId === 'magazyn') wyswietlMagazyn();
        else if (aktywnaStronaId === 'generator') {
             // wyczyscLosowanie jest już częścią wykonajWyczyszczenieDanych,
             // ale można tu upewnić się, że UI jest czyste
            if (wynikiDivGenerator) wynikiDivGenerator.innerHTML = '';
            if (placeholderActualImgGenerator) placeholderActualImgGenerator.style.display = 'block';
        } else if (aktywnaStronaId === 'deck') {
            // clearCurrentDeckForBuilder jest już w wykonajWyczyszczenieDanych,
            // ale renderDeckBuilderAndParts odświeży listę dostępnych części z nowej bazy.
            renderDeckBuilderAndParts();
        } else if (aktywnaStronaId === 'galeriaDeckow') displaySavedDecks();
        else if (aktywnaStronaId === 'licznikPunktow') {
            if (typeof displayScores === 'function') displayScores();
            if (typeof displayPlayerNames === 'function') displayPlayerNames();
        }
        // Strona 'importexport' powinna mieć już wyczyszczone pola przez wykonajWyczyszczenieDanych.
    } else {
        console.log("Brak aktywnej strony do odświeżenia.");
    }
    console.log("Pełny reset aplikacji zakończony.");
}
   
document.addEventListener('DOMContentLoaded', function() {
    // Inicjalizacja podstawowych elementów DOM
    sidebar = document.getElementById('sidebar');
    // ... (reszta inicjalizacji zmiennych globalnych DOM)
    appContainer = document.getElementById('app-container');
    sidebarToggleBtn = document.getElementById('sidebarToggleBtn');
    menuIcon = document.getElementById('menu-icon');
    menuBtnText = document.getElementById('menu-btn-text');
    wynikiDivGenerator = document.getElementById('wyniki');
    placeholderActualImgGenerator = document.getElementById('placeholder-img');

    // Inicjalizacja danych aplikacji (np. pusty deck builder)
    initializeOrResetCurrentDeck(); 

    // ---- AUTOMATYCZNA SYNCHRONIZACJA BAZY DANYCH PRZY KAŻDYM STARCIE ----
    try {
        console.log("Rozpoczynanie automatycznej synchronizacji magazynu z domyślną bazą...");
        // Wywołujemy z trybemCichy=true, aby uniknąć powiadomień, jeśli nic się nie zmieniło.
        // ustawDomyslnaIloscNaZero=true jest domyślne dla importu z HTML i oznacza,
        // że NOWE części dostaną ilość 0, a ilości ISTNIEJĄCYCH nie będą zerowane.
        const czyCosSieZmienilo = importujMagazynZBazyDomyslnejHTML(true); 

        if (czyCosSieZmienilo) {
            console.log("Magazyn został zsynchronizowany z domyślną bazą (dodano nowe/zaktualizowano istniejące części).");
            // Można tu rozważyć dyskretne powiadomienie, jeśli coś faktycznie się zmieniło, np.
            // showNotification("Baza części została zaktualizowana.", 2000, 'info');
            // Ale tylko jeśli `czyCosSieZmienilo` jest `true` i funkcja `przetworz...` zwraca
            // precyzyjnie, czy były zmiany w dodanych/zaktualizowanych danych (nie tylko ilości).
            // Obecnie `przetworzIDopiszDaneMagazynu` zwraca true jeśli cokolwiek z dodanych/zakt.danych/zakt.ilości się zmieniło.
        } else {
            console.log("Magazyn jest aktualny względem domyślnej bazy lub nie dokonano zmian.");
        }
    } catch (e) {
        console.error("Błąd podczas automatycznej synchronizacji magazynu:", e);
        showNotification("Wystąpił błąd przy aktualizacji bazy części.", 3000, 'error');
    }
    // ---- KONIEC AUTOMATYCZNEJ SYNCHRONIZACJI ---
    // ---- INICJALIZACJA TŁA VANTA ----
    // Upewnij się, że Vanta i Three.js są dostępne
    if (typeof VANTA !== 'undefined' && VANTA.NET && typeof THREE !== 'undefined') {
        const vantaContainer = document.getElementById('vanta-background');
        if (vantaContainer) { // Sprawdź, czy kontener istnieje
            try {
                window.vantaEffect = VANTA.NET({ 
                    el: "#vanta-background", // lub vantaContainer
                    mouseControls: true, 
                    touchControls: true, 
                    gyroControls: false, 
                    minHeight: 200.00, 
                    minWidth: 200.00, 
                    scale: 1.00, 
                    scaleMobile: 1.00, 
                    backgroundColor: 0x101018, // Upewnij się, że to jest poprawny format koloru (hex numeryczny)
                    color: 0x8a2be2,          // Poprawny format hex numeryczny
                    points: 11.00, 
                    maxDistance: 20.00, 
                    spacing: 16.00, 
                    showDots: true 
                });
                console.log("Vanta.NET zainicjalizowana pomyślnie.");
            } catch (e) { 
                console.error("Błąd podczas inicjalizacji VANTA:", e); 
                showNotification("Nie udało się załadować animowanego tła.", 3000, 'warning'); 
            }
        } else {
            console.warn("Element #vanta-background nie znaleziony w DOM. Vanta nie zostanie zainicjalizowana.");
        }
    } else {
        console.warn("VANTA lub Three.js niedostępne. Tło nie zostanie załadowane.");
    }
    // ---- KONIEC INICJALIZACJI TŁA VANTA ----

    // Ustawienie marginesu kontenera aplikacji
    if (appContainer) {
        appContainer.style.marginLeft = sidebarWidthCollapsed + 'px';
    }
    
    // Domyślna nawigacja
    const domyslnyLink = document.querySelector('.sidebar a[onclick*="navigateTo(\'info"]'); 
    if (domyslnyLink) {
        navigateTo('info', domyslnyLink); 
    } else { 
        console.error("Brak linku nawigacyjnego do strony 'Info'. Ustawiam 'info' jako domyślny, ale link w sidebarze może nie być podświetlony."); 
        navigateTo('info', null); 
        const infoLinkFallback = Array.from(document.querySelectorAll('.sidebar a')).find(a => a.getAttribute('onclick')?.includes("navigateTo('info'"));
        if(infoLinkFallback) infoLinkFallback.classList.add('active-link');
    }

    // Listener dla przycisku sidebar
    if (sidebarToggleBtn) {
        sidebarToggleBtn.addEventListener('click', toggleSidebar);
    } else {
        console.error("#sidebarToggleBtn nie znaleziony.");
    }
	
});


</script>

<!-- Domyślna Baza Danych JSON -->
</script>
<script id="domyslnaBazaDanychJson" type="application/json">
[
  {
  "id": "1", "typ": "blade", "nazwa": "AeroPegasus", "ilosc": 0, "img":"img/BladeAeroPegasus.webp", "ATK": 70, "DEF": 30, "STM": 35, "waga": 38.3},
  {
  "id": "2", "typ": "blade", "nazwa": "DranBuster", "ilosc": 0, "img": "img/BladeDranBuster.webp", "ATK": 70, "DEF": 20, "STM": 10, "waga": 36.5},
  {
  "id": "3", "typ": "blade", "nazwa": "GhostCircle", "ilosc": 0, "img": "img/BladeGhostCircle.webp", "ATK": 5, "DEF": 40, "STM": 55, "waga": 26.7},
  {
  "id": "4", "typ": "blade", "nazwa": "GolemRock", "ilosc": 0, "img": "img/BladeGolemRock.webp", "ATK": 30, "DEF": 60, "STM": 10, "waga": 34},
  {
  "id": "5", "typ": "blade", "nazwa": "HellsHammer", "ilosc": 0, "img": "img/BladeHellsHammer.webp", "ATK": 50, "DEF": 25, "STM": 25, "waga": 33},
  {
  "id": "6", "typ": "blade", "nazwa": "ImpactDrake", "ilosc": 0, "img": "img/BladeImpactDrake.webp", "ATK": 75, "DEF": 25, "STM":10, "waga": 39},
  {
  "id": "7", "typ": "blade", "nazwa": "KnightMail", "ilosc": 0, "img": "img/BladeKnightMail.webp", "ATK": 10, "DEF": 65, "STM": 35, "waga": 36.7},
  {
  "id": "8", "typ": "blade", "nazwa": "LeonCrest", "ilosc": 0, "img": "img/BladeLeonCrest.webp", "ATK": 15, "DEF": 70, "STM": 15, "waga": 35},
  {
  "id": "9", "typ": "blade", "nazwa": "PhoenixRudder", "ilosc": 0, "img": "img/BladePhoenixRudder.webp", "ATK": 10, "DEF": 35, "STM": 55, "waga": 34.5},
  {
  "id": "10", "typ": "blade", "nazwa": "SamuraiSaber", "ilosc": 0, "img": "img/BladeSamuraiSaber.webp", "ATK": 65, "DEF": 20, "STM": 25, "waga": 36.5},
  {
  "id": "11", "typ": "blade", "nazwa": "ScorpioSpear", "ilosc": 0, "img": "img/BladeScorpioSpear.webp", "ATK": 25, "DEF": 55, "STM": 30, "waga": 39.6},
  {
  "id": "12", "typ": "blade", "nazwa": "SharkScale", "ilosc": 0, "img": "img/BladeSharkScale.webp", "ATK": 70, "DEF": 15, "STM": 15, "waga": 37.6},
  {
  "id": "13", "typ": "blade", "nazwa": "ShinobiShadow", "ilosc": 0, "img": "img/BladeShinobiShadow.webp", "ATK": 10, "DEF": 70, "STM": 20, "waga": 28.2},
  {
  "id": "14", "typ": "blade", "nazwa": "SilverWolf", "ilosc": 0, "img": "img/BladeSilverWolf.webp", "ATK": 15, "DEF": 30, "STM": 65, "waga": 36.8},
  {
  "id": "15", "typ": "blade", "nazwa": "WizardRod", "ilosc": 0, "img": "img/BladeWizardRod.webp", "ATK": 15, "DEF": 25, "STM": 60, "waga": 35.3},
  {
  "id": "16", "typ": "blade", "nazwa": "WyvernHover", "ilosc": 0, "img": "https://iili.io/K2FvNCN.png", "ATK": 13, "DEF": 60, "STM": 27, "waga": 35},
  {
  "id": "17", "typ": "blade", "nazwa": "BlackShell", "ilosc": 0, "img": "img/BladeBlackShell.webp", "ATK": 10, "DEF": 65, "STM": 25, "waga": 32.4},
  {
  "id": "18", "typ": "blade", "nazwa": "CobaltDragoon", "ilosc": 0, "img": "img/BladeCobaltDragoon.webp", "ATK": 60, "DEF":15, "STM": 25, "waga": 37.8},
  {
  "id": "19", "typ": "blade", "nazwa": "CobaltDrake", "ilosc": 0, "img": "img/BladeCobaltDrake.webp", "ATK": 65, "DEF": 30, "STM": 20, "waga": 37.3},
  {
  "id": "20", "typ": "blade", "nazwa": "CrimsonGaruda", "ilosc": 0, "img": "img/BladeCrimsonGaruda.webp", "ATK": 45, "DEF": 25, "STM": 30, "waga": 35},
  {
  "id": "21", "typ": "blade", "nazwa": "DranDagger", "ilosc": 0, "img": "img/BladeDranDagger.webp", "ATK": 50, "DEF": 25, "STM": 25, "waga": 36},
  {
  "id": "22", "typ": "blade", "nazwa": "DranSword", "ilosc": 0, "img": "img/BladeDranSword.webp", "ATK": 55, "DEF": 25, "STM": 20, "waga": 35.1},
  {
  "id": "23", "typ": "blade", "nazwa": "HellsChain", "ilosc": 0, "img": "img/BladeHellsChain.webp", "ATK": 35, "DEF": 40, "STM": 25, "waga": 32.2},
  {
  "id": "24", "typ": "blade", "nazwa": "HellsScythe", "ilosc": 0, "img": "img/BladeHellsScythe.webp", "ATK": 30, "DEF": 35, "STM": 35, "waga": 33},
  {
  "id": "25", "typ": "blade", "nazwa": "KnightLance", "ilosc": 0, "img": "img/BladeKnightLance.webp", "ATK": 25, "DEF": 60, "STM": 15, "waga": 32.9},
  {
  "id": "26", "typ": "blade", "nazwa": "KnightShield", "ilosc": 0, "img": "img/BladeKnightShield.webp", "ATK": 20, "DEF": 55, "STM": 25, "waga": 34.8},
  {
  "id": "27", "typ": "blade", "nazwa": "LeonClaw", "ilosc": 0, "img": "img/BladeLeonClaw.webp", "ATK": 40, "DEF": 40, "STM": 20, "waga": 31.4},
  {
  "id": "28", "typ": "blade", "nazwa": "PhoenixFeather", "ilosc": 0, "img": "img/BladePhoenixFeather.webp", "ATK": 50, "DEF": 20, "STM": 30, "waga": 33.3},
  {
  "id": "29", "typ": "blade", "nazwa": "PhoenixWing", "ilosc": 0, "img": "img/BladePhoenixWing.webp", "ATK": 60, "DEF": 25, "STM": 15, "waga": 39},
  {
  "id": "30", "typ": "blade", "nazwa": "RhinoHorn", "ilosc": 0, "img": "img/BladeRhinoHorn.webp", "ATK": 20, "DEF": 50, "STM": 30, "waga": 32.7},
  {
  "id": "31", "typ": "blade", "nazwa": "SamuraiCalibur", "ilosc": 0, "img": "img/BladeSamuraiCalibur.webp", "ATK": 40, "DEF": 30, "STM": 30, "waga":36},
  {
  "id": "32", "typ": "blade", "nazwa": "SharkEdge", "ilosc": 0, "img": "img/BladeSharkEdge.webp", "ATK": 60, "DEF": 25, "STM": 15, "waga": 34.5},
  {
  "id": "33", "typ": "blade", "nazwa": "ShelterDrake", "ilosc": 0, "img": "img/BladeShelterDrake.webp", "ATK": 25, "DEF": 40, "STM": 35, "waga": 32.6},
  {
  "id": "34", "typ": "blade", "nazwa": "SphinxCowl", "ilosc": 0, "img": "img/BladeSphinxCowl.webp", "ATK": 35, "DEF": 55, "STM": 10, "waga": 32.7},
  {
  "id": "35", "typ": "blade", "nazwa": "TriceraPress", "ilosc": 0, "img": "img/BladeTriceraPress.webp", "ATK":20, "DEF": 65, "STM": 15, "waga": 36.5},
  {
  "id": "36", "typ": "blade", "nazwa": "TyrannoBeat", "ilosc": 0, "img": "img/BladeTyrannoBeat.webp", "ATK": 65, "DEF": 30, "STM": 5, "waga":37},
  {
  "id": "37", "typ": "blade", "nazwa": "UnicornSting", "ilosc": 0, "img": "img/BladeUnicornSting.webp", "ATK": 35, "DEF": 35, "STM": 30, "waga": 34},
  {
  "id": "38", "typ": "blade", "nazwa": "ViperTail", "ilosc": 0, "img": "img/BladeViperTail.webp", "ATK": 30, "DEF": 20, "STM": 50, "waga": 34.7},
  {
  "id": "39", "typ": "blade", "nazwa": "WeissTiger", "ilosc": 0, "img": "img/BladeWeissTiger.webp", "ATK": 45, "DEF": 30, "STM": 25, "waga": 34.6},
  {
  "id": "40", "typ": "blade", "nazwa": "WhaleWave", "ilosc": 0, "img": "img/BladeWhaleWave.webp", "ATK": 45, "DEF": 35, "STM": 20, "waga": 38.2},
  {
  "id": "41", "typ": "blade", "nazwa": "WizardArrow", "ilosc": 0, "img": "img/BladeWizardArrow.webp", "ATK": 15, "DEF": 30, "STM": 55, "waga": 31.8},
  {
  "id": "42", "typ": "blade", "nazwa": "WyvernGale", "ilosc": 0, "img": "img/BladeWyvernGale.webp", "ATK": 10, "DEF": 40, "STM": 50, "waga": 31.9},
  {
  "id": "43", "typ": "blade",
    "nazwa": "Bite Croc",
    "ilosc": 1,
    "img": "https://iili.io/K2FgVKN.md.png",
    "ATK": 60,
    "DEF": 22,
    "STM": 18,
    "waga": 34.1
  },
{
  "id": "44", "typ": "blade", "nazwa": "GillShark", "ilosc": 0, "img": "https://i.ibb.co/9k3FVVRz/Gill-Shark-4-70-O-removebg-preview.png", "ATK": 20, "DEF": 25, "STM": 55, "waga": 29.6},
  {
  "id": "45", "typ": "blade", "nazwa": "ShinobiKnife", "ilosc": 0, "img": "img/BladeKnifeShinobi.webp", "ATK": 23, "DEF": 50, "STM": 27, "waga": 30.9},
  {
  "id": "46", "typ": "blade", "nazwa": "TriceraSpiky", "ilosc": 0, "img": "img/Mosasaurus_9-60U.webp", "ATK": 32, "DEF": 55, "STM": 13, "waga": 29.9},
  {
  "id": "47", "typ": "blade", "nazwa": "TyrannoRoar", "ilosc": 0, "img": "https://i.ibb.co/tPBZWyBm/Roar-Tyranno-9-60-GF-removebg-preview.png", "ATK": 60, "DEF": 28, "STM": 12, "waga": 36},
  {
  "id": "48", "typ": "blade", "nazwa": "BearScratch", "ilosc": 0, "img": "https://i.ibb.co/j9522psj/Savage-Bear-3-60-S-removebg-preview.png", "ATK": 25, "DEF": 45, "STM": 30, "waga": 29.6},
  {
  "id": "49", "typ": "blade", "nazwa": "SamuraiSteel", "ilosc": 0, "img": "https://i.ibb.co/DfnHcbRB/Steel-Samurai-4-80-T-removebg-preview.png", "ATK": 40, "DEF": 37, "STM": 23, "waga": 31.2},
  {
  "id": "50", "typ": "blade", "nazwa": "GoatTackle", "ilosc": 0, "img": "https://i.ibb.co/DP9tf85q/Tackle-Goat-2-70-N-removebg-preview.png", "ATK": 13, "DEF": 65, "STM": 22, "waga": 31.5},
  {
  "id": "51", "typ": "blade", "nazwa": "PteraSwing", "ilosc": 0, "img": "https://i.ibb.co/qGKsvTR/Talon-Ptera-3-80-B-removebg-preview.png", "ATK": 27, "DEF": 23, "STM": 50, "waga": 34.4},
  {
  "id": "52", "typ": "blade", "nazwa": "MammothTusk", "ilosc": 0, "img": "https://i.ibb.co/LdzJFYjL/Tusk-Mammoth-3-60-T-removebg-preview.png", "ATK": 33, "DEF": 35, "STM": 32, "waga": 32},
  {
  "id": "53", "typ": "blade", "nazwa": "KongYell", "ilosc": 0, "img": "https://i.ibb.co/6JNHw42Q/Yell-Kong-3-60-GB-removebg-preview.png", "ATK": 13, "DEF": 37, "STM": 50, "waga": 31.1},
  {
  "id": "54", "typ": "blade", "nazwa": "DragoonStorm", "ilosc": 0, "img": "https://i.ibb.co/SDMPrB3G/Dragoon-Storm-4-60-RA-removebg-preview.png", "ATK": 55, "DEF": 30, "STM": 15, "waga": 25.1},
  {
  "id": "55", "typ": "blade", "nazwa": "DranzerSpiral", "ilosc": 0, "img": "img/BladeDranzerSpiral.webp", "ATK": 35, "DEF": 30, "STM": 35, "waga": 27.7},
  {
  "id": "56", "typ": "blade", "nazwa": "DrigerSlash", "ilosc": 0, "img": "img/BladeDrigerSlash.webp", "ATK": 40, "DEF": 35, "STM": 25, "waga": 28.6},
  {
  "id": "57", "typ": "blade", "nazwa": "DracielShield", "ilosc": 0, "img": "img/BladeDracielShield.webp", "ATK": 30, "DEF": 50, "STM": 20, "waga": 28},
  {
  "id": "58", "typ": "blade", "nazwa": "Lightning L-Drago (Rapid-Hit Type)", "ilosc": 0, "img": "img/BladeLightningL-Drago29.webp", "ATK": 50, "DEF": 30, "STM": 20, "waga": 33.5},
  {
  "id": "59", "typ": "blade", "nazwa": "Lightning L-Drago (Upper Type)", "ilosc": 0, "img": "img/BladeLightningL-Drago292.webp", "ATK": 55, "DEF": 25, "STM": 20, "waga": 34},
  {
  "id": "60", "typ": "blade", "nazwa": "Rock Leone", "ilosc": 0, "img": "img/BladeRockLeone.webp", "ATK": 30, "DEF": 55, "STM": 15, "waga": 29.8},
  {
  "id": "61", "typ": "blade", "nazwa": "StormPegasis", "ilosc": 0, "img": "https://i.ibb.co/9HrvgxqN/Storm-Pegasis-3-70-RA-removebg-preview.png", "ATK": 55, "DEF": 15, "STM": 30, "waga": 31},
  {
  "id": "62", "typ": "blade", "nazwa": "Trypio", "ilosc": 0, "img": "img/Trypio_3-60N.webp", "ATK": 0, "DEF": 0, "STM": 0, "waga": 0},
  {
  "id": "63", "typ": "blade", "nazwa": "VictoryValkyrie", "ilosc": 0, "img": "https://i.ibb.co/svvTNN9v/Victory-Valkyrie-2-60-RA-removebg-preview.png", "ATK": 55, "DEF": 20, "STM": 25, "waga": 33.2},
  {
  "id": "64", "typ": "blade", "nazwa": "XenoXcalibur", "ilosc": 0, "img": "img/BladeXenoXcalibur.webp", "ATK": 65, "DEF": 25, "STM": 10, "waga": 31},
   {
  "id": "64", "typ": "blade", "nazwa": "Quetzalcoatlus", "ilosc": 0, "img": "img/Quetzalcoatlus_4-55D-removebg-preview.png", "ATK": 27, "DEF": 23, "STM": 50, "waga": 34.3},
   {
  "id": "65", "typ": "blade", "nazwa": "Spinosaurus", "ilosc": 0, "img": "img/Spinosaurus_3-85A-removebg-preview.png", "ATK": 60, "DEF": 28, "STM": 12, "waga": 36},
   {
  "id": "66", "typ": "blade", "nazwa": "T.Rex", "ilosc": 0, "img": "img/T._Rex_1-80GB.webp", "ATK": 65, "DEF": 30, "STM": 5, "waga": 37},
   {
  "id": "67", "typ": "blade", "nazwa": "Captain America", "ilosc": 0, "img": "img/CaptainAmerica.png", "ATK": 55, "DEF": 28, "STM": 17, "waga": 32.3},
   {
  "id": "68", "typ": "blade", "nazwa": "Green Goblin", "ilosc": 0, "img": "img/Green_Goblin_9-80HT-removebg-preview.png", "ATK": 17, "DEF": 28, "STM": 55, "waga": 31.7},
   {
  "id": "69", "typ": "blade", "nazwa": "Iron Man", "ilosc": 0, "img": "img/Iron_Man_4-80B-removebg-preview.png", "ATK": 17, "DEF": 55, "STM": 28, "waga": 33.6},
   {
  "id": "70", "typ": "blade", "nazwa": "Miles Morales", "ilosc": 0, "img": "img/Miles_Morales_1-60GN-removebg-preview.png", "ATK": 12, "DEF": 33, "STM": 55, "waga": 31.7},
   {
  "id": "71", "typ": "blade", "nazwa": "Red Hulk", "ilosc": 0, "img": "img/Red_Hulk_1-80R-removebg-preview.png", "ATK": 65, "DEF": 27, "STM": 8, "waga": 36.3},
   {
  "id": "72", "typ": "blade", "nazwa": "Spider-Man", "ilosc": 0, "img": "img/Spider-Man_3-60F-removebg-preview.png", "ATK": 33, "DEF": 17, "STM": 50, "waga": 33.2},
   {
  "id": "73", "typ": "blade", "nazwa": "Thanos", "ilosc": 0, "img": "img/Thanos_4-60P-removebg-preview.png", "ATK": 22, "DEF": 60, "STM": 18, "waga": 29.5},
   {
  "id": "74", "typ": "blade", "nazwa": "Venom", "ilosc": 0, "img": "img/Venom_3-80N-removebg-preview.png", "ATK": 55, "DEF": 22, "STM": 23, "waga": 34.3},
   {
  "id": "75", "typ": "blade", "nazwa": "Chewbacca", "ilosc": 0, "img": "img/Chewbacca_4-80LF-removebg-preview.png", "ATK": 22, "DEF": 23, "STM": 55, "waga": 31.8},
   {
  "id": "76", "typ": "blade", "nazwa": "Darth Vader", "ilosc": 0, "img": "img/Darth_Vader_4-60P-removebg-preview.png", "ATK": 28, "DEF": 60, "STM": 12, "waga": 30.7},
   {
  "id": "77", "typ": "blade", "nazwa": "General Grievous", "ilosc": 0, "img": "img/General_Grievous_3-80HN-removebg-preview.png", "ATK": 22, "DEF": 55, "STM": 28, "waga": 31},
   {
  "id": "78", "typ": "blade", "nazwa": "Luke Skywalker", "ilosc": 0, "img": "img/Luke_Skywalker_4-80B-removebg-preview.png", "ATK": 23, "DEF": 55, "STM": 22, "waga": 31.5},
   {
  "id": "79", "typ": "blade", "nazwa": "Moff Gideon", "ilosc": 0, "img": "img/Moff_Gideon_3-80N-removebg-preview.png", "ATK": 32, "DEF": 35, "STM": 33, "waga": 30.5},
   {
  "id": "80", "typ": "blade", "nazwa": "Obi-Wan Kenobi", "ilosc": 0, "img": "img/Obi-Wan_Kenobi_4-60P-removebg-preview.png", "ATK": 23, "DEF": 60, "STM": 17, "waga": 30.6},
   {
  "id": "81", "typ": "blade", "nazwa": "Stormtrooper", "ilosc": 0, "img": "img/Stormtrooper_5-70B-removebg-preview.png", "ATK": 18, "DEF": 50, "STM": 32, "waga": 33.6},
  {
  "id": "82", "typ": "blade", "nazwa": "Mandalorian", "ilosc": 0, "img": "img/The_Mandalorian_3-60F-removebg-preview.png", "ATK": 30.3, "DEF": 40, "STM": 43, "waga": 17},
    {
  "id": "83", "typ": "blade", "nazwa": "Bumblebee", "ilosc": 0, "img": "img/Bumblebee_3-60GP-removebg-preview.png", "ATK": 21, "DEF": 55, "STM": 24, "waga": 34.8},
   {
  "id": "84", "typ": "blade", "nazwa": "Megatron", "ilosc": 0, "img": "img/Megatron_4-80B-removebg-preview.png", "ATK": 27, "DEF": 35, "STM": 38, "waga": 31.1},
 {
  "id": "85", "typ": "blade", "nazwa": "Optimus Primal", "ilosc": 0, "img": "img/Optimus_Primal_3-60F-removebg-preview.png", "ATK": 60, "DEF": 27, "STM": 13, "waga": 35.7},
     {
  "id": "86", "typ": "blade", "nazwa": "Optimus Prime", "ilosc": 0, "img": "img/Optimus_Prime_4-60P-removebg-preview.png", "ATK": 22, "DEF": 55, "STM": 23, "waga": 33.3},
   {
  "id": "87", "typ": "blade", "nazwa": "Shockwave", "ilosc": 0, "img": "img/Shockwave_5-80O-removebg-preview.png", "ATK": 32, "DEF": 18, "STM": 50, "waga": 34.7},
   {
  "id": "88", "typ": "blade", "nazwa": "Starscream", "ilosc": 0, "img": "img/Starscream_3-80N-removebg-preview.png", "ATK": 18, "DEF": 27, "STM": 55, "waga": 29.5},
  
  {
  "id": "96", "typ": "rachet", "nazwa": "1-70", "ilosc": 0, "img": "img/Ratchet1-70.webp", "ATK": 17, "DEF": 6, "STM": 7, "waga": 7.3},
  {
  "id": "97", "typ": "rachet", "nazwa": "2-60", "ilosc": 0, "img": "img/Ratchet2-60.webp", "ATK": 16, "DEF": 8, "STM": 6, "waga": 6.2},
  {
  "id": "98", "typ": "rachet", "nazwa": "2-80", "ilosc": 0, "img": "img/Ratchet2-80.webp", "ATK": 10, "DEF": 11, "STM": 9, "waga": 6.9},
  {
  "id": "99", "typ": "rachet", "nazwa": "3-60", "ilosc": 0, "img": "img/Ratchet3-60.webp", "ATK": 15, "DEF": 9, "STM": 6, "waga": 6.4},
  {
  "id": "100", "typ": "rachet", "nazwa": "3-80", "ilosc": 0, "img": "img/Ratchet3-80.webp", "ATK":15, "DEF": 7, "STM": 8, "waga": 7.1},
  {
  "id": "101", "typ": "rachet", "nazwa": "4-60", "ilosc": 0, "img": "img/Ratchet4-60.webp", "ATK": 11, "DEF": 13, "STM": 6, "waga": 6.3},
  {
  "id": "102", "typ": "rachet", "nazwa": "4-70", "ilosc": 0, "img": "img/Ratchet4-70.webp", "ATK": 11, "DEF": 12, "STM": 7, "waga": 6.4},
  {
  "id": "103", "typ": "rachet", "nazwa": "4-80", "ilosc": 0, "img": "img/Ratchet4-80.webp", "ATK": 11, "DEF": 11, "STM": 8, "waga": 7},
  {
  "id": "104", "typ": "rachet", "nazwa": "5-60", "ilosc": 0, "img": "img/Ratchet5-60.webp", "ATK": 12, "DEF": 9, "STM": 9, "waga": 6.6},
  {
  "id": "105", "typ": "rachet", "nazwa": "5-80", "ilosc": 0, "img": "img/Ratchet5-80.webp", "ATK": 12, "DEF": 8, "STM": 10, "waga": 7.3},
  {
  "id": "106", "typ": "rachet", "nazwa": "6-70", "ilosc": 0, "img": "img/Ratchet6-70.webp", "ATK": 14, "DEF": 7, "STM": 9, "waga": 7.3},
  {
  "id": "107", "typ": "rachet", "nazwa": "7-80", "ilosc": 0, "img": "img/Ratchet7-80.webp", "ATK": 7, "DEF": 14, "STM": 9, "waga": 7.8},
  {
  "id": "108", "typ": "rachet", "nazwa": "9-60", "ilosc": 0, "img": "img/Ratchet9-60.webp", "ATK": 13, "DEF": 10, "STM": 7, "waga": 6.2},
  {
  "id": "109", "typ": "rachet", "nazwa": "9-80", "ilosc": 0, "img": "img/Ratchet9-80.webp", "ATK": 13, "DEF": 10, "STM": 7, "waga": 6.9},
  {
  "id": "110", "typ": "rachet", "nazwa": "M-85", "ilosc": 0, "img": "img/RatchetM-85.webp", "ATK": 8, "DEF": 19, "STM": 13, "waga": 10.6},
  {
  "id": "111", "typ": "rachet", "nazwa": "0-70", "ilosc": 0, "img": "img/Ratchet0-70.webp", "ATK": 3, "DEF": 13, "STM": 14, "waga": 7.0},
  {
  "id": "112", "typ": "rachet", "nazwa": "0-80", "ilosc": 0, "img": "img/Ratchet0-80.webp", "ATK": 3, "DEF": 12, "STM": 15, "waga": 7.6},
  {
  "id": "113", "typ": "rachet", "nazwa": "1-60", "ilosc": 0, "img": "img/Ratchet1-60.webp", "ATK": 17, "DEF": 9, "STM": 4, "waga": 6.0},
  {
  "id": "114", "typ": "rachet", "nazwa": "1-80", "ilosc": 0, "img": "img/Ratchet1-80.webp", "ATK": 17, "DEF": 4, "STM": 9, "waga":6.7},
  {
  "id": "115", "typ": "rachet", "nazwa": "2-70", "ilosc": 0, "img": "img/Ratchet2-70.webp", "ATK": 10, "DEF": 12, "STM": 8, "waga": 6.4},
  {
  "id": "116", "typ": "rachet", "nazwa": "3-70", "ilosc": 0, "img": "img/Ratchet3-70.webp", "ATK": 15, "DEF": 8, "STM": 7, "waga": 6.4},
  {
  "id": "117", "typ": "rachet", "nazwa": "3-85", "ilosc": 0, "img": "img/Ratchet3-85.webp", "ATK": 5, "DEF": 15, "STM": 10, "waga": 4.7},
  {
  "id": "118", "typ": "rachet", "nazwa": "4-50", "ilosc": 0, "img": "img/Ratchet4-50.webp", "ATK": 12, "DEF": 13, "STM": 5, "waga": 5.9},
  {
  "id": "119", "typ": "rachet", "nazwa": "5-70", "ilosc": 0, "img": "img/Ratchet5-70.webp", "ATK": 12, "DEF": 8, "STM": 10, "waga": 6.7},
  {
  "id": "120", "typ": "rachet", "nazwa": "7-60", "ilosc": 0, "img": "img/Ratchet7-60.webp", "ATK": 8, "DEF": 14, "STM": 8, "waga": 7.1},
  {
  "id": "121", "typ": "rachet", "nazwa": "7-70", "ilosc": 0, "img": "img/Ratchet7-70.webp", "ATK": 8, "DEF": 12, "STM": 10, "waga": 7.3},
  {
  "id": "122", "typ": "rachet", "nazwa": "9-70", "ilosc": 0, "img": "img/Ratchet9-70.webp", "ATK": 13, "DEF": 10, "STM": 7, "waga": 6.3},
  {
  "id": "123", "typ": "rachet", "nazwa": "4-55", "ilosc": 0, "img": "img/Ratchet4-55.webp", "ATK": 7, "DEF": 11, "STM": 12, "waga": 4.8 },
  {
  "id": "124", "typ": "rachet", "nazwa": "6-60", "ilosc": 0, "img": "img/Ratchet6-60.webp", "ATK": 14, "DEF": 8, "STM": 8, "waga": 6.1 },
  {
  "id": "125", "typ": "rachet", "nazwa": "6-80", "ilosc": 0, "img": "img/Ratchet6-80.webp", "ATK": 14, "DEF": 6, "STM": 10, "waga": 6.9 },
  {
  "id": "126", "typ": "bit", "nazwa": "Ball", "ilosc": 0, "img": "img/BitBall.webp", "ATK":15, "DEF": 25, "STM": 50, "waga": 2.1, "DASH": 10, "BURST_RES": 30},
  {
  "id": "127", "typ": "bit", "nazwa": "Cyclone", "ilosc": 0, "img": "img/BitCyclone.webp", "ATK": 40, "DEF": 5, "STM": 10, "waga":2.1, "DASH": 45, "BURST_RES": 80},
  {
  "id": "128", "typ": "bit", "nazwa": "Dot", "ilosc": 0, "img": "img/BitDot.webp", "ATK": 10, "DEF": 55, "STM": 25, "waga": 2.0, "DASH": 10, "BURST_RES": 30},
  {
  "id": "129", "typ": "bit", "nazwa": "Elevate", "ilosc": 0, "img": "img/BitElevate.webp", "ATK": 30, "DEF": 15, "STM": 20, "waga": 3.2, "DASH": 35, "BURST_RES": 30},
  {
  "id": "130", "typ": "bit", "nazwa": "Flat", "ilosc": 0, "img": "img/BitFlat.webp", "ATK": 40, "DEF": 15, "STM": 10, "waga": 2.2, "DASH": 35, "BURST_RES": 80},
  {
  "id": "131", "typ": "bit", "nazwa": "Gear Ball", "ilosc": 0, "img": "img/BitGearBall.webp", "ATK": 10, "DEF": 15, "STM": 45, "waga": 2.0, "DASH": 30, "BURST_RES": 30},
  {
  "id": "132", "typ": "bit", "nazwa": "Gear Flat", "ilosc": 0, "img": "img/BitGearFlat.webp", "ATK": 50, "DEF": 5, "STM": 5, "waga": 2.3, "DASH": 40, "BURST_RES": 80},
  {
  "id": "133", "typ": "bit", "nazwa": "Gear Needle", "ilosc": 0, "img": "img/BitGearNeedle.webp", "ATK": 20, "DEF": 40, "STM": 10, "waga": 2.0, "DASH": 30, "BURST_RES": 30},
  {
  "id": "134", "typ": "bit", "nazwa": "Gear Point", "ilosc": 0, "img": "img/BitGearPoint.webp", "ATK": 30, "DEF": 25, "STM": 15, "waga": 2.3, "DASH": 30, "BURST_RES": 80},
  {
  "id": "135", "typ": "bit", "nazwa": "High Needle", "ilosc": 0, "img": "img/BitHighNeedle.webp", "ATK": 15, "DEF": 55, "STM": 20, "waga": 2.2, "DASH": 10, "BURST_RES": 30},
  {
  "id": "136", "typ": "bit", "nazwa": "High Taper", "ilosc": 0, "img": "img/BitHighTaper.webp", "ATK": 30, "DEF": 25, "STM": 20, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "137", "typ": "bit", "nazwa": "Low Flat", "ilosc": 0, "img": "img/BitLowFlat.webp", "ATK": 45, "DEF": 5, "STM": 10, "waga": 2.1, "DASH": 40, "BURST_RES": 80},
  {
  "id": "138", "typ": "bit", "nazwa": "Merge", "ilosc": 0, "img": "img/BitMerge.webp", "ATK": 50, "DEF": 20, "STM": 10, "waga": 3.4, "DASH": 20, "BURST_RES": 80},
  {
  "id": "139", "typ": "bit", "nazwa": "Needle", "ilosc": 0, "img": "img/BitNeedle.webp", "ATK": 10, "DEF": 50, "STM": 30, "waga": 2.0, "DASH": 10, "BURST_RES": 30},
  {
  "id": "140", "typ": "bit", "nazwa": "Orb", "ilosc": 0, "img": "img/BitOrb.webp", "ATK": 10, "DEF": 30, "STM": 50, "waga": 2.0, "DASH": 10, "BURST_RES": 30},
  {
  "id": "141", "typ": "bit", "nazwa": "Point", "ilosc": 0, "img": "img/BitPoint.webp", "ATK": 25, "DEF": 25, "STM": 25, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "142", "typ": "bit", "nazwa": "Quake", "ilosc": 0, "img": "img/BitQuake.webp", "ATK": 55, "DEF": 15, "STM": 5, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "143", "typ": "bit", "nazwa": "Rush", "ilosc": 0, "img": "img/BitRush.webp", "ATK": 40, "DEF": 10, "STM": 20, "waga": 2.1, "DASH": 30, "BURST_RES": 80},
  {
  "id": "144", "typ": "bit", "nazwa": "Spike", "ilosc": 0, "img": "img/BitSpike.webp", "ATK": 10, "DEF": 45, "STM": 35, "waga": 2, "DASH": 10, "BURST_RES": 30},
  {
  "id": "145", "typ": "bit", "nazwa": "Taper", "ilosc": 0, "img": "img/BitTaper.webp", "ATK": 35, "DEF": 20, "STM": 20, "waga": 2.2, "DASH": 25, "BURST_RES": 80},
  {
  "id": "146", "typ": "bit", "nazwa": "Trans Point", "ilosc": 0, "img": "img/BitTransPoint.webp", "ATK": 35, "DEF": 25, "STM": 25, "waga": 2.4, "DASH": 15, "BURST_RES": 80},
  {
  "id": "147", "typ": "bit", "nazwa": "Unite", "ilosc": 0, "img": "img/BitUnite.webp", "ATK": 25, "DEF": 25, "STM": 30, "waga": 2.1, "DASH": 25, "BURST_RES": 80},
  {
  "id": "148", "typ": "bit", "nazwa": "Accel", "ilosc": 0, "img": "img/BitAccel.webp", "ATK": 40, "DEF": 10, "STM": 10, "waga": 2.6, "DASH": 40, "BURST_RES": 80},
  {
  "id": "149", "typ": "bit", "nazwa": "Bound Spike", "ilosc": 0, "img": "img/BitBoundSpike.webp", "ATK": 5, "DEF": 60, "STM": 30, "waga": 2.0, "DASH": 5, "BURST_RES": 30},
  {
    "typ": "cx-lock-chip",
    "nazwa": "Dran",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipDran.webp",
    "id": "150"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Cerberus",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipCerberus.webp",
    "id": "151"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Fox",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipFox.webp",
    "id": "152"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Hornet",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipHornet.webp",
    "id": "153"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Kraken",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipKraken.webp",
    "id": "154"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Leon",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipLeon.webp",
    "id": "155"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Pegasus",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipPegasus.webp",
    "id": "156"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Perseus",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipPerseus.webp",
    "id": "157"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Rhino",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipRhino.webp",
    "id": "158"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Sol",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipSol.webp",
    "id": "159"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Stag",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipStag.webp",
    "id": "160"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Valkyrie",
    "ilosc": 0,
    "waga": 5.6,
    "img": "img/LockChipValkyrie.webp",
    "id": "161"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Whale",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipWhale.webp",
    "id": "162"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Wizard",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipWizard.webp",
    "id": "163"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Flame",
    "ilosc": 0,
    "ATK": 5,
    "DEF": 15,
    "STM": 40,
    "waga": 28.5,
    "img": "img/MainBladeFlame.webp",
    "id": "164"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Antler",
    "ilosc": 0,
    "ATK": 8,
    "DEF": 15,
    "STM": 37,
    "waga": 28.8,
    "img": "img/Antler.webp",
    "id": "165"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Arc",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 10,
    "STM": 40,
    "waga": 29.2,
    "img": "img/MainBladeArc.webp",
    "id": "166"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Blast",
    "ilosc": 0,
    "ATK": 50,
    "DEF": 10,
    "STM": 15,
    "waga": 32.8,
    "img": "img/MainBladeBlast.webp",
    "id": "167"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Brave",
    "ilosc": 0,
    "ATK": 40,
    "DEF": 10,
    "STM": 10,
    "waga": 31.2,
    "img": "img/MainBladeBrave.webp",
    "id": "168"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Brush",
    "ilosc": 0,
    "ATK": 40,
    "DEF": 15,
    "STM": 5,
    "waga": 30.3,
    "img": "img/MainBladeBrush.webp",
    "id": "169"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Dark",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 40,
    "STM": 10,
    "waga": 30.3,
    "img": "img/MainBladeDark.webp",
    "id": "170"
  },
{
  "id": "171",
  "typ": "cx-main-blade",
  "nazwa": "Eclipse",
  "ilosc": 0,
  "maTryby": true,
  "tryby": [
    {
      "nazwaTrybu": "Upper",
      "img": "img/eclipse.png",
      "ATK": 0,
      "DEF": 0,
      "STM": 0,
      "waga": 0
    },
    {
      "nazwaTrybu": "Smash",
      "img": "img/MainBladeEclipse_29.webp",
      "ATK": 0,
      "DEF": 0,
      "STM": 0,
      "waga": 0
    }
  ]
},


  {
    "typ": "cx-main-blade",
    "nazwa": "Fang",
    "ilosc": 0,
    "ATK": 35,
    "DEF": 10,
    "STM": 15,
    "waga": 29.1,
    "img": "img/MainBladeFang.webp",
    "id": "172"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Fort",
    "ilosc": 0,
    "ATK": 24,
    "DEF": 12,
    "STM": 24,
    "waga": 29.0,
    "img": "img/MainBladeFort.webp",
    "id": "173"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Reaper",
    "ilosc": 0,
    "ATK": 25,
    "DEF": 10,
    "STM": 25,
    "waga": 29.0,
    "img": "img/MainBladeReaper.webp",
    "id": "174"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Volt",
    "ilosc": 0,
    "ATK": 45,
    "DEF": 15,
    "STM": 15,
    "waga": 31.0,
    "img": "img/MainBladeVolt.webp",
    "id": "175"
  },
  {
    "typ": "cx-main-blade",
    "nazwa": "Wriggle",
    "ilosc": 0,
    "ATK": 18,
    "DEF": 2,
    "STM": 40,
    "waga": 29.3,
    "img": "img/MainBladeWriggle.webp",
    "id": "176"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Assault",
    "ilosc": 0,
    "ATK": 25,
    "DEF": 10,
    "STM": 5,
    "waga": 5,
    "img": "img/AssistBladeAssault.webp",
    "id": "177"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Bumper",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 20,
    "STM": 10,
    "waga": 5.3,
    "img": "img/AssistBladeBumper.webp",
    "id": "178"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Charge",
    "ilosc": 0,
    "ATK": 15,
    "DEF": 20,
    "STM": 5,
    "waga": 5.0,
    "img": "img/AssistBladeCharge.webp",
    "id": "179"
  },

    {
    "id": "180",
    "typ": "cx-assist-blade",
    "nazwa": "Dual",
    "ilosc": 0,
    "maTryby": true,
    "tryby": [
      {
        "nazwaTrybu": "Upper",
        "img": "img/AssistBladeDual.webp",
        "ATK": 0,
        "DEF": 0,
        "STM": 0,
        "waga": 0
      },
      {
        "nazwaTrybu": "Smash",
        "img": "img/AssistBladeDual_29.webp",
        "ATK": 0,
        "DEF": 0,
        "STM": 0,
        "waga": 0
      }
    ]
  },

  {
    "typ": "cx-assist-blade",
    "nazwa": "Jaggy",
    "ilosc": 0,
    "ATK": 20,
    "DEF": 15,
    "STM": 5,
    "waga": 4.9,
    "img": "img/AssistBladeJaggy.webp",
    "id": "181"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Massive",
    "ilosc": 0,
    "ATK": 15,
    "DEF": 15,
    "STM": 10,
    "waga": 5.3,
    "img": "img/AssistBladeMassive.webp",
    "id": "182"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Round",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 10,
    "STM": 20,
    "waga": 4.7,
    "img": "img/AssistBladeRound.webp",
    "id": "183"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Slash",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 20,
    "STM": 10,
    "waga": 4.7,
    "img": "img/AssistBladeSlash.webp",
    "id": "184"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Turn",
    "ilosc": 0,
    "ATK": 10,
    "DEF": 10,
    "STM": 20,
    "waga": 5.8,
    "img": "img/AssistBladeTurn.webp",
    "id": "185"
  },
  {
    "typ": "cx-assist-blade",
    "nazwa": "Wheel",
    "ilosc": 0,
    "ATK": 5,
    "DEF": 15,
    "STM": 20,
    "waga": 7.2,
    "img": "img/AssistBladeWheel.webp",
    "id": "186"
  },
  {
    "typ": "cx-lock-chip",
    "nazwa": "Hells",
    "ilosc": 0,
    "waga": 1.7,
    "img": "img/LockChipHells.webp",
    "id": "187"
  },
  {
    "id": "188",
    "typ": "bit",
    "nazwa": "Gear Rush",
    "ilosc": 0,
    "img": "img/BitGearRush.webp",
    "ATK": 45,
    "DEF": 10,
    "STM": 10,
    "waga": 2.1,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "189",
    "typ": "bit",
    "nazwa": "Kick",
    "ilosc": 0,
    "img": "img/BitKick.webp",
    "ATK": 35,
    "DEF": 25,
    "STM": 15,
    "waga": 2.2,
    "DASH": 25,
    "BURST_RES": 80
  },
  {
    "id": "190",
    "typ": "bit",
    "nazwa": "Low Orb",
    "ilosc": 0,
    "img": "img/BitLowOrb.webp",
    "ATK": 5,
    "DEF": 25,
    "STM": 55,
    "waga": 1.85,
    "DASH": 15,
    "BURST_RES": 30
  },
  {
    "id": "191",
    "typ": "bit",
    "nazwa": "Trans Kick",
    "ilosc": 0,
    "img": "img/BitTransKick.webp",
    "ATK": 35,
    "DEF": 30,
    "STM": 20,
    "waga": 2.3,
    "DASH": 15,
    "BURST_RES": 80
  },
  {
    "id": "192",
    "typ": "bit",
    "nazwa": "Vortex",
    "ilosc": 0,
    "img": "img/BitVortex.webp",
    "ATK": 45,
    "DEF": 10,
    "STM": 5,
    "waga": 2.2,
    "DASH": 40,
    "BURST_RES": 80
  },
  {
    "id": "193_wallball", 
    "typ": "bit",
    "nazwa": "Wall Ball",
    "ilosc": 0,
    "img": "img/BitWallBall.webp",
    "ATK": 15,
    "DEF": 30,
    "STM": 45,
    "waga": 2.41,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "193_wedge", 
    "typ": "bit",
    "nazwa": "Wedge",
    "ilosc": 0,
    "img": "img/BitWedge.webp",
    "ATK": 5,
    "DEF": 55,
    "STM": 30,
    "waga": 1.83,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "194",
    "typ": "bit",
    "nazwa": "Disk Ball",
    "ilosc": 0,
    "img": "img/BitDiskBall.webp",
    "ATK": 15,
    "DEF": 20,
    "STM": 55,
    "waga": 3.2,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "195",
    "typ": "bit",
    "nazwa": "Free Ball",
    "ilosc": 0,
    "img": "img/BitFreeBall.webp",
    "ATK": 10,
    "DEF": 25,
    "STM": 60,
    "waga": 1.9,
    "DASH": 15,
    "BURST_RES": 30
  },
  {
    "id": "196",
    "typ": "bit",
    "nazwa": "Glide",
    "ilosc": 0,
    "img": "img/BitGlide.webp",
    "ATK": 20,
    "DEF": 10,
    "STM": 55,
    "waga": 2.5,
    "DASH": 15,
    "BURST_RES": 30
  },
  {
    "id": "197",
    "typ": "bit",
    "nazwa": "Hexa",
    "ilosc": 0,
    "img": "img/BitHexa.webp",
    "ATK": 30,
    "DEF": 35,
    "STM": 20,
    "waga": 2.6,
    "DASH": 15,
    "BURST_RES": 80
  },
  {
    "id": "198",
    "typ": "bit",
    "nazwa": "Level",
    "ilosc": 0,
    "img": "img/BitLevel.webp",
    "ATK": 40,
    "DEF": 5,
    "STM": 15,
    "waga": 2.7,
    "DASH": 40,
    "BURST_RES": 80
  },
  {
    "id": "199",
    "typ": "bit",
    "nazwa": "Low Rush",
    "ilosc": 0,
    "img": "img/BitLowRush.webp",
    "ATK": 45,
    "DEF": 5,
    "STM": 10,
    "waga": 1.9,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "200",
    "typ": "bit",
    "nazwa": "Metal Needle",
    "ilosc": 0,
    "img": "img/BitMetalNeedle.webp",
    "ATK": 8,
    "DEF": 57,
    "STM": 30,
    "waga": 2.8,
    "DASH": 5,
    "BURST_RES": 30
  },
  {
    "id": "201",
    "typ": "bit",
    "nazwa": "Rubber Accel",
    "ilosc": 0,
    "img": "img/BitRubberAccel.webp",
    "ATK": 60,
    "DEF": 17,
    "STM": 3,
    "waga": 3.1,
    "DASH": 20,
    "BURST_RES": 80
  },
  {
    "id": "202",
    "typ": "bit",
    "nazwa": "Under Flat",
    "ilosc": 0,
    "img": "img/BitUnderFlat.webp",
    "ATK": 55,
    "DEF": 5,
    "STM": 5,
    "waga": 2.0,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "203",
    "typ": "bit",
    "nazwa": "Under Needle",
    "ilosc": 0,
    "img": "img/BitUnderNeedle.webp",
    "ATK": 10,
    "DEF": 60,
    "STM": 20,
    "waga": 1.9,
    "DASH": 10,
    "BURST_RES": 30
  },
  {
    "id": "204",
    "typ": "bit",
    "nazwa": "Zap",
    "ilosc": 0,
    "img": "img/BitZap.webp",
    "ATK": 30,
    "DEF": 20,
    "STM": 15,
    "waga": 2.5,
    "DASH": 35,
    "BURST_RES": 80
  },
  {
    "id": "205",
    "typ": "rachet",
    "nazwa": "Turbo",
    "ilosc": 0,
    "img": "img/RatchetBitTurbo.webp",
    "ATK": 30,
    "DEF": 30,
    "STM": 60,
    "waga": 9.0,
    "DASH": 10,
    "BURST_RES": 30,
    "integrujeBit": true
 },
  {
  "id": "206", "typ": "blade", "nazwa": "ClockMirage", "ilosc": 0, "img": "img/BladeClockMirage.webp", "ATK": 0, "DEF": 0, "STM": 0, "waga": 0}
  
  
]




</script>


</body>
</html>


